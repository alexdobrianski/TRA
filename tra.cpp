/***********************************************************************
     
    2009-2015 (C) Alex Dobrianski tra.cpp oprbit calculation app

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>
************************************************************************/

#define _CRT_SECURE_NO_WARNINGS 1
//#define _WIN32_WINNT 0x05010000

#include "stdafx.h"
#include <afxinet.h>
#include <afxsock.h>

#define _USE_MATH_DEFINES 1
#include <math.h>
#include <stdio.h>
#include <malloc.h>
#include "ephem_read.h"

//////////////////////////////////////////////////////////////////////////////
//   predefine vaiable to build different flavor
//#define FIND_IMPULSE_TIME 1
//////////////////////////////////////////////////////////////////////////////

#ifdef _DO_VISUALIZATION
#include "JPEGLIB.H"
void write_JPEG_file (char * filename, int quality, int SizeW, int SizeH, int SizeB, unsigned char *bArray, J_COLOR_SPACE ColorCode);
#endif

#define MERCURY 0
#define VENUS 1
#define EARTH 2
#define MARS 3
#define JUPITER 4
#define SATURN 5
#define URANUS 6
#define NEPTUNE 7
#define PLUTO 8
#define MOON  9
#define SUN 10

#define PLANET_COUNT 11
    // Earth gravitation model
    // earth GEM-T3 3.98600436E5 6378.137
    // earth 1082.6260745913E-6 -2.5325160653E-6 -1.6185636000E-6 -0.2266690830E-6 0.5390785906E-6
    // C21 -0.0002194691E-6 S21 +0:0015362834E-6 C22 +1.5744102040E-6 S22 0.9037571782E-6
    // earth JGM3 3.986004415E5 6378.1363
	// earth 1082.6360229830E-6 -2.5324353458E-6 -1.6193312052E-6 -0.2277161017E-6 +0.5396484905E-6
    // C21 -0.0002414000E-6 S21 +0.0015431000E-6 C22 +1.5745360428E-6 S22 -0.9038680730E-6
    // see http://www.csr.utexas.edu/publications/statod/TabD.3.new.txt
	// New table containing conventional gravity coefficients generated from
	// Table D.1 (normalized gravity coefficients)
	//Table D.3 JGM-3 Earth Gravity Field (Conventional Coefficients)
#define _NORMALIZED_COEF 1

#define MAX_COEF_J 18

#define TOTAL_COEF 360
int iCounter_nk_lm_Numbers;
int nk_lm_Numbers[(TOTAL_COEF+3)*(TOTAL_COEF+3)][2];
long double C_S_nk[(TOTAL_COEF+3)*(TOTAL_COEF+3)][2];

char szMassPointsModelFile[1024];
long double MinH;
long double MaxH;
char MidRandPointsFile[1024];
typedef struct MassPointElement
{
    long double X;
    long double Y;
	long double Z;
	long double Mp;
} MASS_POINT_ELEMENT, *PMASS_POINT_ELEMENT;

MASS_POINT_ELEMENT MassPoints[(TOTAL_COEF+3)*(TOTAL_COEF+3)];
#define MAX_CHECK_POINTS 1000
long double TotalCheckPoints[MAX_CHECK_POINTS][3];

    	
    // see http://vadimchazov.narod.ru/lepa_zov/lesat.pdf
    // P0 == P[0](x) = 1
    // P1 == P[1](x) = x
    // PN == P[N+1](x) = (x*P[N](x)*(2*n+1) - n*P[N-1](x))/(n+1)
    // sample:
    // P2(x) == P[2](x) = 1/2 *(-1+3*x*x)
    // P3(x) == P[3](x) = 1/2 *(-3*x+5*x*x*x)
    // PNK(x) = pow((1-x*x),k/2)* dK(PN(x)/dxK
    // = pow((1-x*x),k/2)* dK((x*P[N](x)*(2*n+1) - n*P[N-1](x))/(n+1))/dxK
    // P21(x) = 3*x*sqrt(1-x*x)
    // P22(x) = 3*(1-x*x)
    // P31(x) = 3/2*(-1+5*x*x)*sqrt(1-x*x)
    // P32(x) = 15*x*(1-x*x)
    // P33(x) = 15*x*pow((1-x*x),3/2)
    // P41(x) = 5/2*(-3*x+7*x*x*x*)*sqrt(1-x*x)
    // P42(x) = 15/2*(-1+7*x*x*)*sqrt(1-x*x)
	// JN = -sqrt(2*n+1) Cl0 from Table D.3
    // CNK = sqrt(2*(2*n+1)) * sqrt(((n-k)!/(n+k)!) * Clm
    // SNK = sqrt(2*(2*n+1) * sqrt((n-k)!/(n+k)!)) * Slm
    // but coeffs from http://www.csr.utexas.edu/publications/statod/TabD.3.new.txt
    // just needs to copy it
	// FM/r * 
	//( 1 
    //	- J2 * (r0/r)**2 * P2(sinPHI)  
    //	- J3 * (r0/r)**3 * P3(sinPHI) 
    //  - J4 * (r0/r)**4 * P4(sinPHI)
    //  - J5 * (r0/r)**5 * P5(sinPHI)
    //  - J6 * (r0/r)**6 * P6(sinPHI)
    //  - J7 * (r0/r)**7 * P7(sinPHI)
    //  - J8 * (r0/r)**8 * P8(sinPHI)
    //  + SUM2=( (r0/r)**2 * P21(sinPHI) * (C21 * cos(1*Lambda) + S21*sin(1*Lanbda)) +
    //           (r0/r)**2 * P22(sinPhi) * (C22 *cos(2*Lambda) + S22*sin(2*Lambda))     )
    //    SUM3=( (r0/r)**3 *P31(sinPHI) * (C31 * cos(1*Lambda) + S31*sin(1*Lambda)) +
    //           (r0/r)**3 *P32(sinPHI) * (C32 * cos(2*Lambda) + S32*sin(2*Lambda)) +
    //           (r0/r)**3 *P33(sinPHI) * (C33 * cos(3*Lambda) + S33*sin(3*Lambda))      )
    //  SUM4= ( (r0/r)**4 *P41(sinPHI) * (C41 * cos(1*Lambda) + S41*sin(1*Lambda)) +
    //          (r0/r)**4 *P42(sinPHI) * (C42 * cos(2*Lambda) + S42*sin(2*Lambda)) +
    //          (r0/r)**4 *P43(sinPHI) * (C43 * cos(3*Lambda) + S43*sin(3*Lambda)) +
    //          (r0/r)**4 *P44(sinPHI) * (C44 * cos(4*Lambda) + S44*sin(3*Lambda))     )
    //  SUM5= ( (r0/r)**5 *P51(sinPHI) * (C51 * cos(1*Lambda) + S51*sin(1*Lambda)) +
    //          (r0/r)**5 *P52(sinPHI) * (C52 * cos(2*Lambda) + S52*sin(2*Lambda)) +
    //          (r0/r)**5 *P53(sinPHI) * (C53 * cos(3*Lambda) + S53*sin(3*Lambda)) +
    //          (r0/r)**5 *P54(sinPHI) * (C54 * cos(4*Lambda) + S54*sin(4*Lambda)) +
    //          (r0/r)**5 *P55(sinPHI) * (C55 * cos(5*Lambda) + S55*sin(5*Lambda))         )
    //  SUM6= ( (r0/r)**6 *P61(sinPHI) * (C61 * cos(1*Lambda) + S61*sin(1*Lambda)) +
    //          (r0/r)**6 *P62(sinPHI) * (C62 * cos(2*Lambda) + S62*sin(2*Lambda)) +
    //          (r0/r)**6 *P63(sinPHI) * (C63 * cos(3*Lambda) + S63*sin(3*Lambda)) +
    //          (r0/r)**6 *P64(sinPHI) * (C64 * cos(4*Lambda) + S64*sin(4*Lambda)) +
    //          (r0/r)**6 *P65(sinPHI) * (C65 * cos(5*Lambda) + S65*sin(5*Lambda)) +
    //          (r0/r)**6 *P66(sinPHI) * (C66 * cos(6*Lambda) + S66*sin(6*Lambda))         )
    //  SUM7= ( (r0/r)**7 *P71(sinPHI) * (C71 * cos(1*Lambda) + S71*sin(1*Lambda)) +
    //          (r0/r)**7 *P72(sinPHI) * (C72 * cos(2*Lambda) + S72*sin(2*Lambda)) +
    //          (r0/r)**7 *P73(sinPHI) * (C73 * cos(3*Lambda) + S73*sin(3*Lambda)) +
    //          (r0/r)**7 *P74(sinPHI) * (C74 * cos(4*Lambda) + S74*sin(4*Lambda)) +
    //          (r0/r)**7 *P75(sinPHI) * (C75 * cos(5*Lambda) + S75*sin(5*Lambda)) +
    //          (r0/r)**7 *P76(sinPHI) * (C76 * cos(6*Lambda) + S76*sin(6*Lambda)) +
    //          (r0/r)**7 *P76(sinPHI) * (C77 * cos(7*Lambda) + S77*sin(7*Lambda))        )
    //  SUM8= ( (r0/r)**8 *P81(sinPHI) * (C81 * cos(1*Lambda) + S81*sin(1*Lambda)) +
    //          (r0/r)**8 *P82(sinPHI) * (C82 * cos(2*Lambda) + S82*sin(2*Lambda)) +
    //          (r0/r)**8 *P83(sinPHI) * (C83 * cos(3*Lambda) + S83*sin(3*Lambda)) +
    //          (r0/r)**8 *P84(sinPHI) * (C84 * cos(4*Lambda) + S84*sin(4*Lambda)) +
    //          (r0/r)**8 *P85(sinPHI) * (C85 * cos(5*Lambda) + S85*sin(5*Lambda)) +
    //          (r0/r)**8 *P86(sinPHI) * (C86 * cos(6*Lambda) + S86*sin(6*Lambda)) +
    //          (r0/r)**8 *P87(sinPHI) * (C87 * cos(7*Lambda) + S86*sin(7*Lambda)) +
    //          (r0/r)**8 *P88(sinPHI) * (C88 * cos(8*Lambda) + S86*sin(8*Lambda))         )

    // moon 0.0002027


    long double __AH[2][7] = {            120,         120,         120,          120,         120,         120,         120,
                                          500,         500,         500,          500,         500,         500,         500};

    long double __AO[2][7][7] = {     26.8629,     27.4598,     28.6395,      29.6418,     30.1671,     29.7578,     30.7854,
                                    -0.451674,   -0.463668,   -0.490987,    -0.514957,   -0.527837,   -0.517915,   -0.545695,
                                   0.00290397,    0.002974,  0.00320649,   0.00341926,  0.00353211,  0.00342699,  0.00370328,
                                  -1.06953e-5,  -1.0753e-5,  -1.1681e-5,  -1.25785e-5, -1.30227e-5, -1.24137e-5, -1.37072e-5,
                                   2.21598e-8,  2.17059e-8,  2.36847e-8,    2.5727e-8,  2.66455e-8,  2.48209e-8,  2.80614e-8,
                                 -2.42941e-11,-2.30249e-11,-2.51809e-11, -2.75874e-11,-2.85432e-11,-2.58413e-11,-3.00184e-11,
                                  1.09926e-14, 1.00123e-14, 1.09536e-14,  1.21091e-14, 1.25009e-14, 1.09383e-14, 1.31142e-14,

                                      17.8781,    -2.54909,    -13.9599,     -23.3079,    -14.7264,      -4.912,    -5.40952,
                                    -0.132025,   0.0140064,   0.0844951,     0.135141,   0.0713256,   0.0108326,  0.00550749,
                                  0.000227717, -0.00016946,-0.000328875, -0.000420802,-0.000228015, -8.10546e-5, -3.78851e-5,
                                   -2.2543e-7,  3.27196e-7,  5.05918e-7,   5.73717e-7,   2.8487e-7,  1.15712e-7,   2.4808e-8,
                                  1.33574e-10, -2.8763e-10,-3.92299e-10, -4.03238e-10,-1.74383e-10, -8.13296e-11,4.92183e-12,
                                 -4.50458e-14, 1.22625e-13, 1.52279e-13,  1.42846e-13, 5.08071e-14, 3.04913e-14,-8.65011e-15,
                                 6.72086e-18,-2.05736e-17,-2.35576e-17, -2.01726e-17,-5.34955e-18,-4.94989e-18,  1.9849e-18};


    long double __BH[2][7] = {            120,         120,         120,          120,         120,         120,         120,
                                          600,         660,         760,          800,         860,         920,         980};

    long double __BO[2][5][7] = {   0.0687894,     0.15073,   0.0479451,    0.0223448, -0.00326391,  -0.0514749,   -0.107255,
                                  -0.00284077, -0.00400889, -0.00239453,   -0.0019798, -0.00159869,-0.000921059,-0.000174343,
                                   1.83922e-5,  2.43937e-5,  1.70335e-5,   1.54101e-5,  1.40443e-5,  1.15147e-5,  9.02759e-6,
                                   9.19605e-9, -9.92772e-9, -1.31626e-9,   -2.3543e-9, -3.02287e-9,- 1.22901e-9,-3.16512e-10,
                                 -4.16873e-11,-1.82239e-11,-1.74032e-11, -1.24994e-11, -9.2016e-12,-8.13104e-12,   -6.14e-12,

                                      23.1584,     33.2732,     39.1961,     43.2469,      49.5738,      11.278,    -52.6184,
                                   -0.0802147,   -0.111099,    -0.12352,   -0.126973,    -0.138613,  0.00143478,    0.214689,
                                  0.000105824, 0.000141421, 0.000149015, 0.000142637,  0.000147851, -3.69846e-5,-0.000294882,
                                  -6.15036e-8, -7.94952e-8,  -7.9705e-8, -7.09985e-8,  -6.96361e-8,  3.58318e-8,  1.71171e-7,
                                  1.32453e-11, 1.65836e-11, 1.58772e-11, 1.31646e-11,  1.21595e-11,-9.91225e-12,-3.60582e-11};


    long double __CH[2][7] = {            120,         120,         120,          120,         120,         120,         120,  
                                         640,         700,         760,          820,         860,         920,         980};

    long double __CO[2][5][7] = {    -1.04825,    -0.93106,   -0.820867,    -0.744047,   -0.722471,   -0.687482,   -0.739984,
                                    0.0166305,   0.0141537,   0.0119916,    0.0104743,  0.00980317,  0.00916594,  0.00952854,
                                  -9.24263e-5, -7.29862e-5, -5.79835e-5,  -4.78544e-5, -4.25245e-5, -3.80932e-5, -3.62727e-5,
                                   2.72382e-7,  2.00294e-7,  1.50707e-7,   1.18513e-7,  9.95544e-8,  8.51275e-8,   7.3887e-8,
                                 -2.41355e-10,-1.62006e-10,-1.13026e-10, -8.31498e-11,-6.55175e-11,-5.29972e-11,-4.23907e-11,

                                      50.5034,      61.624,     53.2623,      18.2236,    -31.8442,    -48.7208,    -147.859,
                                    -0.170541,   -0.192967,   -0.144342,  -0.00840024,    0.168327,    0.222996,    0.531652,
                                   2.17232e-4,  2.28061e-4,   1.4659e-4,     -3.88e-5, -2.62603e-4, -3.21884e-4,  -671937e-4,
                                  -1.21902e-7, -1.18715e-7, -6.46443e-8,  4.31384e-8,   1.65454e-7,  1.91495e-7,  3.64787e-7,
                                  2.54037e-11, 2.29638e-11, 1.04227e-11,-1.23832e-11, -3.69355e-11,-4.08067e-11,-7.26268e-11};



    long double __NO[2][3][7] = {      2.058,       2.058,       2.058,        2.058,       2.058,       2.058,        2.058,
                                    5.887e-3,    5.887e-3,    5.887e-3,     5.887e-3,    5.887e-3,    5.887e-3,     5.887e-3,
                                   -4.012e-6,   -4.012e-6,   -4.012e-6,    -4.012e-6,   -4.012e-6,   -4.012e-6,    -4.012e-6,

                                       2.058,       2.058,       2.058,        2.058,       2.058,       2.058,        2.058,
                                    5.887e-3,    5.887e-3,    5.887e-3,     5.887e-3,    5.887e-3,    5.887e-3,     5.887e-3,
                                    -4.012e-6,   -4.012e-6,   -4.012e-6,    -4.012e-6,   -4.012e-6,   -4.012e-6,    -4.012e-6};


    long double __FEO[2][1][7] = {     0.5411,     0.5515,      0.5585,       0.5585,      0.5585,      0.5585,       0.5585,
                                       0.5411,     0.5515,      0.5585,       0.5585,      0.5585,      0.5585,       0.5585};

    long double __DH[2][7] = {            120,         120,         120,          120,         120,         120,         120,  
                                         1500,        1500,        1500,         1500,        1500,        1500,        1500};

    long double __DO[2][5][7] =  { -0.351899,   -0.047813,     0.20981,     0.265174,     0.23047,    0.170074,     0.088141,
                                   0.0057056,  0.00380813,  0.00262881,   0.00275836,  0.00338331,  0.00406131,   0.00468253,
                                   9.95819e-7,   4.2271e-6,   4.24379e-6,    2.08668e-6,   -5.52305e-7,-  2.82114e-6,    -4.24609e-6,
                                  -7.25324e-9,  -8.66826e-9, -6.67328e-9,  -3.69543e-9, -8.23607e-10,  1.38369e-9,   2.53509e-9,
                                   2.9759e-12,  3.06712e-12, 2.13496e-12,   1.11862e-12,  2.21349e-13, -4.27908e-13,   -7.29031e-13,   

                                   -0.351899,   -0.047813,     0.20981,     0.265174,     0.23047,    0.170074,     0.088141,
                                  0.00577056,  0.00380813,  0.00262881,   0.00275836,  0.00338331,  0.00406131,   0.00468253,
                                  9.95819e-7,  4.22771e-6,  4.24379e-6,   2.08668e-6, -5.52305e-7, -2.82114e-6,  -4.24609e-6,
                                 -7.25324e-9, -8.66826e-9, -6.67328e-9,  -3.69543e-9,-8.23607e-10,  1.38369e-9,   2.53509e-9,
                                 2.9759e-12, 3.06712e-12, 2.13496e-12,  1.11862e-12, 2.21349e-13,-4.27908e-13, -7.29031e-13};

   long double __EH[2][7] = {            120,         120,         120,          120,         120,         120,         120,  
                                         600,         700,         780,          800,         800,         900,         960};

    long double __EO[2][9][7] =  {  -0.731596,    -0.752175,    -0.570476,     -0.949573,    -0.967598,     -1.02278,-   0.757903,
                                   0.00597345,  0.00565925,  2.95802e-3,   8.13121e-3,  8.41991e-3,  9.23633e-3,   0.00606068,
                                  -5.82037e-6,   1.8082e-6,  1.68896e-5,-   3.87813e-6,    -3.585e-6,  -6.10128e-6,   7.85296e-6,
                                  6.84634e-8,  3.33822e-8,-   4.7475e-9,   2.37694e-8,  1.74801e-8,  1.78211e-8,   -9.74891e-9,
                                 -9.50483e-11, -5.13965e-11, -1.72711e-11,-   2.7469e-11, -1.96221e-11, -1.70073e-11,   1.5837e-12,
                                     -0.20670,-     0.16971,-     0.14671,-      0.13150,-    0.120916,-     0.11363,-      0.10444,
                                   9.7533e-2,   7.9830e-2,   6.8808e-2,    6.1603e-2,   5.6538e-2,   5.3178e-2,    4.8551e-2,
                                   -1.1817e-2,   -9.4393e-3,   7.9836e-3,    -7.0866e-3,-   6.4324e-3,-   6.0436e-3,    -5.3567e-3,
                                   1.6145e-3,   1.2622e-3,   1.0535e-3,    9.2813e-4,   8.3723e-4,   7.7982e-4,    6.8809e-4,

                                     38.6199,      51.249,     68.4746,       58.422,     7.20188,     21.5948,     -88.4076,
                                   -0.132147,   -0.167373, -2.15659e-1,  -1.66664e-1,  2.16109e-2, -2.02239e-2,     0.338518,
                                  1.75411e-4,  2.11832e-4,  2.62273e-4,   1.85486e-4, -6.52882e-5, -1.72029e-5, -0.000445581,
                                 -1.02417e-7, -1.18221e-7, -1.40972e-7, -9.12345e-8,   5.37077e-8,  2.83017e-8,   2.51729e-7,
                                  .21446e-11, 2.45055e-11, 2.82285e-11,  1.67118e-11, -1.4095e-11,-8.94486e-12,   -5.203e-11,
                                    -0.20670,    -0.16971,    -0.14671,     -0.13150,   -0.120916,    -0.11363,     -0.10444,
                                   9.7533e-2,   7.9830e-2,   6.8808e-2,    6.1603e-2,   5.6538e-2,   5.3178e-2,    4.8551e-2,
                                 -1.1817e-2,   -9.4393e-3,  -7.9836e-3,   -7.0866e-3,  -6.4324e-3,  -6.0436e-3,   -5.3567e-3,
                                 1.6145e-3,    1.2622e-3,   1.0535e-3,    9.2813e-4,   8.3723e-4,   7.7982e-4,    6.8809e-4};


   long double __ET[2][4][7] =  {     -0.2061,   -0.169279,      -0.14637,-      0.13121,-     0.12067,    -0.113399,-     0.104243,
                                   9.4449e-2,   7.7599e-2,   6.7052e-2,    6.0105e-2,   5.5232e-2,   5.1994e-2,    4.7573e-2,
                                   -8.7953e-3,  - 7.1375e-3,   -6.0951e-3,    -5.4388e-3,-   4.9580e-3,   -4.6876e-3,    -4.1711e-3,
                                   8.8385e-4,   6.9025e-4,   5.7456e-4,    5.0585e-4,   4.5512e-4,   4.2548e-4,    3.7068e-4,

                                     -0.2061,   -0.169279,   -0.146377,     -0.13121,    -0.12067,   -0.113399,    -0.104243,
                                   9.4449e-2,   7.7599e-2,   6.7052e-2,    6.0105e-2,   5.5232e-2,   5.1994e-2,    4.7573e-2,
                                  -8.7953e-3,  -7.1375e-3,  -6.0951e-3,   -5.4388e-3,  -4.9580e-3,  -4.6876e-3,   -4.1711e-3,
                                  8.8385e-4,   6.9025e-4,   5.7456e-4,    5.0585e-4,   4.5512e-4,   4.2548e-4,    3.7068e-4};


   long double __LH[2][7] = {            120,         120,         120,          120,        120,         120,         120,  
                                         640,         660,         740,          800,        860,         900,         900};

   long double __L0[2][5][7] =  { -0.407768,   -0.902739,    -0.73303,     -1.31444,    -1.20026,    -1.52158,     -1.67664,
                                  0.00148506,  0.00826803,  0.00523396,    0.0133124,   0.0114087,    0.015704,   1.77194e-2,
                                  1.25357e-5, -1.25448e-5,  6.35667e-6,  -2.55585e-5, -1.47324e-5, -3.02859e-5,  -3.69498e-5,
                                  3.77311e-8,  6.12853e-8,  1.09065e-8,   5.43981e-8,   2.7804e-8,  4.57668e-8,   5.09134e-8,
                                -7.78953e-11,-7.07966e-11,-2.61427e-11, -4.33784e-11, -2.2632e-11,-2.82926e-11, -2.82878e-11,

                                     48.6536,     54.4867,     60.1267,      47.0996,     50.6174,     8.01942,     -15.5728,
                                   -0.170291,   -0.178298,   -0.183144,     -0.12526,   -0.129047,   0.0185302,   9.36704e-2,
                                  2.26242e-4,  2.22725e-4,  2.12481e-4,   1.26352e-4,  1.24842e-4, -6.14733e-5,  -1.49036e-4,
                                 -1.32032e-7,   -1.227e-7, -1.08497e-7,  -5.51584e-8, -5.24993e-8,  4.97674e-8,   9.42151e-8,
                                 2.85193e-11, 2.51316e-11,  2.0571e-11,  8.75272e-12, 8.08272e-12,-1.26162e-11,  -2.0961e-11};



//#define MAX_FLUX_TABLE 365*2
//int iStarting1007JD;
//long double FLUX107[MAX_FLUX_TABLE];
// coefs for smuzining
long double AlternativePoints[360 ][3] ={
-0.0100,0.0100,92,
4.7500,5.2500,49,
9.5000,10.5000,43,
14.0000,16.0000,42,
19.5000,20.5000,39,
24.5000,25.5000,39,
29.0000,31.0000,39,
34.5000,35.5000,38,
39.0000,41.0000,38,
44.0000,46.0000,38,
49.0000,51.0000,38,
54.0000,56.0000,41,
59.5000,60.5000,37,
64.5000,65.5000,37,
69.5000,70.5000,37,
74.0000,76.0000,37,
79.0000,81.0000,37,
84.0000,86.0000,37,
89.0000,91.0000,37,
94.0000,96.0000,37,
99.0000,101.0000,37,
104.0000,106.0000,37,
109.5000,110.5000,37,
114.5000,115.5000,37,
119.5000,120.5000,37,
124.0000,126.0000,41,
129.5000,130.5000,38,
134.0000,136.0000,42,
139.5000,140.5000,38,
144.5000,145.5000,38,
149.0000,151.0000,39,
154.5000,155.5000,39,
159.5000,160.5000,39,
164.0000,166.0000,42,
169.5000,170.5000,43,
174.7500,175.2500,49,
179.9750,180.0250,92,
184.7500,185.2500,49,
189.5000,190.5000,43,
194.0000,196.0000,42,
199.5000,200.5000,39,
204.5000,205.5000,39,
209.0000,211.0000,39,
214.5000,215.5000,38,
219.0000,221.0000,38,
224.0000,226.0000,38,
229.0000,231.0000,38,
234.0000,236.0000,41,
239.5000,240.5000,37,
244.5000,245.5000,37,
249.5000,250.5000,37,
254.0000,256.0000,37,
259.0000,261.0000,37,
264.0000,266.0000,37,
269.0000,271.0000,37,
274.0000,276.0000,37,
279.0000,281.0000,37,
284.0000,286.0000,37,
289.5000,290.5000,37,
294.5000,295.5000,37,
299.5000,300.5000,37,
304.0000,306.0000,41,
309.0000,311.0000,38,
314.0000,316.0000,38,
319.0000,321.0000,38,
324.5000,325.5000,38,
329.0000,331.0000,39,
334.5000,335.5000,39,
339.5000,340.5000,39,
344.0000,346.0000,42,
349.7500,350.2500,42,
354.9750,355.0250,92};


long double ModelCoef;// = SlS->GM[j]/ GM_MODEL;
#define USE_MODEL_LOAD
#ifdef USE_MODEL_LOAD
char EarthModelFile[1024]={"egm96"};
int EarthModelCoefs = 16;
int CpuCore = 0;
//long  double GM_MODEL = 398600.4415E9;
//#define R0_MODEL 6378136.30
long double GM_MODEL = 398600.4418e9;
long double R0_MODEL =  6378137.00;
#endif
#ifdef USE_MODEL_0
long  double GM_MODEL = 398600.4415E9;
long double R0_MODEL =  6378137.0;
#endif

#ifdef USE_MODEL_1
long  double GM_MODEL = 398600.4415E9;
long double R0_MODEL= 6378136.30;
#endif
#ifdef USE_MODEL_2
long  double GM_MODEL = 398600.4415E9;
long double R0_MODEL= 6378136.30;
#endif
#ifdef USE_MODEL_3
long  double GM_MODEL = 398600.4418E95;
long double R0_MODEL= 6378137;
#endif 
#ifdef USE_MODEL_3
long double ClmNN[MAX_COEF_J][MAX_COEF_J] = {
    //0             1                    2                   3                   4                   5                   6                  7                     8                   9                10                  11                    12                     13               14                    15               16         17
    0.0,                  0.0,-0.484165371736E-03,  0.957254173792E-06, 0.539873863789E-06, 0.685323475630E-07,-0.149957994714E-06, 0.909789371450E-07, 0.496711667324E-07, 0.276714300853E-07, 0.526222488569E-07,-0.509613707522E-07, 0.377252636558E-07, 0.422982206413E-07,-0.242786502921E-07, 0.147910068708E-08,-0.315322986722E-08,0,
	0.0,                  0.0,-0.186987635955E-09,  0.202998882184E-05,-0.536321616971E-06,-0.621012128528E-07,-0.760879384947E-07, 0.279872910488E-06, 0.233422047893E-07, 0.143387502749E-06, 0.835115775652E-07, 0.151687209933E-07,-0.540654977836E-07,-0.513569699124E-07,-0.186968616381E-07, 0.100817268177E-07, 0.258360856231E-07,0,
	0.0,                  0.0, 0.243914352398E-05,  0.904627768605E-06, 0.350694105785E-06, 0.652438297612E-06, 0.481732442832E-07, 0.329743816488E-06, 0.802978722615E-07, 0.222288318564E-07,-0.942413882081E-07, 0.186309749878E-07, 0.142979642253E-07, 0.559217667099E-07,-0.367789379502E-07,-0.213942673775E-07,-0.233671404512E-07,0,
	0.0,                  0.0,                0.0,  0.721072657057E-06, 0.990771803829E-06,-0.451955406071E-06, 0.571730990516E-07, 0.250398657706E-06,-0.191877757009E-07,-0.160811502143E-06,-0.689895048176E-08,-0.309871239854E-07, 0.393995876403E-07,-0.219360927945E-07, 0.358875097333E-07, 0.521392929041E-07,-0.336019429391E-07,0,
    0.0,                  0.0,                0.0,                 0.0,-0.188560802735E-06,-0.295301647654E-06,-0.862142660109E-07,-0.275114355257E-06,-0.244600105471E-06,-0.900179225336E-08,-0.840764549716E-07,-0.389580205051E-07,-0.686908127934E-07,-0.313762599666E-08, 0.183865617792E-08,-0.408150084078E-07, 0.402316284314E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0, 0.174971983203E-06,-0.267133325490E-06, 0.193765507243E-08,-0.255352403037E-07,-0.166165092924E-07,-0.493395938185E-07, 0.377848029452E-07, 0.309411128730E-07, 0.590049394905E-07, 0.287344273542E-07, 0.124935723108E-07,-0.129501939245E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0, 0.967616121092E-08,-0.358856860645E-06,-0.657361610961E-07, 0.626941938248E-07,-0.375885236598E-07,-0.118676592395E-08, 0.341523275208E-08,-0.359038073075E-07,-0.194810485574E-07, 0.331211643896E-07, 0.140239252323E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0, 0.109185148045E-08, 0.672811580072E-07,-0.118366323475E-06, 0.811460540925E-08, 0.411565188074E-08,-0.186909958587E-07, 0.253002147087E-08, 0.375003839415E-07, 0.596210699259E-07,-0.708412635136E-08,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-0.124092493016E-06, 0.188436022794E-06, 0.404927981694E-07,-0.598410841300E-08,-0.253769398865E-07,-0.983150822695E-08,-0.350946485865E-07,-0.322428691498E-07,-0.209018868094E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,-0.477475386132E-07, 0.125491334939E-06,-0.314231072723E-07, 0.422880630662E-07, 0.247325771791E-07, 0.320284939341E-07, 0.128788268085E-07,-0.218588720643E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0, 0.100538634409E-06,-0.521882681927E-07,-0.617619654902E-08, 0.410324653930E-07, 0.390329180008E-07, 0.104688722521E-07,-0.117529900814E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0, 0.460344448746E-07, 0.112502994122E-07,-0.443869677399E-07, 0.153970516502E-07,-0.111675061934E-08, 0.187574042592E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,-0.249532607390E-08,-0.312622200222E-07, 0.840829163869E-08,-0.323962134415E-07, 0.195400194038E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,-0.612759553199E-07, 0.322147043964E-07,-0.283933019117E-07, 0.138196369576E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,-0.518980794309E-07, 0.519168859330E-08,-0.193182168856E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,                  0,-0.190930538322E-07,-0.145149060142E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,                  0,                  0,-0.379671710746E-07,0
};
long double SlmNN[MAX_COEF_J][MAX_COEF_J] = {       //   3                   4                     5                   6                 7                     8                      9              10                   11                 12                 13                  14                 15
    0.0,                  0.0,                0.0,                0.0,                0.0,               0.0,                 0.0,                0.0,                0.0,                  0,                  0,                  0,                  0,                  0,                  0,                      0,                      0,         0,
    0.0,                  0.0, 0.119528012031E-08, 0.248513158716E-06,-0.473440265853E-06,-0.944226127525E-07, 0.262890545501E-07, 0.954336911867E-07, 0.590060493411E-07, 0.216834947618E-07,-0.131314331796E-06,-0.268604146166E-07,-0.435675748979E-07, 0.390510386685E-07, 0.294747542249E-07, 0.109773066324E-07, 0.325447560859E-07,0,
    0.0,                  0.0,-0.140016683654E-05,-0.619025944205E-06, 0.662671572540E-06,-0.323349612668E-06,-0.373728201347E-06, 0.930667596042E-07, 0.654175425859E-07,-0.322196647116E-07,-0.515791657390E-07,-0.990693862047E-07, 0.320975937619E-07,-0.627337565381E-07,-0.516779392055E-08,-0.308914875777E-07, 0.288799363439E-07,0,
    0.0,                  0.0,                0.0, 0.141435626958E-05,-0.200928369177E-06,-0.214847190624E-06, 0.902694517163E-08,-0.217198608738E-06,-0.863454445021E-07,-0.742287409462E-07,-0.153768828694E-06,-0.148131804260E-06, 0.244264863505E-07, 0.974829362237E-07, 0.204618827833E-07, 0.172892926103E-07,-0.220418988010E-07,0,
    0.0,                  0.0,                0.0,                0.0, 0.308853169333E-06, 0.496658876769E-07,-0.471408154267E-06,-0.123800392323E-06, 0.700233016934E-07, 0.194666779475E-07,-0.792806255331E-07,-0.636666511980E-07, 0.415081109011E-08,-0.119627874492E-07,-0.226780613566E-07, 0.650174707794E-08, 0.483837716909E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,-0.669384278219E-06,-0.536488432483E-06, 0.177377719872E-07, 0.891462164788E-07,-0.541113191483E-07,-0.505370221897E-07, 0.494736238169E-07, 0.782536279033E-08, 0.664975958036E-07,-0.163882249728E-07, 0.808375563996E-08,-0.319458578129E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,-0.237192006935E-06, 0.151789817739E-06, 0.309238461807E-06, 0.222903525945E-06,-0.795667053872E-07, 0.344769584593E-07, 0.391765484449E-07,-0.657280613686E-08, 0.247831272781E-08,-0.368246004304E-07,-0.350760208303E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0, 0.244415707993E-07, 0.747440473633E-07,-0.965152667886E-07,-0.336629641314E-08,-0.898252808977E-07, 0.356131849382E-07,-0.621470822331E-08,-0.417291319429E-08, 0.531841171879E-08,-0.881581561131E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0, 0.120533165603E-06,-0.308566220421E-08,-0.918705975922E-07, 0.243989612237E-07, 0.169361024629E-07,-0.104740222825E-07,-0.153515265203E-07, 0.221523579587E-07, 0.500527390530E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0, 0.966412847714E-07,-0.376516222392E-07, 0.417731829829E-07, 0.252692598301E-07, 0.452870369936E-07, 0.288804922064E-07, 0.375629820829E-07,-0.395012419994E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,-0.240148449520E-07,-0.183364561788E-07, 0.308375794212E-07,-0.368121029480E-07,-0.144308452469E-08, 0.147222147015E-07, 0.114211582961E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,-0.696662308185E-07,-0.637946501558E-08,-0.476507804288E-08,-0.390548173245E-07, 0.180996198432E-07,-0.303161919925E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,-0.111780601900E-07, 0.878405809267E-07,-0.311327189117E-07, 0.155243104746E-07, 0.666983574071E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0, 0.685261488594E-07, 0.451897224960E-07,-0.422066791103E-08, 0.102778499508E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,-0.481506636748E-08,-0.243752739666E-07,-0.386174893776E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,                  0,-0.471139421558E-08,-0.327443078739E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,                  0,                  0, 0.302155372655E-08,0,
};
#else
long double ClmNN[MAX_COEF_J][MAX_COEF_J] = { //2                 3                     4                   5                   6                   7                    8                 9                       10              11              12                  13                        14                15              16       17    
    0.0,                  0.0,-4.841692638330e-04,  9.572027902208e-07, 5.399964106071e-07, 6.866574057291e-08,-1.499596204836e-07, 9.050739327092e-08, 4.947735333891e-08,  2.802002397264e-08, 5.332872206339e-08,-5.076684067354e-08, 3.643698716802e-08, 4.173145479803e-08,-2.266932614809e-08, 2.191678708149e-09,-4.711399566556e-09, 0,
	0.0,                  0.0,-2.234662444661e-10,  2.030466388182e-06,-5.361544237902e-07,-6.292428749088e-08,-7.592505797236e-08, 2.808854277322e-07, 2.315575906154e-08,  1.421495778857e-07, 8.376111145897e-08, 1.561187804078e-08,-5.358752398482e-08,-5.144000572708e-08,-1.877109781623e-08, 9.430607665241e-09, 2.618495087563e-08, 0,
	0.0,                  0.0, 2.439350113369e-06,  9.047846524431e-07, 3.504958968385e-07, 6.520778577638e-07, 4.864539750273e-08, 3.304068238591e-07, 8.001179880843e-08,  2.141393810770e-08,-9.399255140566e-08, 2.011423100703e-08, 1.426661258608e-08, 5.530988811097e-08,-3.591920480342e-08,-2.053202027793e-08,-2.451051568312e-08, 0,
	0.0,                  0.0,                0.0,  7.212871882010e-07, 9.908586325033e-07,-4.518537514124e-07, 5.724334935560e-08, 2.504544598798e-07,-1.937186828289e-08, -1.606138778812e-07,-7.005368053537e-09,-3.057925186015e-08, 3.962415995470e-08,-2.155800022081e-08, 3.651607433528e-08, 5.341304630709e-08,-3.391353117356e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,-1.884976309101e-07,-2.953307723280e-07,-8.601639084556e-08,-2.749966205063e-07,-2.443584112320e-07, -9.366026792641e-09,-8.446628400020e-08,-3.795224682616e-08,-6.772572133772e-08,-3.651797523913e-09, 1.602910566428e-09,-4.017381916458e-08, 4.085472497887e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0, 1.748040283338e-07,-2.671694458420e-07, 1.648725941097e-09,-2.570213990017e-08, -1.631147946221e-08,-4.929098071452e-08, 3.742247518693e-08, 3.087560954874e-08, 5.837167041440e-08, 2.930775661205e-08, 1.224207146925e-08,-1.212203260105e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0, 9.475274175687e-09,-3.588026196467e-07,-6.596595299498e-08,  6.278699700289e-08,-3.758514495974e-08,-1.565920036827e-09, 3.132644254277e-09,-3.504446356069e-08,-1.906970629630e-08, 3.285198624026e-08, 1.387384159872e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0, 1.519895064619e-09, 6.725611206683e-08, -1.179836069693e-07, 8.260939438061e-09, 4.654747377856e-09,-1.905168826766e-08, 3.015092155107e-09, 3.763036962799e-08, 5.965511978744e-08,-8.062457398106e-09, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-1.240322758207e-07,  1.881291318200e-07, 4.059211174828e-08,-6.301356391485e-09,-2.588852721232e-08,-1.005497521179e-08,-3.494137393294e-08,-3.208864903358e-08,-2.120437927688e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0, -4.755484386124e-08, 1.253832700848e-07,-3.107538124489e-08, 4.191770164809e-08, 2.476679196786e-08, 3.195228258282e-08, 1.329848455013e-08,-2.241391484986e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0, 1.004229077541e-07,-5.224977584439e-08,-6.199896784872e-09, 4.110412490315e-08, 3.880182386363e-08, 1.026325953351e-08,-1.180463195465e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0, 4.623389723690e-08, 1.136258459209e-08,-4.452226413314e-08, 1.564625400671e-08,-1.305441830526e-09, 1.911171902867e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,-2.423026558875e-09,-3.131887022807e-08, 8.460976772264e-09,-3.241821298600e-08, 1.956110670862e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,-6.120881679019e-08, 3.224218717741e-08,-2.836870432250e-08, 1.377544553767e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,-5.187076100301e-08, 5.200241654303e-09,-1.934458914407e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                  0,-1.902751314587e-08,-1.441678809455e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                  0,                  0,-3.830521289156e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                  0,                  0,                  0, 0
};
long double SlmNN[MAX_COEF_J][MAX_COEF_J] = {
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                   0,                  0,                 0,                   0,                  0,                  0,                    0,                  0, 0,
    0.0,                  0.0, 1.464715526673e-09, 2.482080433653e-07,-4.735680040417e-07,-9.437428640136e-08, 2.651378843389e-08, 9.512586979716e-08, 5.889592314865e-08,  2.140014207954e-08,-1.310928645967e-07,-2.712348064969e-08,-4.316458223037e-08, 3.869034387873e-08,  2.886211920225e-08,  1.048343697123e-08,  3.334313589953e-08,0,
    0.0,                  0.0,-1.400296540441e-06,-6.189942681083e-07, 6.624855562470e-07,-3.233496172587e-07,-3.737920915147e-07, 9.299919715717e-08, 6.528327073129e-08, -3.169859562924e-08,-5.127653720129e-08,-9.899946750685e-08, 3.109064951397e-08,-6.269439481257e-08, -4.054659579019e-09, -3.029929942704e-08,  2.803047576995e-08,0,
    0.0,                  0.0,                0.0, 1.414368208779e-06,-2.009476685481e-07,-2.149561037572e-07, 8.952473451278e-09,-2.171181625992e-07,-8.596235732981e-08, -7.426799091681e-08,-1.541425435369e-07,-1.488361487913e-07, 2.506149544819e-08, 9.768510167924e-08,  1.969199774505e-08,  1.766096915361e-08, -2.133881575508e-08,0,
    0.0,                  0.0,                0.0,                0.0, 3.088135184212e-07, 4.980925678694e-08,-4.714241836895e-07,-1.240577402167e-07, 6.981012693018e-08,  1.990269145001e-08,-7.902664299306e-08,-6.377016394095e-08, 3.839316687212e-09,-1.175070318615e-08, -2.266180766986e-08,  6.811721256429e-09,  4.798864908709e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,-6.693703781765e-07,-5.364945320709e-07, 1.792751666484e-08, 8.920242844714e-08, -5.404158428580e-08,-5.061601820481e-08, 4.959112109226e-08, 7.588579694650e-09, 6.722686386365e-08, -1.679010211399e-08,  7.621491034307e-09, -3.443409814726e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,-2.373889502183e-07, 1.517953939450e-07, 3.089442033489e-07,  2.229637747856e-07,-7.977013211026e-08, 3.427367173521e-08, 3.898098866254e-08,-6.273525421439e-09,  2.456983563782e-09, -3.646985465262e-08, -3.559593322814e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0, 2.410884394887e-08, 7.486559029971e-08, -9.692324514961e-08,-3.046340591979e-09,-8.982781854875e-08, 3.572792342750e-08,-7.323017189905e-09, -3.933698459869e-09,  5.073057805615e-09, -8.651969069085e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0, 1.205465727993e-07, -3.002262507284e-09,-9.171581581980e-08, 2.454773002353e-08, 1.693748226686e-08,-9.857235841573e-09, -1.544686306971e-08,  2.217210257117e-08,  5.406987372004e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,  9.687949185757e-08,-3.794425045512e-08, 4.207091340282e-08, 2.496229497578e-08, 4.589035920265e-08,  2.846426004693e-08,  3.799393471601e-08, -3.966799165656e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,-2.385629426228e-08,-1.841642451641e-08, 3.093427812562e-08,-3.683656180493e-08, -1.297935326294e-09,  1.469238135563e-08,  1.153517812657e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,-6.967357602229e-08,-6.385321730657e-09,-4.841568358339e-09, -3.904229679272e-08,  1.852183740538e-08, -3.202892179004e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,-1.111510144261e-08, 8.793436179258e-08, -3.111925531137e-08,  1.560533743612e-08,  6.727712403290e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0, 6.814363771627e-08,  4.514881135110e-08, -4.577079272453e-09,  1.048199370467e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0, -4.822175650729e-09, -2.439700582238e-08, -3.864568321338e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                   0, -4.690395287240e-09, -3.277186361861e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                   0,                   0,  2.968301836612e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                   0,                   0,                   0,0
};
#endif

#ifdef USE_MODEL_0

long double Clm[MAX_COEF_J][MAX_COEF_J] = {//2                 3                     4                        5                   6                   7                    8             9 10 11 12 13 14 15 16 17           
    0.0,                  0.0, -0.10826360229840e-02,   0.25325160653E-05,   0.16185636000E-05,    0.2266690830E-06,    -0.5390785906e-06,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0,       -0.2194691e-09,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0,    0.15744102040e-05,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0

 };
long double Slm[MAX_COEF_J][MAX_COEF_J] = {
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,      +0.15362834e-08,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,    -0.9037571782e-06,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
#else

long double Clm[MAX_COEF_J][MAX_COEF_J] = {//2                 3                     4                        5                   6                   7                    8             9 10 11 12 13 14 15 16 17           
    0.0,                  0.0,-0.10826260745913e-02, 0.25324353457544E-05, 0.16193312050719e-05, 0.22771610163688E-06,-0.53964849049834e-06, 0.35136844210318e-06, 0.20251871520885e-06, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0,-0.24140000522221e-09, 0.21927988018965e-05,-0.50872530365024e-06,-0.53716510187662e-07,-0.59877976856303e-07, 0.20514872797672e-06, 0.16034587141379e-07, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0, 0.15745360427672e-05, 0.30901604455583e-06, 0.78412230752366e-07, 0.10559053538674e-06, 0.60120988437373e-08, 0.32844904836492e-07, 0.65765423316743e-08, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0,                  0.0, 0.10055885741455e-06, 0.59215743214072e-07,-0.14926153867389e-07, 0.11822664115915e-08, 0.35285405191512e-08,-0.19463581555399e-09, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,-0.39823957404129e-08,-0.22979123502681e-08,-0.32641389117891e-09,-0.58511949148624e-09,-0.31893580211856e-09, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0.43047675045029e-09,-0.21557711513900e-09, 0.58184856030873e-12,-0.46151734306628e-11, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0.22136925556741e-11,-0.24907176820596e-10,-0.18393642697634e-11, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0.25590780149873e-13, 0.34297618184624e-12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,-0.15803322891725e-12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0

 };
long double Slm[MAX_COEF_J][MAX_COEF_J] = {
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0, 0.15430999737844e-08, 0.26801189379726e-06,-0.44945993508117e-06,-0.80663463828530e-07, 0.21164664354382e-07, 0.69369893525908e-07, 0.40199781599510e-07, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,-0.90386807301869e-06,-0.21140239785975e-06, 0.14815545694714e-06,-0.52326723987632e-07,-0.46503948132217e-07, 0.92823143885084e-08, 0.53813164055056e-08, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0, 0.19720132389889e-06,-0.12011291831397e-07,-0.71008771406986e-08, 0.18431336880625e-09,-0.30611502382788e-08,-0.87235195047605e-09, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0, 0.65256058113396e-08, 0.38730050770804e-09,-0.17844913348882e-08,-0.26361822157867e-09, 0.91177355887255e-10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,-0.16482039468636e-08,-0.43291816989540e-09, 0.63972526639235e-11, 0.16125208346784e-10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,-0.55277122205966e-10, 0.10534878629266e-10, 0.86277431674150e-11, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0.44759834144751e-12, 0.38147656686685e-12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0.15353381397148e-12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};


#endif
// just for convinience to proper orbit clculation
double EngCoeff = 1.0;


long double GST,SLONG,SRASN, SDEC;
long double dStartGreenwichA = 0.0;
long double TotalDays;
long iTotalSec;
long double IterPerSec;
int iItearationsPerSec; // that is "int" == IterPerSec
long double StepsValInDay; // step's value in day measurement
//long iCurSec; // current second from begining of the simulation
//int iCurPortionOfTheSecond;
//#define SIMPSON_INTEGRAL 1 
#define ADJUST(__INIT,__FORMULA,__ADDON) ldTemp=(__INIT+(__FORMULA))+__ADDON;ldTemp2=ldTemp-(__INIT +(__FORMULA));__INIT=ldTemp;__ADDON-=ldTemp2;
typedef struct Long_Double_Intergal_Var
{
    long long nX0;
    long double X0;
    long double Y0;
    long double Z0;
    long double VX0;
    long double VY0;
    long double VZ0;

    long double X6[6];
    long double Y6[6];
    long double Z6[6];

    long double x6[6];
    long double y6[6];
    long double z6[6];
    int i6;

    long double X6_h[6];
    long double Y6_h[6];
    long double Z6_h[6];

    long double X6_hh[6];
    long double Y6_hh[6];
    long double Z6_hh[6];

    long double X6_hhh[6];
    long double Y6_hhh[6];
    long double Z6_hhh[6];

    long double X;
    long double Y;
    long double Z;

    long double X_h;
    long double Y_h;
    long double Z_h;

    long double X_hh;
    long double Y_hh;
    long double Z_hh;

    long double X_hhh;
    long double Y_hhh;
    long double Z_hhh;


    long double X_temp;
    long double Y_temp;
    long double Z_temp;

    long double VX;
    long double VY;
    long double VZ;

    long double VX_h;
    long double VY_h;
    long double VZ_h;

    long double VX_hh;
    long double VY_hh;
    long double VZ_hh;

    long double VX_hhh;
    long double VY_hhh;
    long double VZ_hhh;


    long double VX_temp;
    long double VY_temp;
    long double VZ_temp;
    long CountNx;
    long CountNy;
    long CountNz;

    long CountNx_h;
    long CountNy_h;
    long CountNz_h;

    long CountNx_hh;
    long CountNy_hh;
    long CountNz_hh;


    long double x() 
    { 
           return X+X_temp; 
    };
    long double y() 
    { 
            return Y+Y_temp; 
    };
    long double z() 
    { 
            return Z+Z_temp; 
    };
    long double vx() 
    { 
           return VX+VX_temp; 
    };
    long double vy() 
    { 
            return VY+VY_temp; 
    };
    long double vz() 
    { 
            return VZ+VZ_temp; 
    };
#ifndef SIMPSON_INTEGRAL
    void Addpos(long double valVX,long double valX,long double valVY,long double valY, long double valVZ,long double valZ)
    {
        X+=valX;  Y+=valY;   Z+=valZ;
        VX+=valVX;  VY+=valVY;   VZ+=valVZ;
    }
    void Add(long double valX,long double valY, long double valZ)
    {
        X+=valX;
        Y+=valY;
        Z+=valZ;
        //nX0++;
        //x6[i6] =valX; y6[i6] =valY; z6[i6] =valZ;
        //if (++i6 == 6)
        //{
        //    i6 = 0;
        //}
        //else
        //{
        //}
    }
#else
    void Add(long double valX,long double valY, long double valZ)
    {
        //nX0++;
        x6[i6] =valX; y6[i6] =valY; z6[i6] =valZ;
        if (++i6 == 4)
        {
            X6[1] += x6[1]; X6[2] += x6[2];
            Y6[1] += y6[1]; Y6[2] += y6[2];
            Z6[1] += z6[1]; Z6[2] += z6[2];
            X_temp =  (x6[0] + 4.0* (X6[1]+X6_h[1]+X6_hh[1]+X6_hhh[1]) + 2.0* (X6[2]+X6_h[2]+X6_hh[2]+X6_hhh[2]) + valX)/3.0; X = x6[3];
            Y_temp =  (y6[0] + 4.0* (Y6[1]+Y6_h[1]+Y6_hh[1]+Y6_hhh[1]) + 2.0* (Y6[2]+Y6_h[2]+Y6_hh[2]+Y6_hhh[2]) + valY)/3.0; Y = y6[3];
            Z_temp =  (z6[0] + 4.0* (Z6[1]+Z6_h[1]+Z6_hh[1]+Z6_hhh[1]) + 2.0* (Z6[2]+Z6_h[2]+Z6_hh[2]+Z6_hhh[2]) + valZ)/3.0; Z = z6[3];
            i6 = 1;
            x6[i6] =valX; y6[i6] =valY; z6[i6] =valZ;
            i6 = 2;
        }
        else
        {
            X+=valX;   Y+=valY;   Z+=valZ;
        }
    }
#endif
    void getIntegralpos(long double &valVX, long double &valVY, long double &valVZ)
    {
#ifndef SIMPSON_INTEGRAL
            valVX = (x()+X0+vx()+VX0);    
            valVY = (y()+Y0+vy()+VY0);    
            valVZ = (z()+Z0+vz()+VZ0);
#else
            valVX = (X_temp+X+X0);    
            valVY = (Y_temp+Y+Y0);    
            valVZ = (Z_temp+Z+Z0);
#endif
    }

    void getIntegral(long double &valVX, long double &valVY, long double &valVZ)
    {
#ifndef SIMPSON_INTEGRAL
            valVX = (x()+X0);    
            valVY = (y()+Y0);    
            valVZ = (z()+Z0);
#else
            valVX = (X_temp+X+X0);    
            valVY = (Y_temp+Y+Y0);    
            valVZ = (Z_temp+Z+Z0);
#endif
    }
    void adjustAllpos(void)
    {
#ifndef SIMPSON_INTEGRAL
        adjustXpos(10103,10163);      adjustYpos(10463,10559);      adjustZpos(10607,10667);
#else
        adjustXX(10103,10163);      adjustYY(10463,10559);      adjustZZ(10607,10667);
#endif
    }

    void adjustAll(void)
    {
#ifndef SIMPSON_INTEGRAL
        adjustX(10103,10163);      adjustY(10463,10559);      adjustZ(10607,10667);
#else
        adjustXX(10103,10163);      adjustYY(10463,10559);      adjustZZ(10607,10667);
#endif
    }
    void adjustall(void)
    {
#ifndef SIMPSON_INTEGRAL
        adjustX(10799,10883);      adjustY(11279,11423);      adjustZ(11483,11699);
#else
        adjustXX(10799,10883);      adjustYY(11279,11423);      adjustZZ(11483,11699);
#endif
    }
    void adjustX(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNx >= MaxVal)
        {
            CountNx = 0;
            ADJUST(X_h, 0, X);
            X_temp = X_h+X_hh+X_hhh;
            if (++CountNx_h >= MaxVal_h)
            {
                CountNx_h = 0;
                ADJUST(X_hh, 0, X_h);
                X_temp = X_h+X_hh+X_hhh;
                if (++CountNx_hh >= 1019)
                {
                    CountNx_hh = 0;
                    ADJUST(X_hhh, 0, X_hh);
                    X_temp = X_h+X_hh+X_hhh;
                    printf("X");
                }
            }
        }
    };
    void adjustY(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNy >= MaxVal)
        {
            CountNy = 0;
            ADJUST(Y_h, 0, Y);
            Y_temp = Y_h + Y_hh + Y_hhh;
            if (++CountNy_h >= MaxVal_h)
            {
                CountNy_h = 0;
                ADJUST(Y_hh, 0, Y_h);
                Y_temp = Y_h + Y_hh + Y_hhh;
                if (++CountNy_hh >= 1307)
                {
                    CountNy_hh = 0;
                    ADJUST(Y_hhh, 0, Y_hh);
                    Y_temp = Y_h + Y_hh + Y_hhh;
                    printf("Y");
                }
            }
        }
    };
    void adjustZ(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNz >= MaxVal)
        {
            CountNz = 0;
            ADJUST(Z_h, 0, Z);
            Z_temp=Z_h+Z_hh +Z_hhh;
            if (++CountNz_h >= MaxVal_h)
            {
                CountNz_h = 0;
                ADJUST(Z_hh, 0, Z_h);
                Z_temp=Z_h+Z_hh +Z_hhh;
                if (++CountNz_hh >= 983)
                {
                    CountNz_hh = 0;
                    ADJUST(Z_hhh, 0, Z_hh);
                    Z_temp=Z_h+Z_hh +Z_hhh;
                    printf("Z");
                }
            }
        }
    };

    void adjustXpos(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNx >= MaxVal)
        {
            CountNx = 0;
            ADJUST(X_h, 0, X);
            ADJUST(VX_h, 0, VX);
            X_temp = X_h+X_hh+X_hhh;
            VX_temp = VX_h+VX_hh+VX_hhh;
            if (++CountNx_h >= MaxVal_h)
            {
                CountNx_h = 0;
                ADJUST(X_hh, 0, X_h);
                ADJUST(VX_hh, 0, VX_h);
                X_temp = X_h+X_hh+X_hhh;
                VX_temp = VX_h+VX_hh+VX_hhh;
                if (++CountNx_hh >= 1019)
                {
                    CountNx_hh = 0;
                    ADJUST(X_hhh, 0, X_hh);
                    ADJUST(VX_hhh, 0, VX_hh);
                    X_temp = X_h+X_hh+X_hhh;
                    VX_temp = VX_h+VX_hh+VX_hhh;
                    printf("X");
                }
            }
        }
    };
    void adjustYpos(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNy >= MaxVal)
        {
            CountNy = 0;
            ADJUST(Y_h, 0, Y);
            ADJUST(VY_h, 0, VY);
            Y_temp = Y_h + Y_hh + Y_hhh;
            VY_temp = VY_h + VY_hh + VY_hhh;
            if (++CountNy_h >= MaxVal_h)
            {
                CountNy_h = 0;
                ADJUST(Y_hh, 0, Y_h);
                ADJUST(VY_hh, 0, VY_h);
                Y_temp = Y_h + Y_hh + Y_hhh;
                VY_temp = VY_h + VY_hh + VY_hhh;
                if (++CountNy_hh >= 1307)
                {
                    CountNy_hh = 0;
                    ADJUST(Y_hhh, 0, Y_hh);
                    ADJUST(VY_hhh, 0, VY_hh);
                    Y_temp = Y_h + Y_hh + Y_hhh;
                    VY_temp = VY_h + VY_hh + VY_hhh;
                    printf("Y");
                }
            }
        }
    };
    void adjustZpos(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNz >= MaxVal)
        {
            CountNz = 0;
            ADJUST(Z_h, 0, Z);
            ADJUST(VZ_h, 0, VZ);
            Z_temp=Z_h+Z_hh +Z_hhh;
            VZ_temp=VZ_h+VZ_hh +VZ_hhh;
            if (++CountNz_h >= MaxVal_h)
            {
                CountNz_h = 0;
                ADJUST(Z_hh, 0, Z_h);
                ADJUST(VZ_hh, 0, VZ_h);
                Z_temp=Z_h+Z_hh +Z_hhh;
                VZ_temp=VZ_h+VZ_hh +VZ_hhh;
                if (++CountNz_hh >= 983)
                {
                    CountNz_hh = 0;
                    ADJUST(Z_hhh, 0, Z_hh);
                    ADJUST(VZ_hhh, 0, VZ_hh);
                    Z_temp=Z_h+Z_hh +Z_hhh;
                    VZ_temp=VZ_h+VZ_hh +VZ_hhh;
                    printf("Z");
                }
            }
        }
    };

#ifdef SIMPSON_INTEGRAL
    void adjustXX(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNx >= MaxVal)
        {
            CountNx = 0;
            ADJUST(X6_h[1], 0, X6[1]);
            ADJUST(X6_h[2], 0, X6[2]);
            X_temp =  (x6[0] + 4.0* (X6[1]+X6_h[1]+X6_hh[1]+X6_hhh[1]) + 2.0* (X6[2]+X6_h[2]+X6_hh[2]+X6_hhh[2]) + x6[3])/3.0;
            if (++CountNx_h >= MaxVal_h)
            {
                CountNx_h = 0;
                ADJUST(X6_hh[1], 0, X6_h[1]);
                ADJUST(X6_hh[2], 0, X6_h[2]);
                X_temp =  (x6[0] + 4.0* (X6[1]+X6_h[1]+X6_hh[1]+X6_hhh[1]) + 2.0* (X6[2]+X6_h[2]+X6_hh[2]+X6_hhh[2]) + x6[3])/3.0;
                if (++CountNx_hh >= 1019)
                {
                    CountNx_hh = 0;
                    ADJUST(X6_hhh[1], 0, X6_hh[1]);
                    ADJUST(X6_hhh[2], 0, X6_hh[2]);
                    X_temp =  (x6[0] + 4.0* (X6[1]+X6_h[1]+X6_hh[1]+X6_hhh[1]) + 2.0* (X6[2]+X6_h[2]+X6_hh[2]+X6_hhh[2]) + x6[3])/3.0;
                    printf("X");
                }
            }
        }
    };
    void adjustYY(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNy >= MaxVal)
        {
            CountNy = 0;
            ADJUST(Y6_h[1], 0, Y6[1]);
            ADJUST(Y6_h[2], 0, Y6[2]);
            Y_temp =  (y6[0] + 4.0* (Y6[1]+Y6_h[1]+Y6_hh[1]+Y6_hhh[1]) + 2.0* (Y6[2]+Y6_h[2]+Y6_hh[2]+Y6_hhh[2]) + y6[3])/3.0;
            if (++CountNy_h >= MaxVal_h)
            {
                CountNy_h = 0;
                ADJUST(Y6_hh[1], 0, Y6_h[1]);
                ADJUST(Y6_hh[2], 0, Y6_h[2]);
                Y_temp =  (y6[0] + 4.0* (Y6[1]+Y6_h[1]+Y6_hh[1]+Y6_hhh[1]) + 2.0* (Y6[2]+Y6_h[2]+Y6_hh[2]+Y6_hhh[2]) + y6[3])/3.0;
                if (++CountNy_hh >= 1307)
                {
                    CountNy_hh = 0;
                    ADJUST(Y6_hhh[1], 0, Y6_hh[1]);
                    ADJUST(Y6_hhh[2], 0, Y6_hh[2]);
                    Y_temp =  (y6[0] + 4.0* (Y6[1]+Y6_h[1]+Y6_hh[1]+Y6_hhh[1]) + 2.0* (Y6[2]+Y6_h[2]+Y6_hh[2]+Y6_hhh[2]) + y6[3])/3.0;
                    printf("Y");
                }
            }
        }
    };
    void adjustZZ(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNz >= MaxVal)
        {
            CountNz = 0;
            ADJUST(Z6_h[1], 0, Z6[1]);
            ADJUST(Z6_h[2], 0, Z6[2]);
            Z_temp =  (z6[0] + 4.0* (Z6[1]+Z6_h[1]+Z6_hh[1]+Z6_hhh[1]) + 2.0* (Z6[2]+Z6_h[2]+Z6_hh[2]+Z6_hhh[2]) + z6[3])/3.0;
            if (++CountNz_h >= MaxVal_h)
            {
                CountNz_h = 0;
                ADJUST(Z6_hh[1], 0, Z6_h[1]);
                ADJUST(Z6_hh[2], 0, Z6_h[2]);
                Z_temp =  (z6[0] + 4.0* (Z6[1]+Z6_h[1]+Z6_hh[1]+Z6_hhh[1]) + 2.0* (Z6[2]+Z6_h[2]+Z6_hh[2]+Z6_hhh[2]) + z6[3])/3.0;
                if (++CountNz_hh >= 983)
                {
                    CountNz_hh = 0;
                    ADJUST(Z6_hhh[1], 0, Z6_hh[1]);
                    ADJUST(Z6_hhh[2], 0, Z6_hh[2]);
                    Z_temp =  (z6[0] + 4.0* (Z6[1]+Z6_h[1]+Z6_hh[1]+Z6_hhh[1]) + 2.0* (Z6[2]+Z6_h[2]+Z6_hh[2]+Z6_hhh[2]) + z6[3])/3.0;
                    printf("Z");
                }
            }
        }
    };
#endif
    void ZeroIntegral (void)
    {
        nX0 = 0;
        X = 0.0;      Y = 0.0;      Z = 0.0;
        X_h =0.0;    Y_h =0.0;    Z_h =0.0;
        X_hh =0.0;   Y_hh =0.0;   Z_hh =0.0;
        X_hhh =0.0;   Y_hhh =0.0;   Z_hhh =0.0;
        VX = 0.0;      VY = 0.0;      VZ = 0.0;
        VX_h =0.0;    VY_h =0.0;    VZ_h =0.0;
        VX_hh =0.0;   VY_hh =0.0;   VZ_hh =0.0;
        VX_hhh =0.0;   VY_hhh =0.0;   VZ_hhh =0.0;

        CountNx = 0; CountNy = 0; CountNz = 0;
        CountNx_h = 0; CountNy_h = 0; CountNz_h = 0;
        CountNx_hh = 0; CountNy_hh = 0; CountNz_hh = 0;

        X0 = 0.0;      Y0 = 0.0;      Z0 = 0.0;
        VX0 = 0.0;      VY0 = 0.0;      VZ0 = 0.0;
        for (int i = 0; i < 6; i++)
        {
            x6[i] = 0.0;      x6[i] = 0.0;      x6[i] = 0.0;
            X6[i] = 0.0;      Y6[i] = 0.0;      Z6[i] = 0.0;
            X6_h[i] = 0.0;    Y6_h[i] = 0.0;    Z6_h[i] = 0.0;
            X6_hh[i] = 0.0;   Y6_hh[i] = 0.0;   Z6_hh[i] = 0.0;
            X6_hhh[i] = 0.0;  Y6_hhh[i] = 0.0;  Z6_hhh[i] = 0.0;
        }
        i6 = 0;

        X_temp = 0.0; Y_temp = 0.0;   Z_temp = 0.0;
        VX_temp = 0.0; VY_temp = 0.0;   VZ_temp = 0.0;
    };
} LONG_DOUBLE_INT_VAR, *PLONG_DOUBLE_INT_VAR;


typedef struct Long_Double_Intergal_Var4
{
    long double X;
    long double Y;
    long double Z;

    long double X_h;
    long double Y_h;
    long double Z_h;

    long double X_hh;
    long double Y_hh;
    long double Z_hh;

    long double X_hhh;
    long double Y_hhh;
    long double Z_hhh;

    long CountNx;
    long CountNy;
    long CountNz;


    long CountNx_h;
    long CountNy_h;
    long CountNz_h;

    long CountNx_hh;
    long CountNy_hh;
    long CountNz_hh;
    long double x() 
	{
           return X+X_h+X_hh+X_hhh; 
    };
    long double y() 
	{
            return Y+Y_h+Y_hh+Y_hhh; 
    };
    long double z() 
    { 
            return Z+Z_h+Z_hh+Z_hhh; 
    };
    void adjustX(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNx >= MaxVal)
        {
            CountNx = 0;
            ADJUST(X_h, 0, X);
            if (++CountNx_h >= MaxVal_h)
            {
                CountNx_h = 0;
                ADJUST(X_hh, 0, X_h);
                if (++CountNx_hh >= 983)
                {
                    CountNx_hh = 0;
                    ADJUST(X_hhh, 0, X_hh);
                }
            }
        }
    };
    void adjustY(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNy >= MaxVal)
        {
            CountNy = 0;
            ADJUST(Y_h, 0, Y);
            if (++CountNy_h >= MaxVal_h)
            {
                CountNy_h = 0;
                ADJUST(Y_hh, 0, Y_h);
                if (++CountNy_hh >= 1019)
                {
                    CountNy_hh = 0;
                    ADJUST(Y_hhh, 0, Y_hh);
                }
            }
        }
    };
    void adjustZ(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNz >= MaxVal)
        {
            CountNz = 0;
            ADJUST(Z_h, 0, Z);
            if (++CountNz_h >= MaxVal_h)
            {
                CountNz_h = 0;
                ADJUST(Z_hh, 0, Z_h);
                if (++CountNz_hh >= 1307)
                {
                    CountNz_hh = 0;
                   ADJUST(Z_hhh, 0, Z_hh);
                }
            }
        }
    };

    void ZeroIntegral (void)
    {
        X = 0.0;      Y = 0.0;      Z = 0.0;
        X_h =0.0;    Y_h =0.0;    Z_h =0.0;
        X_hh =0.0;   Y_hh =0.0;   Z_hh =0.0;
        X_hhh =0.0;   Y_hhh =0.0;   Z_hhh =0.0;
        CountNx = 0; CountNy = 0; CountNz = 0;
        CountNx_h = 0; CountNy_h = 0; CountNz_h = 0;
        CountNx_hh = 0; CountNy_hh = 0; CountNz_hh = 0;
    };
} LONG_DOUBLE_INT_VAR4, *PLONG_DOUBLE_INT_VAR4;

long double GreenwichAscensionFromTLEEpoch(long double EP, long double &preEps, long double &preTetta, long double &preZ, long double &nutEpsilon, long double &nutDFeta);
typedef struct TraObj
{
    long double TimeSl;
    long double TimeSl_div_m[PLANET_COUNT];
    long double TimeSl_2;
    long double TimeSl_2_div_m[PLANET_COUNT];
    long double TimeSlOld;
    int Elem;
    int flInUse[PLANET_COUNT];
    
    LONG_DOUBLE_INT_VAR _position_[PLANET_COUNT];

    LONG_DOUBLE_INT_VAR _velosity_[PLANET_COUNT];

    long double X[PLANET_COUNT];
    long double Y[PLANET_COUNT];
    long double Z[PLANET_COUNT];
    long double VX[PLANET_COUNT];
    long double VY[PLANET_COUNT];
    long double VZ[PLANET_COUNT];

    long double DX[PLANET_COUNT];
    long double DY[PLANET_COUNT];
    long double DZ[PLANET_COUNT];
    long double DVX[PLANET_COUNT];
    long double DVY[PLANET_COUNT];
    long double DVZ[PLANET_COUNT];

    long double SX[PLANET_COUNT];
    long double SY[PLANET_COUNT];
    long double SZ[PLANET_COUNT];
    long double SVX[PLANET_COUNT];
    long double SVY[PLANET_COUNT];
    long double SVZ[PLANET_COUNT];
    long double SFX[PLANET_COUNT];
    long double SFY[PLANET_COUNT];
    long double SFZ[PLANET_COUNT];


    long long CountNx;  // attention only 1 month with 1024 iteration per 1 sec == 2 month with iteration 512 sec
    long long CountNy;
    long long CountNz;
    BOOL RunOne;

    long double X_[PLANET_COUNT];
    long double VX_[PLANET_COUNT];
    long double FX[PLANET_COUNT];
    long double X0divDt2[PLANET_COUNT];
    long double VX0divDt[PLANET_COUNT];
    long double FX0[PLANET_COUNT];
    long double FX1[PLANET_COUNT];

    long double Y_[PLANET_COUNT];
    long double VY_[PLANET_COUNT];
    long double FY[PLANET_COUNT];
    long double Y0divDt2[PLANET_COUNT];
    long double VY0divDt[PLANET_COUNT];
    long double FY0[PLANET_COUNT];
    long double FY1[PLANET_COUNT];


    long double Z_[PLANET_COUNT];
    long double VZ_[PLANET_COUNT];
    long double FZ[PLANET_COUNT];
    long double Z0divDt2[PLANET_COUNT];
    long double VZ0divDt[PLANET_COUNT];
    long double FZ0[PLANET_COUNT];
    long double FZ1[PLANET_COUNT];

    long double fx[PLANET_COUNT];
    long double fy[PLANET_COUNT];
    long double fz[PLANET_COUNT];

    long double fsinX[PLANET_COUNT];
    long double fsinY[PLANET_COUNT];
    long double fsinZ[PLANET_COUNT];

#ifdef _BETTER_BUT_MANY_ITERATIONS
#else


    
#endif

    long double GM[PLANET_COUNT];
    long double M[PLANET_COUNT];
    long double GMxM[PLANET_COUNT][PLANET_COUNT];
    long double Distance[PLANET_COUNT][PLANET_COUNT];
    long double Distance2[PLANET_COUNT][PLANET_COUNT];
    long double ForceDD[PLANET_COUNT][PLANET_COUNT];
    char Kepler1[PLANET_COUNT][100];
    char Kepler2[PLANET_COUNT][100];
    char Kepler3[PLANET_COUNT][100];
    // 3 punch card calculation helper vars
    //
    //long double ProbEpochOnStart[PLANET_COUNT];
    long double ProbTLEEpoch[PLANET_COUNT];
    long double ProbJD[PLANET_COUNT];
    long double ProbJDSec[PLANET_COUNT];
    long double ProbMeanMotion[PLANET_COUNT];
    long double ProbFirstDervMeanMotion[PLANET_COUNT];
    long double ProbSecondDervmeanMotion[PLANET_COUNT];
    long double ProbDragterm[PLANET_COUNT];
    unsigned char ProbElementSetType[PLANET_COUNT];
    long double ProbIncl[PLANET_COUNT];
    long double ProbAscNode[PLANET_COUNT];
    long double ProbEcc[PLANET_COUNT];
    long double ProbArgPer[PLANET_COUNT];
    long double ProbMeanAnom[PLANET_COUNT];
    long double ProbTPeriod[PLANET_COUNT];
    long double ProbTDays[PLANET_COUNT];
    long double ProbTSec[PLANET_COUNT];
    long double ProbRevAtEpoch[PLANET_COUNT];
    long double ProbSquare[PLANET_COUNT];
    // satelitte close to body
    // it can be only one body
    int iLeg;
    int iLeg_longit;
    int LegBody;
#ifdef ALL_OLD_CODE
    long double J[MAX_COEF_J];
    long double CNK[MAX_COEF_J][MAX_COEF_J];
    long double SNK[MAX_COEF_J][MAX_COEF_J];
    long double SinTetta;
    long double P[MAX_COEF_J];
    //long double Rn1divR[MAX_COEF_J];
    long double Ptilda[MAX_COEF_J];
    long double Pnk_tilda[MAX_COEF_J][MAX_COEF_J];
    //double Pnk[MAX_COEF_J][MAX_COEF_J];
    long double Qnk[MAX_COEF_J][MAX_COEF_J];
#endif

    long double ForceDD_;
    long double Lambda; // that is direction to a Greenwich
    long double precEps; // that is epsilon in precession
    long double precTet; // that is Tetta in precession
    long double precZ;  // that is Z in precession
    long double nutEpsilon;
    long double nutDFeta;
    long double h[PLANET_COUNT];
    long double ro[PLANET_COUNT];
    long double H;
    long double Ro;
    long double d;// days from the begining of the year

    //long double Sc[PLANET_COUNT];
    //long double Fp[PLANET_COUNT];
    int iAtm[PLANET_COUNT];
    long double DeltaVX[PLANET_COUNT][PLANET_COUNT];
    long double DeltaVY[PLANET_COUNT][PLANET_COUNT];
    long double DeltaVZ[PLANET_COUNT][PLANET_COUNT];

#if 1
    long double Xk[MAX_COEF_J];
    long double Yk[MAX_COEF_J];
    long double XkDxr[MAX_COEF_J];
    long double YkDxr[MAX_COEF_J];
    long double XkDyr[MAX_COEF_J];
    long double YkDyr[MAX_COEF_J];
#endif
#if 0
    long double OneMinusSinTettaInSquare;
    long double OneMinusXdivRInSquare;
    long double OneMinusYdivRInSquare;
#endif
    long double OneMinusSinTettaInSquare2;
    long double OneMinusXdivRInSquare2;
    long double OneMinusYdivRInSquare2;
    long double XdivRval;
    long double YdivRval;
    //long double OneMinusXdivRInSquare_XdivRval[PLANET_COUNT][MAX_COEF_J][MAX_COEF_J];
    //long double OneMinusYdivRInSquare_YdivRval[PLANET_COUNT][MAX_COEF_J][MAX_COEF_J];
    //long double OneMinusZdivRInSquare_ZdivRval[PLANET_COUNT][MAX_COEF_J][MAX_COEF_J];
    //long double OldXSign[PLANET_COUNT][MAX_COEF_J][MAX_COEF_J];
    //long double OldYSign[PLANET_COUNT][MAX_COEF_J][MAX_COEF_J];
    //long double OldZSign[PLANET_COUNT][MAX_COEF_J][MAX_COEF_J];
    long double D_Qnk_Dxr[MAX_COEF_J][MAX_COEF_J];
    long double D_Qnk_Dyr[MAX_COEF_J][MAX_COEF_J];

    long double cos_precEps, sin_precEps;
    long double cos_precTet, sin_precTet;
    long double cos_precZ, sin_precZ;
    long double cos_Lambda, sin_Lambda;
    long double cos_nutEpsilon, sin_nutEpsilon;
    long double cos_nutDFeta, sin_nutDFeta;
    long double _SQRT3;
    long double R0divR[TOTAL_COEF+3];
    long double _p_n_m_1[TOTAL_COEF+3];
    long double _p_n_m_2[TOTAL_COEF+3];
    long double _pt_nk[TOTAL_COEF+3][TOTAL_COEF+3];
    long double _tp_nm1_k[TOTAL_COEF+3][TOTAL_COEF+3];
    long double _tp_nm2_k[TOTAL_COEF+3][TOTAL_COEF+3];
    long double _tpk_n_k[TOTAL_COEF+3];
    long double diagonal[TOTAL_COEF+3];
    long double _p_n_k[TOTAL_COEF+3];
    int i_proc;
typedef struct CpuData {
    int cpuid;
    TraObj *my;
    long double *ParamSinTetta;
    long double xx, xadd, yadd,zadd;
    long double *Xk;
    long double *Yk;
    long double *R0divR;
    volatile int WaitVar;
    volatile int WaitDoVar;
} CPUDATA, *PCPUDATA;

typedef struct CpuMemory {
    long double R0divR[TOTAL_COEF+3];
    long double _p_n_m_1[TOTAL_COEF+3];
    long double _p_n_m_2[TOTAL_COEF+3];
    long double _pt_nk[TOTAL_COEF+3][TOTAL_COEF+3];
    long double _tp_nm1_k[TOTAL_COEF+3][TOTAL_COEF+3];
    long double _tp_nm2_k[TOTAL_COEF+3][TOTAL_COEF+3];
    long double _tpk_n_k[TOTAL_COEF+3];
    long double diagonal[TOTAL_COEF+3];
    long double _p_n_k[TOTAL_COEF+3];
    long double Xk[TOTAL_COEF+3];
    long double Yk[TOTAL_COEF+3];
    long double C_S_nk[(TOTAL_COEF+3)*(TOTAL_COEF+3)][2];
    long double _SQRT3;
} CPUMEMORY, *PCPUMEMORY;

    HANDLE mainThread;
    CPUMEMORY MainCpu;

    CPUDATA CPUID[32];
    int i_split[32][3];
    DWORD dwServiceStateThreadID[32];

    HANDLE		hWaitForExit[32];
    HANDLE		hWaitCmdDoCalc[32];
    HANDLE		hWaitCmdDoneCalc[32];
    HANDLE		hWaitCmdStop[32];
    HANDLE		Callback_Thread[32];

// uncomment - for thread signalling used SetEvent ; commented - for thread signalling used pooling
#define THREAD_SIGNAL SET_EVENT
#ifdef THREAD_SIGNAL
#define WAIT_THREAD_POINT while((ResWait = WaitForMultipleObjects(2,hList,FALSE,INFINITE)) != WAIT_OBJECT_0 )
#define DONE_THREAD_SIGNAL SetEvent(my->hWaitCmdDoneCalc[cpuid]);
#define CONTINUE_TO_WAIT ;
#else
#define WAIT_THREAD_POINT WAIT_AGAIN:\
        my->CPUID[cpuid].WaitDoVar = 0;\
        SetThreadPriority(my->Callback_Thread[cpuid],THREAD_PRIORITY_IDLE);\
        while(my->CPUID[cpuid].WaitDoVar == 0)\
        {\
            SwitchToThread();\
        }\
        SetThreadPriority(my->Callback_Thread[cpuid],THREAD_PRIORITY_NORMAL);\
        if (my->CPUID[cpuid].WaitDoVar == 1)


#define DONE_THREAD_SIGNAL Param->WaitVar = 1;
#define CONTINUE_TO_WAIT goto WAIT_AGAIN;
#endif


    static DWORD WINAPI CallbackThread_Proc(LPVOID lParm)
    {   
        UINT uResult = 0;
	    DWORD ResWait;
	    HANDLE hList[2];
	    BOOL bFound;
	    BOOL bRes;
	    int iRea;
        int Nb, Ne, Kb, Ke, Nall;
        CPUDATA *Param = (CPUDATA*)lParm;
        TraObj *my = Param->my;
        int cpuid = Param->cpuid;
        long double *pSinTetta = Param->ParamSinTetta;
        long double sin_Tetta;
        long double xx, xadd, yadd,zadd;
        CPUMEMORY ThreadCpuMem;
	
        hList[0] = my->hWaitCmdStop[cpuid];
	    hList[1] = my->hWaitCmdDoCalc[cpuid];

        //bRes = SetThreadAffinityMask(my->Callback_Thread[cpuid],4);

        memcpy(ThreadCpuMem.diagonal, my->diagonal, sizeof(ThreadCpuMem.diagonal));
        memcpy(ThreadCpuMem._pt_nk, my->_pt_nk, sizeof(ThreadCpuMem._pt_nk));
        memcpy(ThreadCpuMem._p_n_m_1, my->_p_n_m_1, sizeof(ThreadCpuMem._p_n_m_1));
        memcpy(ThreadCpuMem._p_n_m_2, my->_p_n_m_2, sizeof(ThreadCpuMem._p_n_m_2));
        memcpy(ThreadCpuMem._tpk_n_k, my->_tpk_n_k, sizeof(ThreadCpuMem._tpk_n_k));
        memcpy(ThreadCpuMem._tp_nm1_k, my->_tp_nm1_k, sizeof(ThreadCpuMem._tp_nm1_k));
        memcpy(ThreadCpuMem._tp_nm2_k, my->_tp_nm2_k, sizeof(ThreadCpuMem._tp_nm2_k));
        memcpy(ThreadCpuMem.C_S_nk, C_S_nk, sizeof(ThreadCpuMem.C_S_nk));
        memcpy(ThreadCpuMem._p_n_k, my->_p_n_k, sizeof(ThreadCpuMem._p_n_k));
        ThreadCpuMem._SQRT3 = my->_SQRT3;
        if (cpuid == 0)
            Nb = 2;
        else
            Nb = my->i_split[cpuid][0];

        Ne = my->iLeg;
        Kb = my->i_split[cpuid][0];
        Ke = my->i_split[cpuid][1];
        WAIT_THREAD_POINT
	    {
            sin_Tetta = *Param->ParamSinTetta;
            memcpy(ThreadCpuMem.Xk, Param->Xk,sizeof(ThreadCpuMem.Xk));
            memcpy(ThreadCpuMem.Yk, Param->Yk,sizeof(ThreadCpuMem.Yk));
            memcpy(ThreadCpuMem.R0divR, Param->R0divR,sizeof(ThreadCpuMem.R0divR));
            my->CpuPartSummXYZ ( &ThreadCpuMem, sin_Tetta,  xx, xadd, yadd, zadd, Nb , Ne, Kb, Ke);
            //my->CpuPartSummXYZ ( &ThreadCpuMem, sin_Tetta,  xx, xadd, yadd, zadd, 2 , Ne, 0, Ne);
            Param->xx = xx; Param->xadd = xadd; Param->yadd = yadd; Param->zadd = zadd;
            DONE_THREAD_SIGNAL
            CONTINUE_TO_WAIT
        }
	    SetEvent(my->hWaitForExit[cpuid]);
	    return(uResult);   
    };
    

    void StartThreads(void)
    {
        if (i_proc > 1)
        {
            mainThread = GetCurrentThread();
#ifndef THREAD_SIGNAL
            DWORD dwProcessAffinityMask;
            DWORD dwSystemAffinityMask;
            DWORD dwThreadAffinityMask = 1;
            BOOL Ret;
            GetProcessAffinityMask(GetCurrentProcess(), &dwProcessAffinityMask, &dwSystemAffinityMask);
            Ret = SetThreadAffinityMask(GetCurrentThread(), dwThreadAffinityMask);
            dwThreadAffinityMask <<= 2;
#endif
            for (int i =1; i <i_proc; i++)
            {
                hWaitForExit[i] = CreateEvent(NULL, FALSE, TRUE, NULL);
                ResetEvent(hWaitForExit[i]);
                hWaitCmdDoCalc[i] = CreateEvent(NULL, FALSE, TRUE, NULL);
                ResetEvent(hWaitCmdDoCalc[i]);
                hWaitCmdDoneCalc[i] = CreateEvent(NULL, FALSE, TRUE, NULL);
                ResetEvent(hWaitCmdDoneCalc[i]);
                hWaitCmdStop[i] = CreateEvent(NULL, FALSE, TRUE, NULL);
                ResetEvent(hWaitCmdStop[i]);

                Callback_Thread[i] = CreateThread(NULL,20980000,(LPTHREAD_START_ROUTINE)CallbackThread_Proc,(LPVOID)&CPUID[i], 0/*STACK_SIZE_PARAM_IS_A_RESERVATION*/,&dwServiceStateThreadID[i]);
#ifndef THREAD_SIGNAL
                SetThreadPriority(Callback_Thread[i],THREAD_PRIORITY_TIME_CRITICAL);
                SwitchToThread();
                if (dwThreadAffinityMask & dwProcessAffinityMask)
                {
                    Ret = SetThreadAffinityMask(Callback_Thread[i],dwThreadAffinityMask);
                    dwThreadAffinityMask <<= 2;
                }
#endif
                //SetThreadPriority(Callback_Thread[i],THREAD_PRIORITY_IDLE);
                DWORD err = GetLastError();
            }
            
        }

    }
    void StopThreads(void)
    {
        int i;
        if (i_proc > 1)
        {
            for (i =1; i <i_proc; i++)
            {
                SetEvent(hWaitCmdStop[i]);
                CPUID[i].WaitDoVar = 2;
                SetThreadPriority(Callback_Thread[i],THREAD_PRIORITY_TIME_CRITICAL);
            }
            CPUID[0].WaitDoVar = 2;
            
            WaitForMultipleObjects(i_proc-1,&hWaitForExit[1],TRUE,2000);
            for (i =1; i <i_proc; i++)
            {
                CloseHandle(hWaitForExit[i]);
                CloseHandle(hWaitCmdDoCalc[i]);
                CloseHandle(hWaitCmdDoneCalc[i]);
                CloseHandle(hWaitCmdStop[i]);
            }
        }
    }
    void calc_tr_matrix(void)
    {
        cos_precEps= cos(precEps); sin_precEps= sin(precEps);
        cos_precTet = cos(precTet); sin_precTet = sin(precTet);
        cos_precZ =  cos(precZ); sin_precZ = sin(precZ);
        cos_nutEpsilon = cos(nutEpsilon); sin_nutEpsilon = sin(nutEpsilon);
        cos_nutDFeta = cos(nutDFeta); sin_nutDFeta=sin(nutDFeta);
        cos_Lambda = cos(Lambda); sin_Lambda = sin(Lambda);
    }
    void gcrs_2_trs(long double &X, long double &Y, long double &Z)
    {
        long double tempX;
        long double tempY;
        long double tempZ;
        // matrix Deps
            cos_precEps= cos(precEps); sin_precEps= sin(precEps);
            //| cos(eps)   sin(eps) 0 |
            //| -sin(eps)  cos(eps) 0 |
            //|   0           0     1 |
            tempX =  cos_precEps * X + sin_precEps * Y;
            tempY = -sin_precEps * X + cos_precEps * Y;
            X = tempX; Y = tempY;
       // matrix Dtet
            cos_precTet = cos(precTet); sin_precTet = sin(precTet);
            //| cos(tet)   0 sin(tet) | 
            //|   0        1        0 |
            //|- sin(tet)  0 cos(tet) |
            tempX =  cos_precTet * X + sin_precTet * Z;
            tempZ = -sin_precTet * X + cos_precTet * Z;
            X = tempX; Z = tempZ;
       // matrix Dz
            cos_precZ =  cos(precZ); sin_precZ = sin(precZ);
            //| cos(z)  -sin(z) 0 | 
            //| sin(z)   cos(z) 0 |
            //|   0      0     1 |
            tempX =  cos_precZ * X - sin_precZ * Y;
            tempY =  sin_precZ * X + cos_precZ * Y;
            X = tempX; Y = tempY;

       // matrix C nut Epsilon
            cos_nutEpsilon = cos(nutEpsilon); sin_nutEpsilon = sin(nutEpsilon);
            tempY =    cos_nutEpsilon * Y + sin_nutEpsilon * Z;
            tempZ =  - sin_nutEpsilon * Y + cos_nutEpsilon * Z;
            Y = tempY; Z = tempZ;
            
       // matrix C nut dFeta
            cos_nutDFeta = cos(nutDFeta); sin_nutDFeta=sin(nutDFeta);
            tempX =  cos_nutDFeta * X - sin_nutDFeta * Y;
            tempY =  sin_nutDFeta * X + cos_nutDFeta * Y;
            X = tempX; Y = tempY;

       // matrix C nut Epsilon Trans
            tempY =    cos_nutEpsilon * Y - sin_nutEpsilon * Z;
            tempZ =    sin_nutEpsilon * Y + cos_nutEpsilon * Z;
            Y = tempY; Z = tempZ;

            // matrix B:
            cos_Lambda = cos(Lambda); sin_Lambda = sin(Lambda);
            //| cos(h)   sin(h) 0 |  |
            //| -sin(h)  cos(h) 0 |
            //|   0       0     1 |
            tempX = cos_Lambda * X + sin_Lambda * Y;
            tempY = -sin_Lambda * X + cos_Lambda * Y;
            X = tempX; Y = tempY;
    };
    void trs_2_gcrs(long double &X, long double &Y, long double &Z)
    {
        long double tempX;
        long double tempY;
        long double tempZ;
        // matrix (T) B:
        //| cos(h)   -sin(h) 0 |  |
        //| sin(h)   cos(h) 0 |
        //|   0        0     1 |
        tempX = cos_Lambda * X - sin_Lambda * Y;
        tempY = sin_Lambda * X + cos_Lambda * Y;
        X = tempX; Y = tempY;

       // matrix (T) C nut Epsilon Trans
            tempY =    cos_nutEpsilon * Y + sin_nutEpsilon * Z;
            tempZ =  - sin_nutEpsilon * Y + cos_nutEpsilon * Z;
            Y = tempY; Z = tempZ;

       // matrix (T)C nut dFeta
            tempX =  cos_nutDFeta * X + sin_nutDFeta * Y;
            tempY = -sin_nutDFeta * X + cos_nutDFeta * Y;
            X = tempX; Y = tempY;

       // matrix C (T) nut Epsilon
            tempY =    cos_nutEpsilon * Y - sin_nutEpsilon * Z;
            tempZ =    sin_nutEpsilon * Y + cos_nutEpsilon * Z;
            Y = tempY; Z = tempZ;

        // matrix (T) Dz
            //| cos(z)   sin(z) 0 | 
            //|-sin(z)   cos(z) 0 |
            //|   0      0     1 |
            tempX =  cos_precZ * X + sin_precZ * Y;
            tempY = -sin_precZ * X + cos_precZ * Y;
            X = tempX; Y = tempY;
        // matrix(T) Dtet
            //| cos(tet)   0 -sin(tet) | 
            //|   0        1        0  |
            //| sin(tet)   0  cos(tet) |
            tempX =  cos_precTet * X - sin_precTet * Z;
            tempZ =  sin_precTet * X + cos_precTet * Z;
            X = tempX; Z = tempZ;

        // matrix (T) Deps
            //| cos(eps)   -sin(eps) 0 |
            //| sin(eps)    cos(eps) 0 |
            //|   0           0     1 |
            tempX =  cos_precEps * X - sin_precEps * Y;
            tempY =  sin_precEps * X + cos_precEps * Y;
            X = tempX; Y = tempY;
    }
    long double GetDens(void)
    {
#define _E_CONST 2.71828182845904523536028
#if 0
#define _Ro0 1.2250
#define _M 0.0289644
#define _R_STAR 8.31432
#define __G0 9.80665
        long double Tb= 288.15;
        if (H< 11000.0)
        {
#define _LB 288.15
#define _LR -0.0065
            Tb = _LB  + _LR*H;
            Ro = _Ro0 *pow((_LB + _LR* H)/_LB, (long double)-__G0 *_M/_R_STAR/_LR-1.0);
        }
        else if (H < 20000.0)
        {
#define _LB 216.65
#undef _Ro0
#define _Ro0 0.36391802667700957
            Tb = _LB;
            Ro = _Ro0 *pow((long double)_E_CONST,(-__G0 * _M * (H-11000.0))/_R_STAR/_LB);
        }
        else if (H< 32000.0)
        {
#define _LB 216.65
#define _LR 0.001
#undef _Ro0
#define _Ro0 0.088034864330498286
            Tb = _LB  + _LR*H;
            Ro = _Ro0 *pow((_LB + _LR* (H-20000.0))/_LB, (long double)-__G0 *_M/_R_STAR/_LR-1.0);
        }
        else if (H<47000.0)
        {
#define _LB 228.65
#define _LR 0.0028
#undef _Ro0
#define _Ro0 0.013225008760250812
            Tb = _LB  + _LR*H;
            Ro = _Ro0 *pow((_LB + _LR* (H-32000.0))/_LB, (long double)-__G0 *_M/_R_STAR/_LR-1.0);
        }
        else if (H < 51000.0)
        {
#define _LB 270.65
#undef _Ro0
#define _Ro0 0.0014275334960788702
            Tb = _LB;            
            Ro = _Ro0 *pow((long double)_E_CONST,(-__G0 * _M * (H-47000.0))/_R_STAR/_LB);
        }
        else if (H<71000.0)
        {
#define _LB 270.65
#define _LR -0.0028
#undef _Ro0
#define _Ro0 0.00086160550652810688
            Tb = _LB  + _LR*H;
            Ro = _Ro0 *pow((_LB + _LR* (H-51000.00))/_LB, (long double)-__G0 *_M/_R_STAR/_LR-1.0);
        }
        else if (H < 120000.0)
        {
#define _LB 214.65
#define _LR -0.002
#undef _Ro0
#define _Ro0 6.4211030986884037e-005

            Tb = _LB  + _LR*H;
            Ro = _Ro0 *pow((_LB + _LR* (H-71000.0))/_LB, (long double)-__G0 *_M/_R_STAR/_LR-1.0);
        }
#undef _Ro0
#undef _M
#undef _R_STAR
#undef __G0
#undef _LB
#undef _LR
#else
#define _A0 (long double)1.228
#define _K1 -.090764e-3
#define _H0 0
#define _K2 -2.045e-9
#define _H0_TOP 20000.0
        if (H < _H0_TOP)
        {
            Ro = _A0 * pow((long double)_E_CONST, _K1* (H-_H0) + _K2*(H-_H0)*(H-_H0));
        }
        #undef _A0
#undef _K1
#undef _H0
#undef _K2
#undef _H0_TOP
#define _A0 (long double)9.013e-2
#define _K1 -0.16739e-3
#define _H0 20000
#define _K2 6.2669e-10
#define _H0_TOP 60000.0
        else if (H < _H0_TOP)
        {
            Ro = _A0 * pow((long double)_E_CONST, _K1* (H-_H0) + _K2*(H-_H0)*(H-_H0));
        }
#undef _A0
#undef _K1
#undef _H0
#undef _K2
#undef _H0_TOP
#define _A0 (long double)3.104e-4
#define _K1 -0.137e-3
#define _H0 60000
#define _K2 -7.8653e-10
#define _H0_TOP 100000.0
        else if (H < _H0_TOP)
        {
            Ro = _A0 * pow((long double)_E_CONST, _K1* (H-_H0) + _K2*(H-_H0)*(H-_H0));
        }
#undef _A0
#undef _K1
#undef _H0
#undef _K2
#undef _H0_TOP
#define _A0 (long double)3.66e-7
#define _K1 -0.18553e-3
#define _H0 100000
#define _K2 1.5397e-9
#define _H0_TOP 120000.0
        else if (H < _H0_TOP)
        {
            Ro = _A0 * pow((long double)_E_CONST, _K1* (H-_H0) + _K2*(H-_H0)*(H-_H0));
        }
        else if (H < 1500000.0) // 120 km
        {
            long double Hkm = H/1000.0;
#undef _A0
#undef _K1
#undef _H0
#undef _K2
#undef _H0_TOP

            // from GOST P 25645.166-2004
#define _RO_0 1.58868e-8
            long double F10_7 = 115;
            long double F81 = 115;
            long double F0 = 75.0; 
            int SA = 0;
            int Hr_for_AO = 0;
            int Hr_for_L0 = 0;
            int Hr_for_B0 = 0;
            for (SA = 0; SA < 6; SA++)
            {
                if ((F0+25.0) > F81)
                    break;
                F0 += 25.0;
            }
            if ((__AH[Hr_for_AO][SA] < Hkm) && (__AH[Hr_for_AO+1][SA] > Hkm))
                ;
            else
                Hr_for_AO = 1;
            if ((__LH[Hr_for_L0][SA] < Hkm) && (__LH[Hr_for_L0+1][SA] > Hkm))
                ;
            else
                Hr_for_L0 = 1;

            if ((__BH[Hr_for_B0][SA] < Hkm) && (__BH[Hr_for_B0+1][SA] > Hkm))
                ;
            else
                Hr_for_B0 = 1;
            

            long double RoH = _RO_0 * pow((long double)_E_CONST, __AO[Hr_for_AO][0][SA] + (__AO[Hr_for_AO][1][SA] + (__AO[Hr_for_AO][2][SA] + (__AO[Hr_for_AO][3][SA] + (__AO[Hr_for_AO][4][SA]+ (__AO[Hr_for_AO][5][SA]+ __AO[Hr_for_AO][6][SA]*Hkm)*Hkm)*Hkm)*Hkm) *Hkm)*Hkm);
            long double K0 = 1 + (__L0[Hr_for_L0][0][SA] + (__L0[Hr_for_L0][1][SA]+(__L0[Hr_for_L0][2][SA]+(__L0[Hr_for_L0][3][SA]+(__L0[Hr_for_L0][4][SA])*Hkm)*Hkm)*Hkm)*Hkm)*(F81-F0)/F0;
            long double K1 = 0;
            long double K2 = 0;
            long double K3 = 0;
            if (F10_7 != F81)
                K3 = (__BO[Hr_for_B0][0][SA] + (__BO[Hr_for_B0][1][SA]+(__BO[Hr_for_B0][2][SA]+(__BO[Hr_for_B0][3][SA]+(__BO[Hr_for_B0][4][SA])*Hkm)*Hkm)*Hkm)*Hkm)*(F10_7 - F81)/(F81+fabs(F10_7-F81));
            long double K4 = 0;
            Ro = RoH * K0 * (1 + K1 + K2 + K3 + K4);
        }
        else
            Ro = 0;

#endif
        return Ro;
    };
        // LAT  == shirota
        // LON == dolgota
        // (1) sin(LAT) = z/R  => LAT = arcsin(z/R)
        //
        // (2) sin(LON) = - X / (R * cos(LAT))
        //     LON = arcsin(- X / (R * cos(LAT)))
        //     cos(LON) = Y / (R * cos(LAT))
        //                                             AY
        //      0-> PI/2     sin(LON)<0 cos(LON)>0     | sin(LON) >0 cos(LON) >0      0 -> -PI/2
        //      -------------------------------------------------------------------------------> X
        //      PI/2->PI     sin(LON)<0 cos(LON)<0     | sin(LON)>0 cos(LON) <0    -PI/2 -> -PI

    // do not remember == from where code (below) was taken?  Some source code probably
    long double GetH(long double X, long double Y, long double Z, long double a, long double b, long double &ldLAT, long double &ldLON)
    {
        long double r = sqrt(X*X + Y*Y);
        if (r ==0.0)
        {
            ldLAT = 180.0/M_PI* asin(Z/sqrt(X*X + Y*Y + Z*Z));
            ldLON = 0;
            return fabs(Z)-b;
        }
    
        long double f = (a-b)/a;
        long double c= a/(1-f);
        long double e2 = f*(2-f);
        long double e_tilda_2 = e2/(1-e2);
        long double tg_B0 = Z/r*(1+e_tilda_2*b/sqrt(X*X+Y*Y*Z*Z));
        long double sin_;
        long double cos_;
        for (int i = 0; i<2;i++)
        {
            long double tg_tetta = (1-f)*tg_B0;
            long double tetta = atan(tg_tetta);
            sin_ = sin(tetta);
            cos_ = cos(tetta);
            long double sin_3=sin_*sin_*sin_;
            long double cos_3=cos_*cos_*cos_;
            tg_B0 = (Z+e_tilda_2*b*sin_3)/(r-e2*a*cos_3);
        }
        long double lat = atan(tg_B0);
        ldLAT = lat*180/M_PI;
        ldLON = - X / (sqrt(X*X + Y*Y + Z*Z) * cos(lat))*180/M_PI;
        long double n = c /sqrt(1.0 +e_tilda_2* cos(lat)*cos(lat));
        if (fabs(tg_B0) <=1.0)
            return r/cos(lat) -n;
        else
            return Z/sin(lat) - n*(1.0-e_tilda_2);
	};
    ////////////////////////////////////////////////////////////////////////////////////////////////
    // geodesial to trs
    // source: http://www.astronet.ru/db/msg/1190817/node25.html
    // and http://gis-lab.info/qa/geodesic-coords.html (some error has to be fixed)
    void LatLongToTRS(long double Long,long double Lat,long double h, long double a, long double b, long double &PosX,long double &PosY,long double &PosZ)
    {
        //initial calculations
        long cos_lat = cos(Lat* M_PI/180.0);
        long sin_lat = sin(Lat* M_PI/180.0);
        long double f = (a-b)/a;
        long double c= a/(1-f);
        long double e2 = f*(2-f);
        long double e_tilda_2 = e2/(1-e2);
        long double n = c / sqrt(1.0 + e_tilda_2 * cos_lat *cos_lat);

        //   LAT = latitude * pi/180    // shirota
        //   LON = longitude * pi/180   // dolgota
        //   Y =  R * cos(LAT) * cos(LON)
        //   Z =  R * sin(LAT) 
        //   X = -R * cos(LAT) * sin(LON)

        //PosZ =   dRadius * sin(Lat* M_PI/180.0);
        //PosX = - dRadius * cos(Lat* M_PI/180.0) * sin(Long* M_PI/180.0); ///??????
        //PosY =   dRadius * cos(Lat* M_PI/180.0) * cos(Long* M_PI/180.0); ///??????

        PosX = (n+h) * cos_lat * cos(Long* M_PI/180.0);
        PosY = (n+h) * cos_lat * sin(Long* M_PI/180.0);
        PosZ = (n + h - e2 * n) * sin_lat;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////
    // geodesial to crs
    void LatLongToCRS(long double Long,long double Lat,long double h, long double a, long double b, long double curTLETime, long double &PosX,long double &PosY,long double &PosZ)
    {
        Lambda = GreenwichAscensionFromTLEEpoch(curTLETime,precEps,precTet,precZ,nutEpsilon,nutDFeta);
        LatLongToTRS(Long, Lat, h, a, b, PosX, PosY, PosZ);
        calc_tr_matrix();
        trs_2_gcrs(PosX, PosY, PosZ);

    }
#if 1

#if 1
    void CalcSplit(long iCoefs, long iCpu)
    {
        if (iCpu < 0)
        {

            DWORD_PTR dwProcessAffinityMask;
            DWORD_PTR dwSystemAffinityMask;
            DWORD_PTR dwThreadAffinityMask = {1};
            BOOL Ret;
            GetProcessAffinityMask(GetCurrentProcess(), &dwProcessAffinityMask, &dwSystemAffinityMask);
            iCpu = 0;
            while(dwThreadAffinityMask & dwProcessAffinityMask)
            {
                dwThreadAffinityMask <<=2;
                iCpu++;
            }
            CpuCore = iCpu;
            printf("\n detected %d cpu",CpuCore);
            
        }
        i_proc = 0;
        long iAll = 0;
        int i;
        long irow = iCoefs -2;
        for (int i = 0; i< iCoefs; i++)
        {
            iAll += irow;
            if (i>=2)
                irow--;
        }
        long iCount = iAll/iCpu;
        long iEachCount = 0;
        irow = iCoefs -2;
        i_split[i_proc][0] = 0;
        for (int i = 0; i< iCoefs; i++)
        {
            iEachCount += irow;
            if (i>=2)
                irow--;
            if (iEachCount >= (iAll*(i_proc+1))/iCpu)
            {
                CPUID[i_proc].cpuid = i_proc;
                CPUID[i_proc].my = this;
                CPUID[i_proc].WaitVar = 0;
                CPUID[i_proc].WaitDoVar = 0;
                i_split[i_proc][2] = iEachCount;
                i_split[i_proc++][1] = i;
                i_split[i_proc][0] = i+1;
                
            }
        }
        i_split[i_proc-1][1] = i_split[i_proc][0];
    }

    void PowerR(long double *__R0divR)
    {
        long double R0divR_ = __R0divR[1]*__R0divR[1];
        for (int n = 2; n <= iLeg; n++)
        {
            __R0divR[n] = R0divR_;
            R0divR_*= __R0divR[1];
        }
    }
    void CpuPartSummXYZ (CPUMEMORY * CpuMemory, long double sinTetta, long double &MainVal, 
        long double &Xadd, long double &Yadd, long double &Zadd, int Nstart, int Nstop, int Kstart, int Kstop)
    {
        int k;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        int n = 0;  //  initial

        long double Ptilda_m_2[TOTAL_COEF+3];
        long double Ptilda_m_1[TOTAL_COEF+3];
        long double Ptilda_[TOTAL_COEF+3];
        long double *ptilda_m_2 = &Ptilda_m_2[Kstart];
        long double *ptilda_m_1 = &Ptilda_m_1[Kstart];
        long double *ptilda_=&Ptilda_[Kstart];
        int cpSize = sizeof(long double) *3;
        long double P_20_x_Q20_ = 0;
        long double Ptilda_20_x_Qnk_ = 0;
        long double C_nk_ip;
        long double S_nk_ip;

        long double P_nk_x_Qnk_;
        long double Ptilda_nk_x_Qnk_;
        long double P_nk_x_K_x_XSumD;
        long double P_nk_x_K_x_YSumD;

        long double p_nk_x_Qnk_ = 0.0;
        long double ptilda_nk_x_Qnk_ = 0.0;
        long double p_nk_x_K_x_XSumD = 0.0;
        long double p_nk_x_K_x_YSumD = 0.0;

        for (k = Kstart; k <= Kstop+1; k++) 
        {
            Ptilda_[k] = 0;  Ptilda_m_1[k] =0;  Ptilda_m_2[k]=0;
        }
        long double P_m_2 = 0;
        long double P_m_1 = 0;
        long double P_ = 1;
        Ptilda_[0]= P_;



        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // next iteration by n
        n = 1;
        P_m_2 = P_m_1; P_m_1 = P_;
        memcpy(ptilda_m_2,ptilda_m_1, cpSize); memcpy(ptilda_m_1,ptilda_, cpSize);
        //P_ = sinTetta;

#ifdef _NORMALIZED_COEF
        P_ = sinTetta*CpuMemory->_SQRT3;
#else
        P_ = sinTetta;
#endif
        Ptilda_[0]= P_;

        //Ptilda_[1] = n * P_m_1 + sinTetta * Ptilda_m_1[1]; // P'[1]  k == '

        // P = sin => d(P)/d(sin) = 1
#ifdef _NORMALIZED_COEF
        Ptilda_[1] =  CpuMemory->_SQRT3;
#else
        Ptilda_[1] =  1;
#endif

        long double R0divR_;// = R0divR[1]*R0divR[1];
        int ip = 0;

        //int iXkYk = 1;
        int Klast;
        if (Nstart != 2)
        {
            for (n= 2; n< Nstart; n++)
            {
                ip +=n+1;
                //R0divR[n] = R0divR_;
                //R0divR_*= R0divR[1];
            }
        }
        
        for (n = Nstart; n <=Nstop; n++)
        {
            R0divR_ = CpuMemory->R0divR[n];
            if (Kstop >= n)
            {
                Klast = n;
                cpSize += sizeof(long double);
            }
            else
                Klast = Kstop;
            ip+=Kstart;
            P_nk_x_Qnk_ = 0;
            Ptilda_nk_x_Qnk_ = 0;
            P_nk_x_K_x_XSumD = 0;
            P_nk_x_K_x_YSumD = 0;

            for (k = Kstart; k <=Klast; k++)
            {
                long double P_nk;
                long double Ptilda_nk;
                long double Qnk_;
                long double XSumD, YSumD;

#if _DEBUG
                // sanity check n:
                if (n != nk_lm_Numbers[ip][0])
                    exit (1);
#endif
                if (k == Kstart)
                {
                    P_m_2 = P_m_1; P_m_1 = P_;
                    memcpy(ptilda_m_2,ptilda_m_1, cpSize); memcpy(ptilda_m_1,ptilda_, cpSize);
                    if (k)
                    {
                        //k=k-1;  // one Pnk left
                        if ((k-1)==n)
                            P_nk =0;
                        else
                        {
#ifdef _NORMALIZED_COEF
                            if ((k-1) == (n-1))
                                P_nk = CpuMemory->_p_n_k[n];
                            else if ((k-1) == (n-2))
                                P_nk = CpuMemory->_tpk_n_k[n]*sinTetta;
                            else
                                P_nk = CpuMemory->_tp_nm1_k [n][(k-1)+1] * Ptilda_m_1[(k-1)+1]*sinTetta - CpuMemory->_tp_nm2_k[n][(k-1)+1] * Ptilda_m_2[(k-1)+1];
#else
                            if ((k-1) == (n-1))
                                P_nk = CpuMemory->diagonal[n];
#ifdef _DO_NOT_SKIP_OBVIOUS
                            else if ((k-1) == (n-2))
                                P_nk = CpuMemory->diagonal[n]*sinTetta;
#endif
                            else
                                P_nk = ((2*n-1) * Ptilda_m_1[(k-1)+1]*sinTetta - (n + ((k-1)+1) -1)*Ptilda_m_2[(k-1)+1])/(n-((k-1)+1));
#endif
                        }
                        Ptilda_[(k-1)+1] = P_nk; // store Pnk and rerstore original K;
                        //k++;
                    }
                    else
                    {
                        //////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        // next iteration by n
#ifdef _NORMALIZED_COEF
                        P_ = CpuMemory->_p_n_m_1[n] *sinTetta * P_m_1 - CpuMemory->_p_n_m_2[n]*P_m_2;  // P[2]
#else
                        P_ = ((2.0* n-1.0) *sinTetta * P_m_1 - (n-1)*P_m_2)/n;  // P[2]
#endif
                        P_nk = P_;
                        /////////////////////////////////////////////////////////////////////////////  k =================0
                        //k = 0;
                        Ptilda_[k]= P_;
#if _DEBUG
                        // sanity check k:
                        if (k != nk_lm_Numbers[ip][1])
                            exit (1);
#endif
#ifdef _NORMALIZED_COEF
                        if (2 == n) // k==0 & n == 2
                            Ptilda_nk  = CpuMemory->_tpk_n_k[n]*sinTetta;
                        else
                            Ptilda_nk  = CpuMemory->_tp_nm1_k [n][k+1] * Ptilda_m_1[k+1]*sinTetta - CpuMemory->_tp_nm2_k[n][k+1] * Ptilda_m_2[k+1];
            
#else
#ifdef _DO_NOT_SKIP_OBVIOUS
                        if (2 == n) // k==0 & n == 2
                            Ptilda_nk  = CpuMemory->diagonal[n]*sinTetta;
                        else
#endif
                            Ptilda_nk  = ((2*n-1) * Ptilda_m_1[k+1]*sinTetta - (n + (k+1) -1)*Ptilda_m_2[k+1])/(n-(k+1));   // P'[2]
#endif
                        Ptilda_[k+1] = Ptilda_nk; // store P'[2] for use 
                        Qnk_ = CpuMemory->C_S_nk[ip][0] * CpuMemory->Xk[k] + CpuMemory->C_S_nk[ip][1] * CpuMemory->Yk[k];
                        // J case
                        if (ip == 0)
                        {
                            P_20_x_Q20_ = P_nk * Qnk_;
#ifdef _NORMALIZED_COEF
                            Ptilda_20_x_Qnk_ = CpuMemory->_pt_nk[n][k] *Ptilda_nk *  Qnk_;
#else
                            Ptilda_20_x_Qnk_ = Ptilda_nk *  Qnk_;
#endif
                        }
                        else
                        {
                            P_nk_x_Qnk_ += -(n+1) * P_nk * Qnk_;
#ifdef _NORMALIZED_COEF
                            Ptilda_nk_x_Qnk_ += - CpuMemory->_pt_nk[n][k] *Ptilda_nk *  Qnk_;
#else
                            Ptilda_nk_x_Qnk_ += - Ptilda_nk *  Qnk_ ;
#endif
                        }
                        ++ip;
                        continue;
                    }
                }
                ////////////////////////////////////////////////////////////////////////////////////////
                //for (k = 1; k <=n; k++)
                {
                    ////////////////////////////////////////////////////////////////////////////////////////
                    // next iteration == k ==2
#if _DEBUG
                    // sanity check k:
                    if (k != nk_lm_Numbers[ip][1])
                        exit (1);
#endif
                    C_nk_ip = CpuMemory->C_S_nk[ip][0];
                    S_nk_ip = CpuMemory->C_S_nk[ip][1];
                    Qnk_ = C_nk_ip * CpuMemory->Xk[k] + S_nk_ip * CpuMemory->Yk[k];
                    XSumD = C_nk_ip * CpuMemory->Xk[k-1] + S_nk_ip * CpuMemory->Yk[k-1];
                    YSumD = C_nk_ip * CpuMemory->Yk[k-1] - S_nk_ip * CpuMemory->Xk[k-1];
                    P_nk = Ptilda_[k];
                    if (k==n)
                        Ptilda_nk = 0;
                    else
                    {
#ifdef _NORMALIZED_COEF
                        if (k == (n-1))
                            Ptilda_nk  = CpuMemory->_p_n_k[n];
                        else if (k == (n-2))
                            Ptilda_nk  = CpuMemory->_tpk_n_k[n]*sinTetta;
                        else
                            Ptilda_nk  = CpuMemory->_tp_nm1_k [n][k+1] * Ptilda_m_1[k+1]*sinTetta - CpuMemory->_tp_nm2_k[n][k+1] * Ptilda_m_2[k+1];
#else
                        if (k == (n-1))
                            Ptilda_nk = CpuMemory->diagonal[n];
#ifdef _DO_NOT_SKIP_OBVIOUS
                        else if (k == (n-2))
                            Ptilda_nk = CpuMemory->diagonal[n]*sinTetta;
#endif
                        else
                            Ptilda_nk  = ((2*n-1) * Ptilda_m_1[k+1]*sinTetta - (n + (k+1) -1)*Ptilda_m_2[k+1])/(n-(k+1));
#endif
                    }
                    Ptilda_[k+1] = Ptilda_nk;
                    P_nk_x_Qnk_ += -(n+k+1) * P_nk * Qnk_;
#ifdef _NORMALIZED_COEF
                    Ptilda_nk_x_Qnk_ += - CpuMemory->_pt_nk[n][k] *Ptilda_nk *  Qnk_;   // sumh_n    (normalized == z[n][k] * Ptilda_nk *  Qnk_
#else
                    Ptilda_nk_x_Qnk_ += - Ptilda_nk *  Qnk_;
#endif
                    P_nk_x_K_x_XSumD += P_nk * ( k *  XSumD   );
                    P_nk_x_K_x_YSumD += P_nk * ( k * -YSumD   );
                }
                ++ip;
            }
            ////////////////////////////////////////////////////////////////////////////////////////
            // next iteration == k ==2
            ip += n - Klast;
            p_nk_x_Qnk_      += P_nk_x_Qnk_*R0divR_;
            ptilda_nk_x_Qnk_ +=Ptilda_nk_x_Qnk_*R0divR_;
            p_nk_x_K_x_XSumD +=P_nk_x_K_x_XSumD*R0divR_;
            p_nk_x_K_x_YSumD +=P_nk_x_K_x_YSumD*R0divR_;
            //R0divR[n] = R0divR_;
            //R0divR_*= R0divR[1];
        }
        Xadd = (    + p_nk_x_K_x_XSumD ); 
        Yadd = (    + p_nk_x_K_x_YSumD );
        Zadd = (    - ptilda_nk_x_Qnk_ );
        Zadd+= (  + Ptilda_20_x_Qnk_ * (1.0))* CpuMemory->R0divR[2];
        MainVal = (p_nk_x_Qnk_ + ptilda_nk_x_Qnk_ * sinTetta ) + (-(2+1) * P_20_x_Q20_ - Ptilda_20_x_Qnk_ * sinTetta)* CpuMemory->R0divR[2] ; 
    }
    void FillXkYk(long double XdivR, long double YdivR, long double *Xk, long double *Yk)
    {
        Xk[0] = 1.0;
        Yk[0] = 0.0;
        Xk[1] = Xk[0]*XdivR - Yk[0]*YdivR;
        Yk[1] = Yk[0]*XdivR + Xk[0]*YdivR;
        for (int k = 2; k <= iLeg; k++)
        {
            Xk[k] = Xk[k-1]*XdivR - Yk[k-1]*YdivR;
            Yk[k] = Yk[k-1]*XdivR + Xk[k-1]*YdivR;
        }
    }

    void PartSummXYZ ( long double *Xk, long double *Yk, long double sinTetta, long double &MainVal, 
        long double &Xadd, long double &Yadd, long double &Zadd, int Nstart, int Nstop, int Kstart, int Kstop)
    {
        int k;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        int n = 0;  //  initial

        long double Ptilda_m_2[TOTAL_COEF+3];
        long double Ptilda_m_1[TOTAL_COEF+3];
        long double Ptilda_[TOTAL_COEF+3];
        long double *ptilda_m_2 = &Ptilda_m_2[Kstart];
        long double *ptilda_m_1 = &Ptilda_m_1[Kstart];
        long double *ptilda_=&Ptilda_[Kstart];
        int cpSize = sizeof(long double) *3;
        long double P_20_x_Q20_ = 0;
        long double Ptilda_20_x_Qnk_ = 0;
        long double C_nk_ip;
        long double S_nk_ip;

        long double P_nk_x_Qnk_;
        long double Ptilda_nk_x_Qnk_;
        long double P_nk_x_K_x_XSumD;
        long double P_nk_x_K_x_YSumD;

        long double p_nk_x_Qnk_ = 0.0;
        long double ptilda_nk_x_Qnk_ = 0.0;
        long double p_nk_x_K_x_XSumD = 0.0;
        long double p_nk_x_K_x_YSumD = 0.0;

        //long double Xk[TOTAL_COEF+3];
        //long double Yk[TOTAL_COEF+3];
        //memcpy(Xk, xk, sizeof(Xk));
        //memcpy(Yk, yk, sizeof(Yk));


        for (k = Kstart; k <= Kstop+1; k++) 
        {
            Ptilda_[k] = 0;  Ptilda_m_1[k] =0;  Ptilda_m_2[k]=0;
        }
        long double P_m_2 = 0;
        long double P_m_1 = 0;
        long double P_ = 1;
        Ptilda_[0]= P_;



        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // next iteration by n
        n = 1;
        P_m_2 = P_m_1; P_m_1 = P_;
        memcpy(ptilda_m_2,ptilda_m_1, cpSize); memcpy(ptilda_m_1,ptilda_, cpSize);
        //P_ = sinTetta;

#ifdef _NORMALIZED_COEF
        P_ = sinTetta*_SQRT3;
#else
        P_ = sinTetta;
#endif
        Ptilda_[0]= P_;

        //Ptilda_[1] = n * P_m_1 + sinTetta * Ptilda_m_1[1]; // P'[1]  k == '

        // P = sin => d(P)/d(sin) = 1
#ifdef _NORMALIZED_COEF
        Ptilda_[1] =  _SQRT3;
#else
        Ptilda_[1] =  1;
#endif

        long double R0divR_;// = R0divR[1]*R0divR[1];
        int ip = 0;

        //int iXkYk = 1;
        int Klast;
        if (Nstart != 2)
        {
            for (n= 2; n< Nstart; n++)
            {
                ip +=n+1;
                //R0divR[n] = R0divR_;
                //R0divR_*= R0divR[1];
            }
        }
        
        for (n = Nstart; n <=Nstop; n++)
        {
            R0divR_ = R0divR[n];
            if (Kstop >= n)
            {
                Klast = n;
                cpSize += sizeof(long double);
            }
            else
                Klast = Kstop;
            ip+=Kstart;
            P_nk_x_Qnk_ = 0;
            Ptilda_nk_x_Qnk_ = 0;
            P_nk_x_K_x_XSumD = 0;
            P_nk_x_K_x_YSumD = 0;

            for (k = Kstart; k <=Klast; k++)
            {
                long double P_nk;
                long double Ptilda_nk;
                long double Qnk_;
                long double XSumD, YSumD;

#if _DEBUG
                // sanity check n:
                if (n != nk_lm_Numbers[ip][0])
                    exit (1);
#endif
                if (k == Kstart)
                {
                    P_m_2 = P_m_1; P_m_1 = P_;
                    memcpy(ptilda_m_2,ptilda_m_1, cpSize); memcpy(ptilda_m_1,ptilda_, cpSize);
                    if (k)
                    {
                        //k=k-1;  // one Pnk left
                        if ((k-1)==n)
                            P_nk =0;
                        else
                        {
#ifdef _NORMALIZED_COEF
                            if ((k-1) == (n-1))
                                P_nk = _p_n_k[n];
                            else if ((k-1) == (n-2))
                                P_nk = _tpk_n_k[n]*sinTetta;
                            else
                                P_nk = _tp_nm1_k [n][(k-1)+1] * Ptilda_m_1[(k-1)+1]*sinTetta - _tp_nm2_k[n][(k-1)+1] * Ptilda_m_2[(k-1)+1];
#else
                            if ((k-1) == (n-1))
                                P_nk = diagonal[n];
#ifdef _DO_NOT_SKIP_OBVIOUS
                            else if ((k-1) == (n-2))
                                P_nk = diagonal[n]*sinTetta;
#endif
                            else
                                P_nk = ((2*n-1) * Ptilda_m_1[(k-1)+1]*sinTetta - (n + ((k-1)+1) -1)*Ptilda_m_2[(k-1)+1])/(n-((k-1)+1));
#endif
                        }
                        Ptilda_[(k-1)+1] = P_nk; // store Pnk and rerstore original K;
                        //k++;
                    }
                    else
                    {
                        //////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        // next iteration by n
#ifdef _NORMALIZED_COEF
                        P_ = _p_n_m_1[n] *sinTetta * P_m_1 - _p_n_m_2[n]*P_m_2;  // P[2]
#else
                        P_ = ((2.0* n-1.0) *sinTetta * P_m_1 - (n-1)*P_m_2)/n;  // P[2]
#endif
                        P_nk = P_;
                        /////////////////////////////////////////////////////////////////////////////  k =================0
                        //k = 0;
                        Ptilda_[k]= P_;
#if _DEBUG
                        // sanity check k:
                        if (k != nk_lm_Numbers[ip][1])
                            exit (1);
#endif
#ifdef _NORMALIZED_COEF
                        if (2 == n) // k==0 & n == 2
                            Ptilda_nk  = _tpk_n_k[n]*sinTetta;
                        else
                            Ptilda_nk  = _tp_nm1_k [n][k+1] * Ptilda_m_1[k+1]*sinTetta - _tp_nm2_k[n][k+1] * Ptilda_m_2[k+1];
            
#else
#ifdef _DO_NOT_SKIP_OBVIOUS
                        if (2 == n) // k==0 & n == 2
                            Ptilda_nk  = diagonal[n]*sinTetta;
                        else
#endif
                            Ptilda_nk  = ((2*n-1) * Ptilda_m_1[k+1]*sinTetta - (n + (k+1) -1)*Ptilda_m_2[k+1])/(n-(k+1));   // P'[2]
#endif
                        Ptilda_[k+1] = Ptilda_nk; // store P'[2] for use 
                        Qnk_ = C_S_nk[ip][0] * Xk[k] + C_S_nk[ip][1] * Yk[k];
                        // J case
                        if (ip == 0)
                        {
                            P_20_x_Q20_ = P_nk * Qnk_;
#ifdef _NORMALIZED_COEF
                            Ptilda_20_x_Qnk_ = _pt_nk[n][k] *Ptilda_nk *  Qnk_;
#else
                            Ptilda_20_x_Qnk_ = Ptilda_nk *  Qnk_;
#endif
                        }
                        else
                        {
                            P_nk_x_Qnk_ += -(n+1) * P_nk * Qnk_;
#ifdef _NORMALIZED_COEF
                            Ptilda_nk_x_Qnk_ += - _pt_nk[n][k] *Ptilda_nk *  Qnk_;
#else
                            Ptilda_nk_x_Qnk_ += - Ptilda_nk *  Qnk_ ;
#endif
                        }
                        ++ip;
                        continue;
                    }
                }
                ////////////////////////////////////////////////////////////////////////////////////////
                //for (k = 1; k <=n; k++)
                {
                    ////////////////////////////////////////////////////////////////////////////////////////
                    // next iteration == k ==2
#if _DEBUG
                    // sanity check k:
                    if (k != nk_lm_Numbers[ip][1])
                        exit (1);
#endif
                    C_nk_ip = C_S_nk[ip][0];
                    S_nk_ip = C_S_nk[ip][1];
                    Qnk_ = C_nk_ip * Xk[k] + S_nk_ip * Yk[k];
                    XSumD = C_nk_ip * Xk[k-1] + S_nk_ip * Yk[k-1];
                    YSumD = C_nk_ip * Yk[k-1] - S_nk_ip * Xk[k-1];
                    P_nk = Ptilda_[k];
                    if (k==n)
                        Ptilda_nk = 0;
                    else
                    {
#ifdef _NORMALIZED_COEF
                        if (k == (n-1))
                            Ptilda_nk  = _p_n_k[n];
                        else if (k == (n-2))
                            Ptilda_nk  = _tpk_n_k[n]*sinTetta;
                        else
                            Ptilda_nk  = _tp_nm1_k [n][k+1] * Ptilda_m_1[k+1]*sinTetta - _tp_nm2_k[n][k+1] * Ptilda_m_2[k+1];
#else
                        if (k == (n-1))
                            Ptilda_nk = diagonal[n];
#ifdef _DO_NOT_SKIP_OBVIOUS
                        else if (k == (n-2))
                            Ptilda_nk = diagonal[n]*sinTetta;
#endif
                        else
                            Ptilda_nk  = ((2*n-1) * Ptilda_m_1[k+1]*sinTetta - (n + (k+1) -1)*Ptilda_m_2[k+1])/(n-(k+1));
#endif
                    }
                    Ptilda_[k+1] = Ptilda_nk;
                    P_nk_x_Qnk_ += -(n+k+1) * P_nk * Qnk_;
#ifdef _NORMALIZED_COEF
                    Ptilda_nk_x_Qnk_ += - _pt_nk[n][k] *Ptilda_nk *  Qnk_;   // sumh_n    (normalized == z[n][k] * Ptilda_nk *  Qnk_
#else
                    Ptilda_nk_x_Qnk_ += - Ptilda_nk *  Qnk_;
#endif
                    P_nk_x_K_x_XSumD += P_nk * ( k *  XSumD   );
                    P_nk_x_K_x_YSumD += P_nk * ( k * -YSumD   );
                }
                ++ip;
            }
            ////////////////////////////////////////////////////////////////////////////////////////
            // next iteration == k ==2
            ip += n - Klast;
            p_nk_x_Qnk_      += P_nk_x_Qnk_*R0divR_;
            ptilda_nk_x_Qnk_ +=Ptilda_nk_x_Qnk_*R0divR_;
            p_nk_x_K_x_XSumD +=P_nk_x_K_x_XSumD*R0divR_;
            p_nk_x_K_x_YSumD +=P_nk_x_K_x_YSumD*R0divR_;
            //R0divR[n] = R0divR_;
            //R0divR_*= R0divR[1];
        }
        Xadd = (    + p_nk_x_K_x_XSumD ); 
        Yadd = (    + p_nk_x_K_x_YSumD );
        Zadd = (    - ptilda_nk_x_Qnk_ );
        Zadd+= (  + Ptilda_20_x_Qnk_ * (1.0))*R0divR[2];
        MainVal = (p_nk_x_Qnk_ + ptilda_nk_x_Qnk_ * sinTetta ) + (-(2+1) * P_20_x_Q20_ - Ptilda_20_x_Qnk_ * sinTetta)*R0divR[2] ; 
    }
#if 1
    void FastSummXYZ( long double ValX, long double ValY, long double ValZ, long double ValR, long double &X, long double &Y, long double &Z, 
            long double &Xadd, long double &Yadd, long double &Zadd,
            int iCurSat)
    {
        int n,k;
        long double tempX;
        long double tempY;
        long double tempZ;
        long double sinTetta, XdivR, YdivR;
        X = 0; Y = 0; Z = 0;

        //long double _x[TOTAL_COEF][3];
        //long double _y[TOTAL_COEF][3];
        //long double _z[TOTAL_COEF][3];
        //long double _x20,_y20,_z20;
        long double P_20_x_Q20_;
        long double Ptilda_20_x_Qnk_;

        long double P_nk_x_Qnk_;//[TOTAL_COEF];
        long double Ptilda_nk_x_Qnk_;//[TOTAL_COEF];
        long double P_nk_x_K_x_XSumD;//[TOTAL_COEF];
        long double P_nk_x_K_x_YSumD;//[TOTAL_COEF];

        long double p_nk_x_Qnk_ = 0.0;
        long double ptilda_nk_x_Qnk_ = 0.0;
        long double p_nk_x_K_x_XSumD = 0.0;
        long double p_nk_x_K_x_YSumD = 0.0;

        tempX = ValX; tempY = ValY; tempZ = ValZ;
        gcrs_2_trs(tempX, tempY, tempZ);
        // now earth in Terra Ref System
        // it is possible to calculate H to get air drag
        if (--iAtm[iCurSat] == 0)
        {
            long double dlLAT, dlLON;
            iAtm[iCurSat] = iItearationsPerSec;//479; // onc per 1000 iteration == 1 per sec
            h[iCurSat] = H =GetH(tempX, tempY, tempZ, 6378245.000, 6356863.019,dlLAT,dlLON);
            ro[iCurSat] = Ro=GetDens(); // 15C
        }

        sinTetta =tempZ/ValR;

        XdivR =   tempX/ValR;
        YdivR =   tempY/ValR;
        XdivRval = XdivR;
        YdivRval = YdivR;
#ifdef ALL_OLD_CODE
        SinTetta = sinTetta;
#endif

        // loop iteration starts from n=2 k = 0
        // formula 8 on page 92
        long double Xk[TOTAL_COEF+3];
        long double Yk[TOTAL_COEF+3];
#if 0
        FillXkYk(XdivR, YdivR, Xk, Yk);
        PowerR(R0divR);
        if (i_proc == 0)
        {
            PartSummXYZ (Xk,Yk, sinTetta,  X, Xadd, Yadd, Zadd, 2, iLeg, 0, iLeg);

                           Y=X;            Z=X;
            X=1-X;         Y=1-Y;          Z=1-Z;
            Xadd = -Xadd;  Yadd = -Yadd;   Zadd = -Zadd;
        }

#else
        FillXkYk(XdivR, YdivR, MainCpu.Xk, MainCpu.Yk);
        MainCpu.R0divR[0] = R0divR[0];
        MainCpu.R0divR[1] = R0divR[1];
        PowerR(MainCpu.R0divR);
        if (i_proc <= 1)
        {
            CpuPartSummXYZ (&MainCpu, sinTetta,  X, Xadd, Yadd, Zadd, 2, iLeg, 0, iLeg);
                           Y=X;            Z=X;
            X=1-X;         Y=1-Y;          Z=1-Z;
            Xadd = -Xadd;  Yadd = -Yadd;   Zadd = -Zadd;
        }
#endif 
        else
        {
#define CALC_VIA_THREADS
#ifdef CALC_VIA_THREADS

#ifdef THREAD_SIGNAL
#define KICK_THREAD_SIGNAL SetEvent(hWaitCmdDoCalc[ipr]);
#define KICK_ALL_THREAD_SIGNAL ;
#define WAIT_ALL_THREAD_DONE WaitForMultipleObjects(i_proc-1,&hWaitCmdDoneCalc[1],TRUE,INFINITE);
#else
#define KICK_THREAD_SIGNAL CPUID[ipr].WaitDoVar = 1;\
                SetThreadPriority(Callback_Thread[ipr],THREAD_PRIORITY_TIME_CRITICAL);
#define KICK_ALL_THREAD_SIGNAL CPUID[0].WaitDoVar = 1;
#define WAIT_ALL_THREAD_DONE    int iDoneCound = 0;\
            for (ipr = 1; ipr< i_proc; ipr++)\
            {\
                iDoneCound += CPUID[ipr].WaitVar;\
            }\
            SetThreadPriority(mainThread,THREAD_PRIORITY_IDLE);\
            while(iDoneCound != (i_proc-1))\
            {\
                SwitchToThread(); \
                iDoneCound = 0;\
                for (ipr = 1; ipr< i_proc; ipr++)\
                {\
                    iDoneCound += CPUID[ipr].WaitVar;\
                }\
            }\
            SetThreadPriority(mainThread,THREAD_PRIORITY_NORMAL);\
            for (ipr = 0; ipr< i_proc; ipr++)\
                CPUID[ipr].WaitVar = 0; 
#endif
            int ipr;
            
            
            for (ipr = 1; ipr< i_proc; ipr++)
            {
                CPUID[ipr].ParamSinTetta = &sinTetta; CPUID[ipr].Xk =  MainCpu.Xk; CPUID[ipr].Yk = MainCpu.Yk;
                CPUID[ipr].R0divR = MainCpu.R0divR;
                KICK_THREAD_SIGNAL
            }
            //SetThreadPriority(mainThread,THREAD_PRIORITY_TIME_CRITICAL);
            CpuPartSummXYZ (&MainCpu, sinTetta,  X, Xadd, Yadd, Zadd, 2, iLeg, 0, i_split[0][1]);
            
            WAIT_ALL_THREAD_DONE
            
            for (ipr = 1; ipr< i_proc; ipr++)
            {
                X+= CPUID[ipr].xx;
                Xadd += CPUID[ipr].xadd;  Yadd += CPUID[ipr].yadd;  Zadd += CPUID[ipr].zadd;
            }
                           Y=X;            Z=X;
            X=1-X;         Y=1-Y;          Z=1-Z;
#else
            long double xx[4], xadd[4], yadd[4],zadd[4];
            PowerR(R0divR);
            // i_split[0][0] - i_split[0][1]
            PartSummXYZ ( MainCpu.Xk, MainCpu.Yk, sinTetta,  xx[0], xadd[0], yadd[0], zadd[0], 2            , iLeg, i_split[0][0], i_split[0][1]);
            PartSummXYZ ( MainCpu.Xk, MainCpu.Yk, sinTetta,  xx[1], xadd[1], yadd[1], zadd[1], i_split[1][0], iLeg, i_split[1][0], i_split[1][1]);
            PartSummXYZ ( MainCpu.Xk, MainCpu.Yk, sinTetta,  xx[2], xadd[2], yadd[2], zadd[2], i_split[2][0], iLeg, i_split[2][0], i_split[2][1]);
            PartSummXYZ ( MainCpu.Xk, MainCpu.Yk, sinTetta,  xx[3], xadd[3], yadd[3], zadd[3], i_split[3][0], iLeg, i_split[3][0], iLeg         );
            X = xx[0]+xx[1]+xx[2]+xx[3];
                           Y=X;            Z=X;
            X=1-X;         Y=1-Y;          Z=1-Z;
            Xadd = xadd[0]+xadd[1]+xadd[2]+xadd[3];
            Yadd = yadd[0]+yadd[1]+yadd[2]+yadd[3];
            Zadd = zadd[0]+zadd[1]+zadd[2]+zadd[3];
#endif
            Xadd = -Xadd;  Yadd = -Yadd;   Zadd = -Zadd;
        }
        trs_2_gcrs(Xadd, Yadd, Zadd);
    };
#else
    void FastSummXYZ( long double ValX, long double ValY, long double ValZ, long double ValR, long double &X, long double &Y, long double &Z, 
            long double &Xadd, long double &Yadd, long double &Zadd,
            int iCurSat)
    {
        int n,k;
        long double tempX;
        long double tempY;
        long double tempZ;
        long double sinTetta, XdivR, YdivR;
        X = 0; Y = 0; Z = 0;
        //long double _x[TOTAL_COEF][3];
        //long double _y[TOTAL_COEF][3];
        //long double _z[TOTAL_COEF][3];
        //long double _x20,_y20,_z20;
        long double P_20_x_Q20_;
        long double Ptilda_20_x_Qnk_;

        long double P_nk_x_Qnk_;//[TOTAL_COEF];
        long double Ptilda_nk_x_Qnk_;//[TOTAL_COEF];
        long double P_nk_x_K_x_XSumD;//[TOTAL_COEF];
        long double P_nk_x_K_x_YSumD;//[TOTAL_COEF];

        long double p_nk_x_Qnk_ = 0.0;
        long double ptilda_nk_x_Qnk_ = 0.0;
        long double p_nk_x_K_x_XSumD = 0.0;
        long double p_nk_x_K_x_YSumD = 0.0;

        tempX = ValX; tempY = ValY; tempZ = ValZ;
        gcrs_2_trs(tempX, tempY, tempZ);
        // now earth in Terra Ref System
        // it is possible to calculate H to get air drag
        if (--iAtm[iCurSat] == 0)
        {
            long double dlLAT, dlLON;
            iAtm[iCurSat] = iItearationsPerSec;//479; // onc per 1000 iteration == 1 per sec
            h[iCurSat] = H =GetH(tempX, tempY, tempZ, 6378245.000, 6356863.019,dlLAT,dlLON);
            ro[iCurSat] = Ro=GetDens(); // 15C
        }

        sinTetta =tempZ/ValR;

        XdivR =   tempX/ValR;
        YdivR =   tempY/ValR;
        XdivRval = XdivR;
        YdivRval = YdivR;

        SinTetta = sinTetta;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        n = 0;  //  initial

        long double Ptilda_m_2[TOTAL_COEF+3];
        long double Ptilda_m_1[TOTAL_COEF+3];
        long double Ptilda_[TOTAL_COEF+3];
        for (k = 0; k < TOTAL_COEF; k++) 
        {
            Ptilda_[k] = 0;  Ptilda_m_1[k] =0;  Ptilda_m_2[k]=0;
        }
        long double P_m_2 = 0;
        long double P_m_1 = 0;
        long double P_ = 1;
        Ptilda_[0]= P_;

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // next iteration by n
        n = 1;
        P_m_2 = P_m_1; P_m_1 = P_;
        memcpy(Ptilda_m_2,Ptilda_m_1, sizeof(Ptilda_m_2)); memcpy(Ptilda_m_1,Ptilda_, sizeof(Ptilda_m_1));
        //P_ = sinTetta;

#ifdef _NORMALIZED_COEF
        P_ = sinTetta*_SQRT3;
#else
        P_ = sinTetta;
#endif
        Ptilda_[0]= P_;

        //Ptilda_[1] = n * P_m_1 + sinTetta * Ptilda_m_1[1]; // P'[1]  k == '

        // P = sin => d(P)/d(sin) = 1
#ifdef _NORMALIZED_COEF
        Ptilda_[1] =  _SQRT3;
#else
        Ptilda_[1] =  1;
#endif

        long double R0divR_ = R0divR[1]*R0divR[1];
        int ip = 0;
        // loop iteration starts from n=2 k = 0
        // formula 8 on page 92
        long double Xk[TOTAL_COEF+3];
        long double Yk[TOTAL_COEF+3];
        
        Xk[0] = 1.0;
        Yk[0] = 0.0;
        Xk[1] = Xk[0]*XdivR - Yk[0]*YdivR;
        Yk[1] = Yk[0]*XdivR + Xk[0]*YdivR;
        for (k = 2; k <= iLeg; k++)
        {
            Xk[k] = Xk[k-1]*XdivR - Yk[k-1]*YdivR;
            Yk[k] = Yk[k-1]*XdivR + Xk[k-1]*YdivR;
        }

        //int iXkYk = 1;
        int nb = 2;
        int ne = iLeg;
        int kb = 0;
        for (n = nb; n <=ne; n++)
        {
            long double x[3],y[3],z[3];
#if _DEBUG
            // sanity check n:
            if (n != nk_lm_Numbers[ip][0])
                exit (1);
#endif
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // next iteration by n
            P_m_2 = P_m_1; P_m_1 = P_;
            memcpy(Ptilda_m_2,Ptilda_m_1, sizeof(Ptilda_m_2)); memcpy(Ptilda_m_1,Ptilda_, sizeof(Ptilda_m_1));
#ifdef _NORMALIZED_COEF
            P_ = _p_n_m_1[n] *sinTetta * P_m_1 - _p_n_m_2[n]*P_m_2;  // P[2]
#else
            P_ = ((2.0* n-1.0) *sinTetta * P_m_1 - (n-1)*P_m_2)/n;  // P[2]
#endif
            long double P_nk = P_;
            long double XSumD, YSumD;
            /////////////////////////////////////////////////////////////////////////////  k =================0
            k = 0;
            Ptilda_[k]= P_;

#if _DEBUG
            // sanity check k:
            if (k != nk_lm_Numbers[ip][1])
                exit (1);
#endif

            long double Ptilda_nk;
#ifdef _NORMALIZED_COEF
            if (2 == n) // k==0 & n == 2
                Ptilda_nk  = _tpk_n_k[n]*sinTetta;
            else
                Ptilda_nk  = _tp_nm1_k [n][k+1] * Ptilda_m_1[k+1]*sinTetta - _tp_nm2_k[n][k+1] * Ptilda_m_2[k+1];
            
#else
            //long double Ptilda_nk = n * P_m_1 + sinTetta * Ptilda_m_1[1];                        // P'[2]
            // this is equivalent, but better for iterations
            //long double Ptilda_nk  = (2*n-1) * Ptilda_m_1[k] + Ptilda_m_2[k+1];                      // P'[2]
            // this is equivalent
#ifdef _DO_NOT_SKIP_OBVIOUS
            if (2 == n) // k==0 & n == 2
                Ptilda_nk  = diagonal[n]*sinTetta;
            else
#endif
                Ptilda_nk  = ((2*n-1) * Ptilda_m_1[k+1]*sinTetta - (n + (k+1) -1)*Ptilda_m_2[k+1])/(n-(k+1));   // P'[2]
#endif
            Ptilda_[k+1] = Ptilda_nk; // store P'[2] for use 

            long double Qnk_ = C_S_nk[ip][0] * Xk[k] + C_S_nk[ip][1] * Yk[k];
            // on k=0 iteration!! i.e. n=2, k=0
            // Qnk = Cnk=0*Xk=0 +Snk=0*Yk=0
            // Xk=0 = 1; and Yk=0 = 0;
            // Qn0 = Cn0  => D_Qnk_Dxr =0; D_Qnk_Dyr=0
            //long double D_Qnk_Dxr_ = 0;
            //long double D_Qnk_Dyr_ = 0;
            // k is derivative

            // J case
            P_nk_x_Qnk_ = 0;       // sumv_n => sumgam_n
            Ptilda_nk_x_Qnk_ = 0;  // sumh_n
            P_nk_x_K_x_XSumD = 0;  // sumj_n
            P_nk_x_K_x_YSumD = 0;  // sumk_n

            if (ip == 0)
            {           //Sumgam_N := Pn[0]*Cn[O]*(n + 1)
                                                       // Sumh_N := Pn[1]* Cn[0];
                //_x20 = -(n+1) *XdivR    * P_nk * Qnk_  - Ptilda_nk *  Qnk_ * XdivR * SinTetta ;
                //_y20 = -(n+1) *YdivR    * P_nk * Qnk_  - Ptilda_nk *  Qnk_ * YdivR * SinTetta     ;
                //_z20 = -(n+1) *SinTetta * P_nk * Qnk_  +  Ptilda_nk *  Qnk_ * (1-SinTetta*SinTetta);
                P_20_x_Q20_ = P_nk * Qnk_;              // sumv_n => sumgam_n
#ifdef _NORMALIZED_COEF
                Ptilda_20_x_Qnk_ = _pt_nk[n][k] *Ptilda_nk *  Qnk_;   // sumh_n    (normalized == z[n][k] * Ptilda_nk *  Qnk_
#else
                Ptilda_20_x_Qnk_ = Ptilda_nk *  Qnk_;   // sumh_n 
#endif

            }
            else
            {
                //x = (-(n+1) *XdivR    * P_ * Qnk_ - Ptilda_nk *  Qnk_ * XdivR * SinTetta   );
                //y = (-(n+1) *YdivR    * P_ * Qnk_ - Ptilda_nk *  Qnk_ * YdivR * SinTetta   );
                //z = (-(n+1) *SinTetta * P_ * Qnk_ + Ptilda_nk *  Qnk_ * (1-SinTetta*SinTetta) );

                //x[0] = -(n+1) *XdivR    * P_nk * Qnk_;
                //y[0] = -(n+1) *YdivR    * P_nk * Qnk_;
                //z[0] = -(n+1) *SinTetta * P_nk * Qnk_;
                P_nk_x_Qnk_ += -(n+1) * P_nk * Qnk_;
                //x[1] = - Ptilda_nk *  Qnk_ * XdivR * SinTetta     ;
                //y[1] = - Ptilda_nk *  Qnk_ * YdivR * SinTetta     ;
                //z[1] =   Ptilda_nk *  Qnk_ * (1-SinTetta*SinTetta);
#ifdef _NORMALIZED_COEF
                Ptilda_nk_x_Qnk_ += - _pt_nk[n][k] *Ptilda_nk *  Qnk_;   // sumh_n    (normalized == z[n][k] * Ptilda_nk *  Qnk_
#else
                Ptilda_nk_x_Qnk_ += - Ptilda_nk *  Qnk_ ;
#endif
                //x[2] =0; y[2]=0;z[2]=0;
            }
            
            //////////////////////////////////////////////////////////////////////////   k ==================1
            // next iteration by k
            ip++;
            k = 1;
#if _DEBUG
            // sanity check k:
            if (k != nk_lm_Numbers[ip][1])
                exit (1);
#endif
            //if (iXkYk < k)
            //{
            //    Xk[k] = Xk[k-1]*XdivR - Yk[k-1]*YdivR;
            //    Yk[k] = Yk[k-1]*XdivR + Xk[k-1]*YdivR;
            //    iXkYk = k;
            //}
            Qnk_ = C_S_nk[ip][0] * Xk[k] + C_S_nk[ip][1] * Yk[k];  //Bnmtil := Cnm*ctll[M] + Snm*stil[M];
            XSumD = C_S_nk[ip][0] * Xk[k-1] + C_S_nk[ip][1] * Yk[k-1];
            YSumD = C_S_nk[ip][0] * Yk[k-1] - C_S_nk[ip][1] * Xk[k-1];
            //XkPrev = Xk; YkPrev = Yk;

            P_nk = Ptilda_[k]; // P'[2] == (k= 1)
#ifdef _NORMALIZED_COEF
            if (2 == n) // k==1 && n==2
                Ptilda_nk  = _p_n_k[n];// + Ptilda_m_2[k+1];
            else
                Ptilda_nk  = _tp_nm1_k [n][k+1] * Ptilda_m_1[k+1]*sinTetta - _tp_nm2_k[n][k+1] * Ptilda_m_2[k+1];
#else
            if (2 == n) // k==1 && n==2
            {
                //Ptilda_nk  = (2*n-1) * Ptilda_m_1[k];// + Ptilda_m_2[k+1];
                Ptilda_nk  = diagonal[n];
            }
#ifdef _DO_NOT_SKIP_OBVIOUS
            else if (3 == n) // k==1 && n == 3
            {
                Ptilda_nk  = diagonal[n]*sinTetta;
            }
#endif
            else
            {
                Ptilda_nk  = ((2*n-1) * Ptilda_m_1[k+1]*sinTetta - (n + (k+1) -1)*Ptilda_m_2[k+1])/(n-(k+1));
            }
#endif
            Ptilda_[k+1] = Ptilda_nk; // store P"[2] for next use
            //x += (-(n+1+1) *XdivR    * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * XdivR    * SinTetta     + P_nk * ( 1 *  XSumD   ));
            //y += (-(n+1+1) *YdivR    * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * YdivR    * SinTetta     + P_nk * ( 1 * -YSumD   ));
            //z += (-(n+1+1) *SinTetta * P_nk * Qnk_ + Ptilda_nk *  Qnk_ * (1- SinTetta * SinTetta));


            //x[0] += -(n+1+1) *XdivR    * P_nk * Qnk_;
            //y[0] += -(n+1+1) *YdivR    * P_nk * Qnk_;
            //z[0] += -(n+1+1) *SinTetta * P_nk * Qnk_;
            P_nk_x_Qnk_ += -(n+1+1) * P_nk * Qnk_;      // sumgam_n (normalized == n+k+10 P_nk * Qnk_)

            //x[1] +=  - Ptilda_nk *  Qnk_ * XdivR    * SinTetta ;
            //y[1] +=  - Ptilda_nk *  Qnk_ * YdivR    * SinTetta;
            //z[1] +=    Ptilda_nk *  Qnk_ * (1- SinTetta * SinTetta);

#ifdef _NORMALIZED_COEF
            Ptilda_nk_x_Qnk_ += - _pt_nk[n][k] *Ptilda_nk *  Qnk_;   // sumh_n    (normalized == z[n][k] * Ptilda_nk *  Qnk_
#else
            Ptilda_nk_x_Qnk_ += - Ptilda_nk *  Qnk_;   // sumh_n    (normalized == z[n][k] * Ptilda_nk *  Qnk_
#endif

            //x[2] += P_nk * ( 1 *  XSumD   );
            //y[2] += P_nk * ( 1 * -YSumD   );
            //z[2] += 0;
            P_nk_x_K_x_XSumD += P_nk * ( 1 *  XSumD   );   // sumj_n (normalized == k * P_nk * XSumD)
            P_nk_x_K_x_YSumD += P_nk * ( 1 * -YSumD   );   // sumk_n (normakized ==-k * P_nk * YSumD

            ////////////////////////////////////////////////////////////////////////////////////////
            for (k = 2; k <=n; k++)
            {
                ////////////////////////////////////////////////////////////////////////////////////////
                // next iteration == k ==2
                ip++;
#if _DEBUG
                // sanity check k:
                if (k != nk_lm_Numbers[ip][1])
                    exit (1);
#endif
                P_nk = Ptilda_[k];
                if (k==n)
                {
                    //Xk[k] = Xk[k-1]*XdivR - Yk[k-1]*YdivR;
                    //Yk[k] = Yk[k-1]*XdivR + Xk[k-1]*YdivR;
                    //iXkYk = k;
                    Ptilda_nk = 0;//(2*n-1) * Ptilda_m_1[k] + Ptilda_m_2[k+1];
                }
                else
                {
#ifdef _NORMALIZED_COEF
                    if (k == (n-1))
                        Ptilda_nk  = _p_n_k[n];
                    else if (k == (n-2))
                        Ptilda_nk  = _tpk_n_k[n]*sinTetta;// + Ptilda_m_2[k+1];
                    else
                        Ptilda_nk  = _tp_nm1_k [n][k+1] * Ptilda_m_1[k+1]*sinTetta - _tp_nm2_k[n][k+1] * Ptilda_m_2[k+1];
#else
                    if (k == (n-1))
                        Ptilda_nk = diagonal[n];// + Ptilda_m_2[k+1];
#ifdef _DO_NOT_SKIP_OBVIOUS
                    else if (k == (n-2))
                        Ptilda_nk = diagonal[n]*sinTetta;
#endif
                    else
                        Ptilda_nk  = ((2*n-1) * Ptilda_m_1[k+1]*sinTetta - (n + (k+1) -1)*Ptilda_m_2[k+1])/(n-(k+1));
#endif
                }
                Ptilda_[k+1] = Ptilda_nk; // store P'"[2] (third derivative) for next use

                Qnk_ = C_S_nk[ip][0] * Xk[k] + C_S_nk[ip][1] * Yk[k];
                XSumD = C_S_nk[ip][0] * Xk[k-1] + C_S_nk[ip][1] * Yk[k-1];
                YSumD = C_S_nk[ip][0] * Yk[k-1] - C_S_nk[ip][1] * Xk[k-1];

                //XkPrev = Xk; YkPrev = Yk;

                

                //x += (-(n+k+1) *XdivR    * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * XdivR    * SinTetta   + P_nk * ( k *  XSumD   ));
                //y += (-(n+k+1) *YdivR    * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * YdivR    * SinTetta   + P_nk * ( k * -YSumD   ));
                //z += (-(n+k+1) *SinTetta * P_nk * Qnk_ + Ptilda_nk *  Qnk_ * (1- SinTetta * SinTetta));


                //x[0] += -(n+k+1) *XdivR    * P_nk * Qnk_;
                //y[0] += -(n+k+1) *YdivR    * P_nk * Qnk_;
                //z[0] += -(n+k+1) *SinTetta * P_nk * Qnk_;
                P_nk_x_Qnk_ += -(n+k+1) * P_nk * Qnk_;

                //x[1] += - Ptilda_nk *  Qnk_ * XdivR    * SinTetta;
                //y[1] += - Ptilda_nk *  Qnk_ * YdivR    * SinTetta;
                //z[1] +=   Ptilda_nk *  Qnk_ * (1- SinTetta * SinTetta);
#ifdef _NORMALIZED_COEF
                Ptilda_nk_x_Qnk_ += - _pt_nk[n][k] *Ptilda_nk *  Qnk_;   // sumh_n    (normalized == z[n][k] * Ptilda_nk *  Qnk_
#else
                Ptilda_nk_x_Qnk_ += - Ptilda_nk *  Qnk_;
#endif

                //x[2] +=  P_nk * ( k *  XSumD   );
                //y[2] +=  P_nk * ( k * -YSumD   );
                //z[2] += 0;
                P_nk_x_K_x_XSumD += P_nk * ( k *  XSumD   );
                P_nk_x_K_x_YSumD += P_nk * ( k * -YSumD   );
            }
            p_nk_x_Qnk_      += P_nk_x_Qnk_*R0divR_;      // sumgam
            ptilda_nk_x_Qnk_ +=Ptilda_nk_x_Qnk_*R0divR_;  // sumh
            p_nk_x_K_x_XSumD +=P_nk_x_K_x_XSumD*R0divR_;  // sumj
            p_nk_x_K_x_YSumD +=P_nk_x_K_x_YSumD*R0divR_;  // sumk
            //_x[n][0] = x[0];_x[n][1] = x[1];_x[n][2] = x[2];
            //_y[n][0] = y[0];_y[n][1] = y[1];_y[n][2] = y[2];
            //_z[n][0] = z[0];_z[n][1] = z[1];_z[n][2] = z[2];
            R0divR[n] = R0divR_;


            //X += x* R0divR_; Y += y *R0divR_; Z += z * R0divR_;
            R0divR_*= R0divR[1];
            ////////////////////////////////////////////////////////////////////////////////////////
            // next iteration == k ==2
            ip++;
        }
        //for (n=2; n <= iLeg; n++)
        //{
        //    _x[n] *= R0divR[n]; _y[n] *= R0divR[n]; _z[n] *= R0divR[n];
        //}
        //for (n=iLeg; n >=2; n--)
        //{
        //    //X += (_x[n][0]+_x[n][1]+_x[n][2])*R0divR[n]; 
        //    //Y += (_y[n][0]+_y[n][1]+_y[n][2])*R0divR[n];
        //    //Z += (_z[n][0]+_z[n][1]+_z[n][2])*R0divR[n];
        //    X += (P_nk_x_Qnk_[n] * XdivR    + Ptilda_nk_x_Qnk_[n] * XdivR * SinTetta         + P_nk_x_K_x_XSumD[n] )*R0divR[n]; 
        //    Y += (P_nk_x_Qnk_[n] * YdivR    + Ptilda_nk_x_Qnk_[n] * YdivR * SinTetta         + P_nk_x_K_x_YSumD[n] )*R0divR[n];
        //    Z += (P_nk_x_Qnk_[n] * SinTetta - Ptilda_nk_x_Qnk_[n] * (1- SinTetta * SinTetta)                       )*R0divR[n];
        //}
        //for (n=iLeg; n >=2; n--)
        //for (n=2; n <=iLeg; n++)
        //{
        //    p_nk_x_Qnk_      += P_nk_x_Qnk_[n]*R0divR[n];
        //    ptilda_nk_x_Qnk_ +=Ptilda_nk_x_Qnk_[n]*R0divR[n];
        //    p_nk_x_K_x_XSumD +=P_nk_x_K_x_XSumD[n]*R0divR[n];
        //    p_nk_x_K_x_YSumD +=P_nk_x_K_x_YSumD[n]*R0divR[n];
        //}

        //    lambda = sumgam + ep*sumh    
        //        sumgam==-p_nk_x_Qnk_   sumh==-ptilda_nk_x_Qnk_
        //        sumj == p_nk_x_K_x_XSumD   sumk == p_nk_x_K_x_YSumD
        //    -(lambda * XdivR - sumj)  
        // =>   -sumgam   * XdivR          -sumh        * XdivR *  ep              + sumj 
#if 0
        Xadd = (p_nk_x_Qnk_ * XdivR    + ptilda_nk_x_Qnk_ * XdivR * SinTetta         + p_nk_x_K_x_XSumD ); 

        //    -(lamda * YdivR - sumk)
        //      -sumgam   * YdivR          -sumh        * YdivR *  ep              + sunk
        Yadd = (p_nk_x_Qnk_ * YdivR    + ptilda_nk_x_Qnk_ * YdivR * SinTetta         + p_nk_x_K_x_YSumD );
        //    lamda * SinTetta - sumh
        //     - simgam   * sintetta        -sumh       * SinTetta * SinTetta      + sumh
        Zadd = (p_nk_x_Qnk_ * SinTetta - ptilda_nk_x_Qnk_ * (1- SinTetta * SinTetta)                    );

        //X += _x20*R0divR[2];  Y += _y20*R0divR[2];  Z += _z20*R0divR[2];

        Xadd+= (-(2+1) *XdivR    * P_20_x_Q20_  - Ptilda_20_x_Qnk_ * XdivR * SinTetta)*R0divR[2] ;
        Yadd+= (-(2+1) *YdivR    * P_20_x_Q20_  - Ptilda_20_x_Qnk_ * YdivR * SinTetta)*R0divR[2]     ;
        Zadd+= (-(2+1) *SinTetta * P_20_x_Q20_  + Ptilda_20_x_Qnk_ * (1-SinTetta*SinTetta))*R0divR[2];
        X =1; Y= 1; Z =1;
        trs_2_gcrs(Xadd, Yadd, Zadd);
        //trs_2_gcrs(X, Y, Z);
#else
        // Xadd = (p_nk_x_Qnk_ * XdivR    + ptilda_nk_x_Qnk_ * XdivR * SinTetta         + p_nk_x_K_x_XSumD );
        // Yadd = (p_nk_x_Qnk_ * YdivR    + ptilda_nk_x_Qnk_ * YdivR * SinTetta         + p_nk_x_K_x_YSumD );
        // Zadd = (p_nk_x_Qnk_ * SinTetta - ptilda_nk_x_Qnk_ * (1- SinTetta * SinTetta)                    );
        // Zadd = (p_nk_x_Qnk_ * SinTetta + ptilda_nk_x_Qnk_ * SinTetta * SinTetta                         - ptilda_nk_x_Qnk_ );
        // xadd = XdivR *(p_nk_x_Qnk_ + ptilda_nk_x_Qnk_ * SinTetta      + p_nk_x_K_x_XSumD/XdivR); 
        // Yadd = YdivR *(p_nk_x_Qnk_ + ptilda_nk_x_Qnk_ * SinTetta      + p_nk_x_K_x_YSumD/YdivR );
        // Zadd = SinTetta *(p_nk_x_Qnk_  + ptilda_nk_x_Qnk_ * SinTetta  - ptilda_nk_x_Qnk_/SinTetta );

        // Xadd+= (-(2+1) *XdivR    * P_20_x_Q20_  - Ptilda_20_x_Qnk_ * XdivR * SinTetta)*R0divR[2] ;
        // Yadd+= (-(2+1) *YdivR    * P_20_x_Q20_  - Ptilda_20_x_Qnk_ * YdivR * SinTetta)*R0divR[2]     ;
        // Zadd+= (-(2+1) *SinTetta * P_20_x_Q20_  + Ptilda_20_x_Qnk_ * (1-SinTetta*SinTetta))*R0divR[2];
        // Xadd+= XdivR  * (-(2+1) * P_20_x_Q20_  - Ptilda_20_x_Qnk_ * SinTetta)*R0divR[2] ;
        // Yadd+= YdivR  * (-(2+1) * P_20_x_Q20_  - Ptilda_20_x_Qnk_ * SinTetta)*R0divR[2] ;
        // Zadd+= SinTetta*(-(2+1) * P_20_x_Q20_  - Ptilda_20_x_Qnk_ * SinTetta)  + Ptilda_20_x_Qnk_/SinTetta)*R0divR[2];
        {
            Xadd = (    + p_nk_x_K_x_XSumD ); 
            Yadd = (    + p_nk_x_K_x_YSumD );
            Zadd = (    - ptilda_nk_x_Qnk_ );
            //Xadd+= (  - Ptilda_20_x_Qnk_ * XdivR * SinTetta)*R0divR[2] ;
            //Yadd+= (  - Ptilda_20_x_Qnk_ * YdivR * SinTetta)*R0divR[2]     ;
            Zadd+= (  + Ptilda_20_x_Qnk_ * (1.0))*R0divR[2];

            //X =XdivR; Y= YdivR; Z =SinTetta;

            //trs_2_gcrs(X, Y, Z); // that will be original X0divR Y0divR Z0divR
             // prove :
            //X =1.1*XdivR;       Y= 1.1*YdivR; Z =1.1*SinTetta;

            //trs_2_gcrs(X, Y, Z);
            // such way reduce error

            X = (p_nk_x_Qnk_ + ptilda_nk_x_Qnk_ * SinTetta ) + (-(2+1) * P_20_x_Q20_ - Ptilda_20_x_Qnk_ * SinTetta)*R0divR[2] ; 
                           Y=X;            Z=X;
            X=1-X;         Y=1-Y;          Z=1-Z;
            Xadd = -Xadd;  Yadd = -Yadd;   Zadd = -Zadd;
            trs_2_gcrs(Xadd, Yadd, Zadd);
        }
#endif
    };
#endif
#else
    void FastSummXYZ( long double ValX, long double ValY, long double ValZ, long double ValR, long double &X, long double &Y, long double &Z, int iCurSat)
    {
        int n,k;
        long double tempX;
        long double tempY;
        long double tempZ;
        long double sinTetta, XdivR, YdivR;
        X = 0; Y = 0; Z = 0;
        long double _x[TOTAL_COEF];
        long double _y[TOTAL_COEF];
        long double _z[TOTAL_COEF];
        long double _x20,_y20,_z20;

        gcrs_2_trs(ValX, ValY, ValZ);
        tempX = ValX; tempY = ValY; tempZ = ValZ;
       // now earth in Terra Ref System
       // it is possible to calculate H to get air drag
       if (--iAtm[iCurSat] == 0)
       {
           long double dlLAT, dlLON;
           iAtm[iCurSat] = iItearationsPerSec;//479; // onc per 1000 iteration == 1 per sec
           h[iCurSat] = H =GetH(tempX, tempY, tempZ, 6378245.000, 6356863.019,dlLAT,dlLON);
           ro[iCurSat] = Ro=GetDens(); // 15C
       }

       sinTetta =ValZ/ValR;

        XdivR =   tempX/ValR;
        YdivR =   tempY/ValR;
        XdivRval = XdivR;
        YdivRval = YdivR;

        SinTetta = sinTetta;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        n = 0;  //  initial

        long double Ptilda_m_2[TOTAL_COEF];
        long double Ptilda_m_1[TOTAL_COEF];
        long double Ptilda_[TOTAL_COEF];
        for (k = 0; k < TOTAL_COEF; k++) 
        {
            Ptilda_[k] = 0;  Ptilda_m_1[k] =0;  Ptilda_m_2[k]=0;
        }
        long double P_m_2 = 0;
        long double P_m_1 = 0;
        long double P_ = 1;
        Ptilda_[0]= P_;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // next iteration by n
        n = 1;
        P_m_2 = P_m_1; P_m_1 = P_;
        memcpy(Ptilda_m_2,Ptilda_m_1, sizeof(Ptilda_m_2)); memcpy(Ptilda_m_1,Ptilda_, sizeof(Ptilda_m_1));
        //P_ = sinTetta;
        P_ = sinTetta;
        Ptilda_[0]= P_;

        //Ptilda_[1] = n * P_m_1 + sinTetta * Ptilda_m_1[1]; // P'[1]  k == '

        // P = sin => d(P)/d(sin) = 1
        Ptilda_[1] =  1;

        long double R0divR_ = R0divR[1]*R0divR[1];
        int ip = 0;
        // loop iteration starts from n=2 k = 0
        // formula 8 on page 92
        for (n = 2; n <=iLeg; n++)
        {
            long double x,y,z;
            x = 0;  y = 0;  z = 0;
            // sanity check n:
            if (n != nk_lm_Numbers[ip][0])
                exit (1);
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // next iteration by n
            P_m_2 = P_m_1; P_m_1 = P_;
            memcpy(Ptilda_m_2,Ptilda_m_1, sizeof(Ptilda_m_2)); memcpy(Ptilda_m_1,Ptilda_, sizeof(Ptilda_m_1));
            P_ = ((2.0* n-1.0) *sinTetta * P_m_1 - (n-1)*P_m_2)/n;  // P[2]
            Ptilda_[0]= P_;
            long double XkDxrPrev =0;
            long double XkDyrPrev =0;
            long double YkDxrPrev =0;
            long double YkDyrPrev =0;
            long double XkPrev =1;
            long double YkPrev =0;
            //long double XkDxr, XkDyr, YkDxr, YkDyr;
            long double XSumD, YSumD;
            long double Xk =1;
            long double Yk =0;
            /////////////////////////////////////////////////////////////////////////////  k =================0
            k = 0;
            // sanity check k:
            if (k != nk_lm_Numbers[ip][1])
                exit (1);

            long double Qnk_ = C_S_nk[ip][0] * Xk + C_S_nk[ip][1] * Yk;
            // on k=0 iteration!! i.e. n=2, k=0
            // Qnk = Cnk=0*Xk=0 +Snk=0*Yk=0
            // Xk=0 = 1; and Yk=0 = 0;
            // Qn0 = Cn0  => D_Qnk_Dxr =0; D_Qnk_Dyr=0
            //long double D_Qnk_Dxr_ = 0;
            //long double D_Qnk_Dyr_ = 0;
            // k is derivative
            long double Ptilda_nk = n * P_m_1 + sinTetta * Ptilda_m_1[1];                        // P'[2]
            Ptilda_[1] = Ptilda_nk; // store P'[2] for use 
            // J case
            if (ip == 0)
            {           //Sumgam_N := Pn[0]*Cn[O]*(n + 1)
                                                       // Sumh_N := Pn[1]* Cn[0];
                _x20 = (-(n+1) *XdivR    * P_ * Qnk_ - Ptilda_nk *  Qnk_ * XdivR * SinTetta     );
                _y20 = (-(n+1) *YdivR    * P_ * Qnk_ - Ptilda_nk *  Qnk_ * YdivR * SinTetta     );
                _z20 = (-(n+1) *SinTetta * P_ * Qnk_ + Ptilda_nk *  Qnk_ * (1-SinTetta*SinTetta));
            }
            else
            {
                x = (-(n+1) *XdivR    * P_ * Qnk_ - Ptilda_nk *  Qnk_ * XdivR * SinTetta   );
                y = (-(n+1) *YdivR    * P_ * Qnk_ - Ptilda_nk *  Qnk_ * YdivR * SinTetta   );
                z = (-(n+1) *SinTetta * P_ * Qnk_ + Ptilda_nk *  Qnk_ * (1-SinTetta*SinTetta) );

            }
            
            //////////////////////////////////////////////////////////////////////////   k ==================1
            // next iteration by k
            ip++;
            k = 1;
            // sanity check k:
            if (k != nk_lm_Numbers[ip][1])
                exit (1);
            Xk = XkPrev*XdivR - YkPrev*YdivR;
            Yk = YkPrev*XdivR + XkPrev*YdivR;
            Qnk_ = C_S_nk[ip][0] * Xk + C_S_nk[ip][1] * Yk;  //Bnmtil := Cnm*ctll[M] + Snm*stil[M];
            XSumD = C_S_nk[ip][0] * XkPrev + C_S_nk[ip][1] * YkPrev;
            YSumD = C_S_nk[ip][0] * YkPrev - C_S_nk[ip][1] * XkPrev;
            //XkDxr = XkDxrPrev*XdivR + XkPrev          - YkDxrPrev*YdivR; // only XkPrev and YkPrev in use => Sumj_N := Sumj_N + M*Pnm (Cnm*ctil[M-1] + Snm*stil[M-1]);   
            //XkDyr = XkDyrPrev*XdivR - YkDyrPrev*YdivR - YkPrev;          // only YlPrev and XkPrev in use => Sumk_N := Sumk_N - M*Pnm (Cnm*stil[M-1l - Snm*ctil[M-1]):
            //YkDxr = YkDxrPrev*XdivR + YkPrev          + XkDxrPrev*YdivR; 
            //YkDyr = YkDyrPrev*XdivR + XkDyrPrev*YdivR + XkPrev;
                                                                         // at the end multiplied Sumj := Sumj + Reorn * Sumj_N; and Sumk := Sumk + Reorn * Sumk_N
                                                                         // Cnk*(XkDxrPrev*XdivR + YkDxrPrev*XdivR - YkDxrPrev*YdivR + XkDxrPrev*YdivR)
                                                                         // Snk*(XkDyrPrev*XdivR + YkDyrPrev*XdivR - YkDyrPrev*YdivR + XkDyrPrev*YdivR)
                                                                         // Cnk*((XkDxrPrev+YkDxrPrev)*XdivR + (- YkDxrPrev + XkDxrPrev)*YdivR)
                                                                         // Snk*((XkDyrPrev+YkDyrPrev)*XdivR + (- YkDyrPrev + XkDyrPrev)*YdivR)
                                                                         // somehow comes to Qnk_ * k = ((XkDxrPrev*XdivR*XdivR  - YkDxrPrev*YdivR*XdivR + XkDyrPrev*XdivR* YdivR - YkDyrPrev*YdivR* YdivR ))*C_S_nk[ip][0]+((YkDxrPrev*XdivR*XdivR  + XkDxrPrev*YdivR*XdivR + YkDyrPrev*XdivR* YdivR + XkDyrPrev*YdivR* YdivR ))*C_S_nk[ip][1]
            //D(Qnk)/D(x/r) * D(x/r)/D(y) + D(Qnk)/D(y/r)
            //D_Qnk_Dxr_ = C_S_nk[ip][0]*XkDxr + C_S_nk[ip][1]*YkDxr;
            //D_Qnk_Dyr_ = C_S_nk[ip][0]*XkDyr + C_S_nk[ip][1]*YkDyr;
            //XkDxrPrev =XkDxr; XkDyrPrev =XkDyr; YkDxrPrev =YkDxr; YkDyrPrev =YkDyr;
            XkPrev = Xk; YkPrev = Yk;

            long double P_nk = Ptilda_[1]; // P'[2] == (k= 1)
            //Ptilda_nk  = n * Ptilda_[1] + sinTetta * Ptilda_m_1[2]; // P"[2] 
            Ptilda_nk  = (2*n-1) * Ptilda_m_1[1] + Ptilda_m_2[2];
            Ptilda_[2] = Ptilda_nk; // store P"[2] for next use
                  
                  // Sumgam_N := Sumgam_N + (N + m + 1) * Pnm * Bnmtil;
                                                   // Sumh_N += Pn(m+l)*Bnmtil;
            x += (-(n+1+1) *XdivR    * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * XdivR    * SinTetta     + P_nk * ( 1 *  XSumD   ));
            y += (-(n+1+1) *YdivR    * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * YdivR    * SinTetta     + P_nk * ( 1 * -YSumD   ));
            z += (-(n+1+1) *SinTetta * P_nk * Qnk_ + Ptilda_nk *  Qnk_ * (1- SinTetta * SinTetta));
                                                                                                  //  (-(C_S_nk[ip][0]*XkDxr + C_S_nk[ip][1]*YkDxr)*XdivR*SinTetta +
                                                                                                  //                                    - (C_S_nk[ip][0]*XkDyr + C_S_nk[ip][1]*YkDyr) * YdivR*SinTetta)
                                                                                                  //  (-(C_S_nk[ip][0]*(+ XkPrev*XdivR*SinTetta - YkPrev* YdivR*SinTetta ) + C_S_nk[ip][0]*((XkDxrPrev*XdivR*XdivR*SinTetta  - YkDxrPrev*YdivR*XdivR*SinTetta + XkDyrPrev*XdivR* YdivR*SinTetta - YkDyrPrev*YdivR* YdivR*SinTetta )) + 
                                                                                                  //     C_S_nk[ip][1]*(+ YkPrev*XdivR*SinTetta + XkPrev* YdivR*SinTetta ) + C_S_nk[ip][1]*((YkDxrPrev*XdivR*XdivR*SinTetta  + XkDxrPrev*YdivR*XdivR*SinTetta + YkDyrPrev*XdivR* YdivR*SinTetta + XkDyrPrev*YdivR* YdivR*SinTetta )))
                                                                                                  //  (-((C_S_nk[ip][0]*XkPrev*XdivR*SinTetta      + C_S_nk[ip][1] *YkPrev*XdivR*SinTetta)  + C_S_nk[ip][0]*((XkDxrPrev*XdivR*XdivR*SinTetta  - YkDxrPrev*YdivR*XdivR*SinTetta + XkDyrPrev*XdivR* YdivR*SinTetta - YkDyrPrev*YdivR* YdivR*SinTetta )) + 
                                                                                                  //     (C_S_nk[ip][0]*(- YkPrev* YdivR*SinTetta) + C_S_nk[ip][1] *XkPrev* YdivR*SinTetta) + C_S_nk[ip][1]*((YkDxrPrev*XdivR*XdivR*SinTetta  + XkDxrPrev*YdivR*XdivR*SinTetta + YkDyrPrev*XdivR* YdivR*SinTetta + XkDyrPrev*YdivR* YdivR*SinTetta )))

            ////////////////////////////////////////////////////////////////////////////////////////
            for (k = 2; k <=n; k++)
            {
                ////////////////////////////////////////////////////////////////////////////////////////
                // next iteration == k ==2
                ip++;

                // sanity check k:
                if (k != nk_lm_Numbers[ip][1])
                    exit (1);
                Xk = XkPrev*XdivR - YkPrev*YdivR;
                Yk = YkPrev*XdivR + XkPrev*YdivR;
                Qnk_ = C_S_nk[ip][0] * Xk + C_S_nk[ip][1] * Yk;
                XSumD = C_S_nk[ip][0] * XkPrev + C_S_nk[ip][1] * YkPrev;
                YSumD = C_S_nk[ip][0] * YkPrev - C_S_nk[ip][1] * XkPrev;

                //XkDxr = XkDxrPrev*XdivR + XkPrev          - YkDxrPrev*YdivR;
                //XkDyr = XkDyrPrev*XdivR - YkDyrPrev*YdivR - YkPrev;
                //YkDxr = YkDxrPrev*XdivR + YkPrev          + XkDxrPrev*YdivR;
                //YkDyr = YkDyrPrev*XdivR + XkDyrPrev*YdivR + XkPrev;

                //D(Qnk)/D(x/r) * D(x/r)/D(y) + D(Qnk)/D(y/r)
                //D_Qnk_Dxr_ = C_S_nk[ip][0]*XkDxr + C_S_nk[ip][1]*YkDxr;
                //D_Qnk_Dyr_ = C_S_nk[ip][0]*XkDyr + C_S_nk[ip][1]*YkDyr;
                //XkDxrPrev =XkDxr; XkDyrPrev =XkDyr; YkDxrPrev =YkDxr; YkDyrPrev =YkDyr;
                XkPrev = Xk; YkPrev = Yk;

                P_nk = Ptilda_[k];
                Ptilda_nk = (2*n-1) * Ptilda_m_1[k] + Ptilda_m_2[k+1];
                Ptilda_[k+1] = Ptilda_nk; // store P'"[2] (third derivative) for next use
                x += (-(n+k+1) *XdivR    * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * XdivR    * SinTetta   + P_nk * ( k *  XSumD   ));
                y += (-(n+k+1) *YdivR    * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * YdivR    * SinTetta   + P_nk * ( k * -YSumD   ));
                z += (-(n+k+1) *SinTetta * P_nk * Qnk_ + Ptilda_nk *  Qnk_ * (1- SinTetta * SinTetta));
                
            }
            _x[n] = x;_y[n] = y;_z[n] = z;
            R0divR[n] = R0divR_;

            //X += x* R0divR_; Y += y *R0divR_; Z += z * R0divR_;
            R0divR_*= R0divR[1];
            ////////////////////////////////////////////////////////////////////////////////////////
            // next iteration == k ==2
            ip++;
        }
        for (n=2; n <= iLeg; n++)
        {
            _x[n] *= R0divR[n]; _y[n] *= R0divR[n]; _z[n] *= R0divR[n];
        }
        for (n=iLeg; n >=2; n--)
        {
            X += _x[n]; Y += _y[n]; Z += _z[n];
        }
        X += _x20*R0divR[2];  Y += _y20*R0divR[2];  Z += _z20*R0divR[2];

        trs_2_gcrs(X, Y, Z);
    };
#endif
#else
    void FastSummXYZ( long double ValX, long double ValY, long double ValZ, long double ValR, long double &X, long double &Y, long double &Z, int iCurSat)
    {
        int n,k;
        long double tempX;
        long double tempY;
        long double sinTetta, XdivR, YdivR, tempValX, tempValY;
        X = 0; Y = 0; Z = 0;
        long double _x[TOTAL_COEF];
        long double _y[TOTAL_COEF];
        long double _z[TOTAL_COEF];
        long double _x20,_y20,_z20;

#if 0
            tempX = cos(Lambda) * ValX - sin(Lambda) * ValY;
            tempY = sin(Lambda) * ValX + cos(Lambda) * ValY;
#else
            tempX = cos(Lambda) * ValX + sin(Lambda) * ValY;
            tempY = -sin(Lambda) * ValX + cos(Lambda) * ValY;

#endif
        sinTetta =ValZ/ValR;

        XdivR =   tempX/ValR;
        YdivR =   tempY/ValR;
        XdivRval = XdivR;
        YdivRval = YdivR;

        SinTetta = sinTetta;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        n = 0;  //  initial

        long double Ptilda_m_2[TOTAL_COEF];
        long double Ptilda_m_1[TOTAL_COEF];
        long double Ptilda_[TOTAL_COEF];
        for (k = 0; k < TOTAL_COEF; k++) 
        {
            Ptilda_[k] = 0;  Ptilda_m_1[k] =0;  Ptilda_m_2[k]=0;
        }
        long double P_m_2 = 0;
        long double P_m_1 = 0;
        long double P_ = 1;
        Ptilda_[0]= P_;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // next iteration by n
        n = 1;
        P_m_2 = P_m_1; P_m_1 = P_;
        memcpy(Ptilda_m_2,Ptilda_m_1, sizeof(Ptilda_m_2)); memcpy(Ptilda_m_1,Ptilda_, sizeof(Ptilda_m_1));
        //P_ = sinTetta;
        P_ = sinTetta;
        Ptilda_[0]= P_;

        //Ptilda_[1] = n * P_m_1 + sinTetta * Ptilda_m_1[1]; // P'[1]  k == '

        // P = sin => d(P)/d(sin) = 1
        Ptilda_[1] =  1;

        long double R0divR_ = R0divR[1]*R0divR[1];
        int ip = 0;
        // loop iteration starts from n=2 k = 0
        // formula 8 on page 92
        for (n = 2; n <=iLeg; n++)
        {
            long double x,y,z;
            x = 0;  y = 0;  z = 0;
            // sanity check n:
            if (n != nk_lm_Numbers[ip][0])
                exit (1);
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // next iteration by n
            P_m_2 = P_m_1; P_m_1 = P_;
            memcpy(Ptilda_m_2,Ptilda_m_1, sizeof(Ptilda_m_2)); memcpy(Ptilda_m_1,Ptilda_, sizeof(Ptilda_m_1));
            P_ = ((2.0* n-1.0) *sinTetta * P_m_1 - (n-1)*P_m_2)/n;  // P[2]
            Ptilda_[0]= P_;
            long double XkDxrPrev =0;
            long double XkDyrPrev =0;
            long double YkDxrPrev =0;
            long double YkDyrPrev =0;
            long double XkPrev =1;
            long double YkPrev =0;
            long double XkDxr, XkDyr, YkDxr, YkDyr;
            long double Xk =1;
            long double Yk =0;
            /////////////////////////////////////////////////////////////////////////////  k =================0
            k = 0;
            // sanity check k:
            if (k != nk_lm_Numbers[ip][1])
                exit (1);

            long double Qnk_ = C_S_nk[ip][0] * Xk + C_S_nk[ip][1] * Yk;
            // on k=0 iteration!! i.e. n=2, k=0
            // Qnk = Cnk=0*Xk=0 +Snk=0*Yk=0
            // Xk=0 = 1; and Yk=0 = 0;
            // Qn0 = Cn0  => D_Qnk_Dxr =0; D_Qnk_Dyr=0
            long double D_Qnk_Dxr_ = 0;
            long double D_Qnk_Dyr_ = 0;
            // k is derivative
            long double Ptilda_nk = n * P_m_1 + sinTetta * Ptilda_m_1[1];                        // P'[2]
            Ptilda_[1] = Ptilda_nk; // store P'[2] for use 
            // J case
            if (ip == 0)
            {           //Sumgam_N := Pn[0]*Cn[O]*(n + 1)
                                                       // Sumh_N := Pn[1]* Cn[0];
                _x20 = (-(n+1) *XdivRval * P_ * Qnk_ - Ptilda_nk *  Qnk_ * XdivRval * SinTetta   + P_ * ( D_Qnk_Dxr_*(1-XdivRval*XdivRval)- D_Qnk_Dyr_ * YdivRval*XdivRval     ));
                _y20 = (-(n+1) *YdivRval * P_ * Qnk_ - Ptilda_nk *  Qnk_ * YdivRval * SinTetta   + P_ * (-D_Qnk_Dxr_*XdivRval*YdivRval    + D_Qnk_Dyr_ * (1-YdivRval*YdivRval) ));
                _z20 = (-(n+1) *SinTetta * P_ * Qnk_ + Ptilda_nk *  Qnk_ * (1-SinTetta*SinTetta) + P_ * (-D_Qnk_Dxr_*XdivRval*SinTetta    - D_Qnk_Dyr_ * YdivRval*SinTetta     ));
            }
            else
            {
                x = (-(n+1) *XdivRval * P_ * Qnk_ - Ptilda_nk *  Qnk_ * XdivRval * SinTetta   + P_ * ( D_Qnk_Dxr_*(1-XdivRval*XdivRval)- D_Qnk_Dyr_ * YdivRval*XdivRval     ));
                y = (-(n+1) *YdivRval * P_ * Qnk_ - Ptilda_nk *  Qnk_ * YdivRval * SinTetta   + P_ * (-D_Qnk_Dxr_*XdivRval*YdivRval    + D_Qnk_Dyr_ * (1-YdivRval*YdivRval) ));
                z = (-(n+1) *SinTetta * P_ * Qnk_ + Ptilda_nk *  Qnk_ * (1-SinTetta*SinTetta) + P_ * (-D_Qnk_Dxr_*XdivRval*SinTetta    - D_Qnk_Dyr_ * YdivRval*SinTetta     ));

            }
            
            //////////////////////////////////////////////////////////////////////////   k ==================1
            // next iteration by k
            ip++;
            k = 1;
            // sanity check k:
            if (k != nk_lm_Numbers[ip][1])
                exit (1);
            Xk = XkPrev*XdivR - YkPrev*YdivR;
            Yk = YkPrev*XdivR + XkPrev*YdivR;
            Qnk_ = C_S_nk[ip][0] * Xk + C_S_nk[ip][1] * Yk;  //Bnmtil := Cnm*ctll[M] + Snm*stil[M];
            XkDxr = XkDxrPrev*XdivR + XkPrev          - YkDxrPrev*YdivR; // only XkPrev and YkPrev in use => Sumj_N := Sumj_N + M*Pnm (Cnm*ctil[M-1] + Snm*stil[M-1]);   
            XkDyr = XkDyrPrev*XdivR - YkDyrPrev*YdivR - YkPrev;          // only YlPrev and XkPrev in use => Sumk_N := Sumk_N - M*Pnm (Cnm*stil[M-1l - Snm*ctil[M-1]):
            YkDxr = YkDxrPrev*XdivR + YkPrev          + XkDxrPrev*YdivR; 
            YkDyr = YkDyrPrev*XdivR + XkDyrPrev*YdivR + XkPrev;
                                                                         // at the end multiplied Sumj := Sumj + Reorn * Sumj_N; and Sumk := Sumk + Reorn * Sumk_N
                                                                         // Cnk*(XkDxrPrev*XdivR + YkDxrPrev*XdivR - YkDxrPrev*YdivR + XkDxrPrev*YdivR)
                                                                         // Snk*(XkDyrPrev*XdivR + YkDyrPrev*XdivR - YkDyrPrev*YdivR + XkDyrPrev*YdivR)
                                                                         // Cnk*((XkDxrPrev+YkDxrPrev)*XdivR + (- YkDxrPrev + XkDxrPrev)*YdivR)
                                                                         // Snk*((XkDyrPrev+YkDyrPrev)*XdivR + (- YkDyrPrev + XkDyrPrev)*YdivR)
                                                                         // somehow comes to Qnk_ * k = ((XkDxrPrev*XdivR*XdivR  - YkDxrPrev*YdivR*XdivR + XkDyrPrev*XdivR* YdivR - YkDyrPrev*YdivR* YdivR ))*C_S_nk[ip][0]+((YkDxrPrev*XdivR*XdivR  + XkDxrPrev*YdivR*XdivR + YkDyrPrev*XdivR* YdivR + XkDyrPrev*YdivR* YdivR ))*C_S_nk[ip][1]
            //D(Qnk)/D(x/r) * D(x/r)/D(y) + D(Qnk)/D(y/r)
            D_Qnk_Dxr_ = C_S_nk[ip][0]*XkDxr + C_S_nk[ip][1]*YkDxr;
            D_Qnk_Dyr_ = C_S_nk[ip][0]*XkDyr + C_S_nk[ip][1]*YkDyr;
            XkDxrPrev =XkDxr; XkDyrPrev =XkDyr; YkDxrPrev =YkDxr; YkDyrPrev =YkDyr;
            XkPrev = Xk; YkPrev = Yk;

            long double P_nk = Ptilda_[1]; // P'[2] == (k= 1)
            //Ptilda_nk  = n * Ptilda_[1] + sinTetta * Ptilda_m_1[2]; // P"[2] 
            Ptilda_nk  = (2*n-1) * Ptilda_m_1[1] + Ptilda_m_2[2];
            Ptilda_[2] = Ptilda_nk; // store P"[2] for next use
                  
                  // Sumgam_N := Sumgam_N + (N + m + 1) * Pnm * Bnmtil;
                                                   // Sumh_N += Pn(m+l)*Bnmtil;
            x += (-(n+1) *XdivRval * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * XdivRval * SinTetta   + P_nk * ( D_Qnk_Dxr_*(1-XdivRval*XdivRval)- D_Qnk_Dyr_ * YdivRval*XdivRval     ));
            y += (-(n+1) *YdivRval * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * YdivRval * SinTetta   + P_nk * (-D_Qnk_Dxr_*XdivRval*YdivRval    + D_Qnk_Dyr_ * (1-YdivRval*YdivRval) ));
            z += (-(n+1) *SinTetta * P_nk * Qnk_ + Ptilda_nk *  Qnk_ * (1-SinTetta*SinTetta) + P_nk * (-D_Qnk_Dxr_*XdivRval*SinTetta    - D_Qnk_Dyr_ * YdivRval*SinTetta     ));
                                                                                                  //  (-(C_S_nk[ip][0]*XkDxr + C_S_nk[ip][1]*YkDxr)*XdivR*SinTetta +
                                                                                                  //                                    - (C_S_nk[ip][0]*XkDyr + C_S_nk[ip][1]*YkDyr) * YdivR*SinTetta)
                                                                                                  //  (-(C_S_nk[ip][0]*(+ XkPrev*XdivR*SinTetta - YkPrev* YdivR*SinTetta ) + C_S_nk[ip][0]*((XkDxrPrev*XdivR*XdivR*SinTetta  - YkDxrPrev*YdivR*XdivR*SinTetta + XkDyrPrev*XdivR* YdivR*SinTetta - YkDyrPrev*YdivR* YdivR*SinTetta )) + 
                                                                                                  //     C_S_nk[ip][1]*(+ YkPrev*XdivR*SinTetta + XkPrev* YdivR*SinTetta ) + C_S_nk[ip][1]*((YkDxrPrev*XdivR*XdivR*SinTetta  + XkDxrPrev*YdivR*XdivR*SinTetta + YkDyrPrev*XdivR* YdivR*SinTetta + XkDyrPrev*YdivR* YdivR*SinTetta )))
                                                                                                  //  (-((C_S_nk[ip][0]*XkPrev*XdivR*SinTetta      + C_S_nk[ip][1] *YkPrev*XdivR*SinTetta)  + C_S_nk[ip][0]*((XkDxrPrev*XdivR*XdivR*SinTetta  - YkDxrPrev*YdivR*XdivR*SinTetta + XkDyrPrev*XdivR* YdivR*SinTetta - YkDyrPrev*YdivR* YdivR*SinTetta )) + 
                                                                                                  //     (C_S_nk[ip][0]*(- YkPrev* YdivR*SinTetta) + C_S_nk[ip][1] *XkPrev* YdivR*SinTetta) + C_S_nk[ip][1]*((YkDxrPrev*XdivR*XdivR*SinTetta  + XkDxrPrev*YdivR*XdivR*SinTetta + YkDyrPrev*XdivR* YdivR*SinTetta + XkDyrPrev*YdivR* YdivR*SinTetta )))

            ////////////////////////////////////////////////////////////////////////////////////////
            for (k = 2; k <=n; k++)
            {
                ////////////////////////////////////////////////////////////////////////////////////////
                // next iteration == k ==2
                ip++;

                // sanity check k:
                if (k != nk_lm_Numbers[ip][1])
                    exit (1);
                Xk = XkPrev*XdivR - YkPrev*YdivR;
                Yk = YkPrev*XdivR + XkPrev*YdivR;
                Qnk_ = C_S_nk[ip][0] * Xk + C_S_nk[ip][1] * Yk;
                XkDxr = XkDxrPrev*XdivR + XkPrev          - YkDxrPrev*YdivR;
                XkDyr = XkDyrPrev*XdivR - YkDyrPrev*YdivR - YkPrev;
                YkDxr = YkDxrPrev*XdivR + YkPrev          + XkDxrPrev*YdivR;
                YkDyr = YkDyrPrev*XdivR + XkDyrPrev*YdivR + XkPrev;

                //D(Qnk)/D(x/r) * D(x/r)/D(y) + D(Qnk)/D(y/r)
                D_Qnk_Dxr_ = C_S_nk[ip][0]*XkDxr + C_S_nk[ip][1]*YkDxr;
                D_Qnk_Dyr_ = C_S_nk[ip][0]*XkDyr + C_S_nk[ip][1]*YkDyr;
                XkDxrPrev =XkDxr; XkDyrPrev =XkDyr; YkDxrPrev =YkDxr; YkDyrPrev =YkDyr;
                XkPrev = Xk; YkPrev = Yk;

                P_nk = Ptilda_[k];
                Ptilda_nk = (2*n-1) * Ptilda_m_1[k] + Ptilda_m_2[k+1];
                Ptilda_[k+1] = Ptilda_nk; // store P'"[2] (third derivative) for next use
                x += (-(n+1) *XdivRval * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * XdivRval * SinTetta   + P_nk * ( D_Qnk_Dxr_*(1-XdivRval*XdivRval)- D_Qnk_Dyr_ * YdivRval*XdivRval     ));
                y += (-(n+1) *YdivRval * P_nk * Qnk_ - Ptilda_nk *  Qnk_ * YdivRval * SinTetta   + P_nk * (-D_Qnk_Dxr_*XdivRval*YdivRval    + D_Qnk_Dyr_ * (1-YdivRval*YdivRval) ));
                z += (-(n+1) *SinTetta * P_nk * Qnk_ + Ptilda_nk *  Qnk_ * (1-SinTetta*SinTetta) + P_nk * (-D_Qnk_Dxr_*XdivRval*SinTetta    - D_Qnk_Dyr_ * YdivRval*SinTetta     ));
                // on last (z) P_nk * Qnk_ * k == - P_nk * (-D_Qnk_Dxr_*XdivRval*SinTetta    - D_Qnk_Dyr_ * YdivRval*SinTetta     )
                
            }
            _x[n] = x;_y[n] = y;_z[n] = z;
            R0divR[n] = R0divR_;

            //X += x* R0divR_; Y += y *R0divR_; Z += z * R0divR_;
            R0divR_*= R0divR[1];
            ////////////////////////////////////////////////////////////////////////////////////////
            // next iteration == k ==2
            ip++;
        }
        for (n=2; n <= iLeg; n++)
        {
            _x[n] *= R0divR[n]; _y[n] *= R0divR[n]; _z[n] *= R0divR[n];
        }
        for (n=iLeg; n >=2; n--)
        {
            X += _x[n]; Y += _y[n]; Z += _z[n];
        }
        X += _x20*R0divR[2];  Y += _y20*R0divR[2];  Z += _z20*R0divR[2];
#if 0
        tempX = cos(-Lambda) * X - sin(-Lambda) * Y;
        tempY = sin(-Lambda) * X + cos(-Lambda) * Y;
#else
        tempX = cos(-Lambda) * X + sin(-Lambda) * Y;
        tempY = -sin(-Lambda) * X + cos(-Lambda) * Y;
#endif
        X = tempX;
        Y = tempY;

    };
#endif    
#ifdef ALL_OLD_CODE
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    int CalcP( long double ValX, long double ValY, long double ValZ, long double ValR)
    {
        int n,k;
        long double tempX;
        long double tempY;
        long double sinTetta, XdivR, YdivR;
        // Lambda                               // 0 - 143 2 - 165 4 - 049
        //Lambda =  -Lambda -M_PI/2;            // 0 - 162 2 - 152 4 - 101
        //Lambda =  Lambda -M_PI/2;//           // 0 - 164 2 - 143 4 - 147
        //Lambda = -Lambda +M_PI;               // 0 - 082 2 - 106 4 - 048
        //Lambda =  Lambda -3*M_PI/2;           // 0 - 052 2 - 059 4 - 149 5 - 038 6 - 103
        //Lambda = -Lambda +M_PI/2;             // 0 - 047 2 - 149 4 - 159
        //Lambda =  Lambda +M_PI/2;             // 0 - 052 2 - 059 4 - 149
        //Lambda = - Lambda;                    // 0 - 161 2 - 134 4 - 161
        //Lambda = - Lambda + M_PI; // 0 min - 082 2 - 059 4 - 149
        //Lambda =0 ;
        //Lambda = 0.1;
        //Lambda = 0.2;
        //Lambda = 0.3;
        //Lambda = 0.4;
        //Lambda = 0.5;
        //Lambda = 0.6;
        //Lambda = 0.7;
        //Lambda = 0.8;
        //Lambda = 0.9;
        //Lambda = 1.0;
        //Lambda = 1.1;
        //Lambda = 1.2;
        //Lambda = 1.3;
        //Lambda = 1.4;
        //Lambda = 1.5;
        //Lambda = 1.6;
        //Lambda = 1.7;
        //Lambda = 1.8;
        //Lambda = 1.9;
        //Lambda = 2.0;
        //Lambda = 2.08;
        //Lambda = 2.1;
        //Lambda = 2.2;
        //Lambda = 2.3;
        //Lambda = 2.4;
        //Lambda = 2.45;
        //Lambda = 2.5;
        //Lambda = 2.6;
        //Lambda = 2.7;
        //Lambda = 2.8;
        //Lambda = 2.9;
        //Lambda = 3.0;
        //Lambda = 3.1;
        //Lambda = 3.2;
        //Lambda = 3.3;
        //Lambda = 3.4;
        //Lambda = 3.5;
        // Lambda = 3.6;
        //Lambda = 3.7;
        //Lambda = 3.8;
        //Lambda = 3.9;
        //Lambda = 4.0;
        //Lambda = 4.1;
        //Lambda = 4.2;
        //Lambda = 4.3;
        //Lambda = 4.4;
        //Lambda = 4.5;
        //Lambda = 4.6;
        //Lambda = 4.7;
        //Lambda = 4.8;
        //Lambda = 4.9;
        //Lambda = 5.0;
        //Lambda = 5.1;
        //Lambda = 5.2;
        //Lambda = 5.3;
        //Lambda = 5.4;
        //Lambda = 5.5; 
        //Lambda = 5.6;  
        //Lambda = 5.7;     
        //Lambda = 5.8;
        //Lambda = 5.9; 
        //Lambda = 6.0;
        //Lambda = 6.1;
        //Lambda = 6.2;

         {
            //tempX = cos(Lambda) * XdivR - sin(Lambda) * YdivR;
            //tempY = sin(Lambda) * XdivR + cos(Lambda) * YdivR;
            //XdivR = tempX;YdivR = tempY;
#if 0
            tempX = cos(Lambda) * ValX - sin(Lambda) * ValY;
            tempY = sin(Lambda) * ValX + cos(Lambda) * ValY;
#else
            tempX = cos(Lambda) * ValX + sin(Lambda) * ValY;
            tempY = -sin(Lambda) * ValX + cos(Lambda) * ValY;

#endif
            //ValX = tempX;
            //ValY = tempY;

            sinTetta =ValZ/ValR;
            //sinTetta =sqrt(tempX*tempX+ tempY*tempY)/ValR;
            XdivR =   tempX/ValR;
            YdivR =   tempY/ValR;

        }

        XdivRval = XdivR;
        YdivRval = YdivR;
#ifdef ALL_OLD_CODE
        SinTetta = sinTetta;
#endif
#define CPV 0.0000005
#if 0
        if ((XdivRval > -CPV) && (XdivRval < CPV))
            return 1;
        if ((YdivRval > -CPV) && (YdivRval < CPV))
            return 2;
#endif
#define _ACCOUNT_SIN

#ifndef _ACCOUNT_SIN
        if ((sinTetta > -CPV) && (sinTetta < CPV))
            return 3;
#endif


#if 0
        // power of a cos
        OneMinusSinTettaInSquare = 1.0 - sinTetta*sinTetta;
        OneMinusXdivRInSquare =    1.0 - XdivR * XdivR;
        OneMinusYdivRInSquare =    1.0 - YdivR * YdivR;
#endif

        //OneMinusSinTettaInSquare2 = (ValR*ValR - ValZ*ValZ)/(ValR*ValZ);
        //OneMinusXdivRInSquare2 =    (ValR*ValR - tempX*tempX)/(ValR*tempX);
        //OneMinusYdivRInSquare2 =    (ValR*ValR - tempY*tempY)/(ValR*tempY);

        // clean all array
        //for (n = 0; n<=iLeg+1;n++)
        //{
        //    for (k=0; k <=iLeg+1;k++)
        //    {
        //        Pnk_tilda[n][k] = 0;
        //    }
        //}
        // legandr functions from sinTetta
        P[0] = 1.0;
//#define CPV 0.0000005

        P[1] = sinTetta;
        Pnk_tilda[0][0] = P[0];
        Pnk_tilda[1][0] = P[1];
        for (n = 2; n <=iLeg; n++)
        {
            // page 90- formula 8
            // (n + 1)Pn+1(z) - (2n + 1)zPn(z) + nPn-1(z) = 0 =>
            // (n + 1)Pn+1(z) = (2n + 1)zPn(z) - nPn-1(z) =>
            // Pn+1(z) = ((2n + 1)zPn(z) - nPn-1(z))/(n + 1) =>
            // or Pn(z) = ((2(n-1) + 1)zPn-1(z) - (n-1)Pn-2(z))/(n-1 + 1)
            // or Pn(z) = ((2n-1)  zPn-1(z) - (n-1)Pn-2(z))/n
            

            //P[n] = ((2.0* (n-1) +1) *sinTetta * P[n-1] - (n-1)*P[n-2])/((n-1)+1);
            P[n] = ((2.0* n-1.0) *sinTetta * P[n-1] - (n-1)*P[n-2])/n;
            Pnk_tilda[n][0] = P[n];
            //break;
            //}
        }
        // derivetiveas from legandr fucntions
        Ptilda[0] = 0; // P0 was constant == P0' == 0
#if 1
        Ptilda[1] = 1;//sqrt(ValX*ValX + ValY*ValY)/ValR;; // P1 was a X == P1' == 1

        Pnk_tilda[0][1] = Ptilda[0];
        Pnk_tilda[1][1] = Ptilda[1];
        for (n=2;n<=iLeg;n++)
        {   // all derivatives
            // for P2' == 2* P1 + sin(tetta) * 1
            Ptilda[n] = n * P[n-1] + sinTetta * Ptilda[n-1];
            Pnk_tilda[n][1] = Ptilda[n];
        }
#else
        Pnk_tilda[0][1] = Ptilda[0];
        for (n=1;n<=iLeg;n++)
        {   // all derivatives
            // for P2' == 2* P1 + sin(tetta) * 1
            Ptilda[n] = n * P[n-1] + sinTetta * Ptilda[n-1];
            Pnk_tilda[n][1] = Ptilda[n];
        }

#endif
        Pnk_tilda[0][2] = 0;
        Pnk_tilda[1][2] = 0;
        for (k= 3;k <=iLeg+1;k++)
        {
            Pnk_tilda[0][k] = 0;
            Pnk_tilda[1][k] =0;
        }
        // derivatives for dK(Pn(sinTetta))/d(sinTetta)**K
        for (n= 2;n <=iLeg;n++)
        {
            for (k = 2; k<=n+1;k++)
            {
                Pnk_tilda[n][k] = (2*n-1) * Pnk_tilda[n-1][k-1] + Pnk_tilda[n-2][k];
            }
        }
        //for (n= 2;n <=iLeg;n++)
        //{
        //    for (k = 1; k<=iLeg;k++)
        //    {
        //        //Pnk[n][k] = pow((1 - X*X),k/2)*Pnk_tilda[n][k];
        //        Pnk[n][k] = CosTetta[k]*Pnk_tilda[n][k];
        //    }
        //}
        //if (iLeg_longit) // this is case when need to acount Longitude
        // last formula on page 92
#if 0
        Xk[0] = 1; Yk[0] =0; 
        Xk[1] = XdivR; Yk[1] = YdivR;
        for (k = 2; k<=(iLeg+1); k++)
        {
            Xk[k] = Xk[k-1]*XdivR - Yk[k-1] * YdivR;
            Yk[k] = Yk[k-1]*XdivR + Xk[k-1] * YdivR;
        }
        XkDxr[0] = 0; XkDyr[0] = 0; YkDxr[0] = 0; YkDyr[0] = 0;
        for (k = 1; k <=iLeg+1; k++)
        {
            XkDxr[k] = XkDxr[k-1]*XdivR + Xk[k-1]          - YkDxr[k-1]*YdivR;
            XkDyr[k] = XkDyr[k-1]*XdivR - YkDyr[k-1]*YdivR - Yk[k-1];
            YkDxr[k] = YkDxr[k-1]*XdivR + Yk[k-1]          + XkDxr[k-1]*YdivR;
            YkDyr[k] = YkDyr[k-1]*XdivR + XkDyr[k-1]*YdivR + Xk[k-1];
        }
        {
            // formula 8 on page 92
             for (n = 2; n <=iLeg+1; n++)
             {
                 for (k = 0; k <=iLeg+1; k++)
                 {
                     Qnk[n][k] = CNK[n][k] * Xk[k] + SNK[n][k] * Yk[k];
                     D_Qnk_Dxr[n][k] = CNK[n][k]*XkDxr[k] + SNK[n][k]*YkDxr[k];
                     D_Qnk_Dyr[n][k] = CNK[n][k]*XkDyr[k] + SNK[n][k]*YkDyr[k];
                 }
             }
        }
#else
        // formula 8 on page 92
        for (n = 2; n <=iLeg; n++)
        {
            long double XkDxrPrev =0;
            long double XkDyrPrev =0;
            long double YkDxrPrev =0;
            long double YkDyrPrev =0;
            long double XkPrev =1;
            long double YkPrev =0;
            long double XkDxr, XkDyr, YkDxr, YkDyr;
            long double Xk =1;
            long double Yk =0;

            Qnk[n][0] = CNK[n][0] * Xk + SNK[n][0] * Yk;
            // on k=0 iteration!! i.e. n=2, k=0
            // Qnk = Cnk=0*Xk=0 +Snk=0*Yk=0
            // Xk=0 = 1; and Yk=0 = 0;
            // Qn0 = Cn0  => D_Qnk_Dxr =0; D_Qnk_Dyr=0


            D_Qnk_Dxr[n][0] = 0;
            D_Qnk_Dyr[n][0] = 0;
            //XkDxr = XkDxrPrev*XdivR + XkPrev          - YkDxrPrev*YdivR;
            //XkDyr = XkDyrPrev*XdivR - YkDyrPrev*YdivR - YkPrev;
            //YkDxr = YkDxrPrev*XdivR + YkPrev          + XkDxrPrev*YdivR;
            //YkDyr = YkDyrPrev*XdivR + XkDyrPrev*YdivR + XkPrev;

            //D_Qnk_Dxr[n][0] = CNK[n][k]*XkDxr + SNK[n][k]*YkDxr;
            //D_Qnk_Dyr[n][0] = CNK[n][k]*XkDyr + SNK[n][k]*YkDyr;
            for (k = 1; k <=n; k++)
            {
                Xk = XkPrev*XdivR - YkPrev*YdivR;
                Yk = YkPrev*XdivR + XkPrev*YdivR;
                Qnk[n][k] = CNK[n][k] * Xk + SNK[n][k] * Yk;
                XkDxr = XkDxrPrev*XdivR + XkPrev          - YkDxrPrev*YdivR;
                XkDyr = XkDyrPrev*XdivR - YkDyrPrev*YdivR - YkPrev;
                YkDxr = YkDxrPrev*XdivR + YkPrev          + XkDxrPrev*YdivR;
                YkDyr = YkDyrPrev*XdivR + XkDyrPrev*YdivR + XkPrev;

                //D(Qnk)/D(x/r) * D(x/r)/D(y) + D(Qnk)/D(y/r)
                D_Qnk_Dxr[n][k] = CNK[n][k]*XkDxr + SNK[n][k]*YkDxr;
                D_Qnk_Dyr[n][k] = CNK[n][k]*XkDyr + SNK[n][k]*YkDyr;
                XkDxrPrev =XkDxr; XkDyrPrev =XkDyr; YkDxrPrev =YkDxr; YkDyrPrev =YkDyr;
                XkPrev = Xk; YkPrev = Yk;
            }
        }
#endif
        return 0;
    };

    void SummXYZ(int SatCalc, long double &X, long double &Y, long double &Z)
    {
        int n,k;
        X=0; Y=0; Z=0;
        /*
        for (n= 2;n <=iLeg;n++)
        {
            // implementation of derivetive (page 91 on Aksenov lectures)
            // Potential Unk:
            // Unk = fm/r (r0/r)**n Pnk(sinTetta) [Cnk*cos(k*lambda) + Snk*sin(k*lambda)
            // then Unk separated into 3 parts:
            // (1) Rn(1/r) = fm/r *(r0/r)**n         => Rn(1/r)' = (n+1) * fm * r0**n * (1/r)**n = (n+1) * fm * (r0/r)**n
            //
            //  on a page 12 is (kaind hard to write formulas in C code)
            // Pnk(sinTetta) = (1-sinTetta**2) ** k/2 * dk (Pn(sinTetta))/ d(sinTetta)**k ==
            //   cosTetta **k * dK(Pn(sinTetta))/ d(sinTtta)**k
            // now cosTetta**k separated from Pnk(sinTetta) and a second part is:
            // (2) Znk(z/r) = dK(Pn(sinTetta)/ d(sinTetta)**k == Pnk_tetta[n][k]  => Znk(z/r)' = Pnk_tilda[n][k+1]
            // also (2) for K == 0 is:
            // Zn0 = Pn(sinTetta)
            // and cosTetta goes to a last part:
            // (3) Qnk(x/r,y/r) = cosTetta**k * [Cnk*cos(k*lambda) + Snk * sin(k*lambda)] ==
            // [Cnk*cosTetta**k * cos(k*lambda) + Snk * cosTetta**k * sin(k*lambda)] =
            // [Cnk* Xk + Snk*Yk] and 
            // Xk = (cosTetta)**k * cos(k*Lambda) 
            // Yk = (costetta)**k * sin(k*Lambda)
            // or recurcevly:
            // X0 =1, Y0 = 0
            // X1 = cosTeatta * Cos(Lambda) = x/r; Y1 = cosTetta * sin(Lambda) = y/r
            // X[k+1] = Xk * x/r - Yk* y/r  Y[k+1] = Yk* x/r  + Xk * y/r
            //  
            // X2 = X1 * x/r - Y1 * y/r       = (x/r)**2 - (y/r)**2;
            // Y2 = Y1 *x/r + X1 *y/r         = y/r * x/r + x/r* y/r = 2 (y/r) * (x/r)
            //
            // Q20 = C20 (constant) => D(Q20)/D(x/r) = 0 ; D(Q20)/ D (y/r) = 0
            // Q21 = C21 * (x/r) + S21 (y/r) => 
            //       D(Q21)/D(x/r) = C21; 
            //       D(Q21)/D(y/r) = S21
            // Q22 = C22 * [(x/r)*(x/r) - (y/r)*(y/r)] + S22 * [2*x/r*y/r] 
            //       D(Q22)/D(x/r) = 2 * C22 * x/r + 2 * S22 * y/r = 2*[C22*x/r + S22*y/r]
            //       D(Q22)/D(y/r) =-2 * C22 * y/r + 2 * S22 * x/r = 2*[C22*y/r + S22*x/r]
            // Q30 = C30 (constant) => D(Q30)/D(x/r) = 0; D(Q30)/D(y/r) = 0;
            // Q31 = C31 * (x/r) + S31 (y/r) => 
            //       D(Q31)/D(x/r) = C31; 
            //       D(Q31)/D(y/r) = S31
            // Q32 = C32 * [(x/r)*(x/r) - (y/r)*(y/r)] + S32 * [2*x/r*y/r] 
            //       D(Q32)/D(x/r) = 2 * C32 * x/r + 2 * S32 * y/r = 2*[C22*x/r + S22*y/r]
            //       D(Q32)/D(y/r) =-2 * C32 * y/r + 2 * S32 * x/r = 2*[C22*y/r + S22*x/r]
            // Q33 = C33 * [(x/r)*(x/r) - (y/r)*(y/r)] + S33 * [2*x/r*y/r] 
            //       D(Q32)/D(x/r) = 2 * C32 * x/r + 2 * S32 * y/r = 2*[C22*x/r + S22*y/r]
            //       D(Q32)/D(y/r) =-2 * C32 * y/r + 2 * S32 * x/r = 2*[C22*y/r + S22*x/r]
            // chastnie proizvodnie (simbol D) :
            // D(Unk)/D(x) = d(Rn) / d(1/r)    * D(1/r)/D(x)    * Znk    * Qnk +
            //                 Rn * d(Znk)/d(z/r) * D(z/r)/D(x) * Qnk +
            //                 Rn * Znk * [D(Qnk)/D(x/r) * D(x/r)/D(x) + D(Qnk)/D(y/r)*D(y/r)/D(x)]
            //            = (n+1)* fm * (r0/r)**n * (-x/r**3) * Znk * Qnk +
            //              Rn * d(K+1)(Pn(sinTetta)/d(sintetta)**(k+1) * (-x*z/r**3) * Qnk +
            //              Rn * Znk * [D(Qnk)/D(x/r) * (1/r - x**2/r**3) + D(Qnk)/D(y/r)*(-x*y/r**3)]
            //
            //            = (n+1)* fm * (r0/r)**n * (-x/r**3) * Znk * Qnk +
            //              Rn * d(K+1)(Pn(sinTetta)/d(sintetta)**(k+1) * (-x*z/r**3) * Qnk +
            //              Rn * Znk * [(Cnk*D(Xk)/D(x/r)+Snk*D(Yk)/D(x/r)) * (1/r - x**2/r**3) + (Cnk*D(Xk)/D(y/r)+Snk*D(Yk)/D(y/r))*(-x*y/r**3)]
            // as a result for example n=2 and k = 0
            // D(U20)/D(X) = (2+1)* fm * (r0/r)**2 * (-x/r**3) * d(P2(sinTetta))/d(sinTetta) * J2 +
            //              fm * r0**2 * (1/r)**3 * d(0+1)(P2(sinTetta)/d(sintetta)**(0+1) *(-x*z/r**3) * J2 +
            //              fm * r0**2 * (1/r)**3 * d(Pn(sinTetta))/d(sinTetta) * [D(Q20)/D(x/r) * (1/r - x**2/r**3) + D(Q20)/D(y/r)*(-x*y/r**3)]
            //            = - 3 * fm * (ro/r)**2 * (x/r**3) * Pnk_tilda[2][0] * J2 
            //              -     fm * (r0/r)**2 * (1/r) * Pnk_tilda[2][1] * x*z/r**3 *J2 
            //                    fm * (r0/r)**2 * (1/r) Pnk_tilda[2][0] * [0*(1/r-x**2/r**3) + 0*(-x*y/r**3)]

            //X += -(n+1) * R0divR[n] * Pnk_tilda[n][0] * Qnk[n][0]//CNK[n][0] 
            //     - R0divR[n] * SinTetta[1] * Pnk_tilda[n][1] * Qnk[n][0];//CNK[n][0]; 
            X += -(n+1) * R0divR[n] * Pnk_tilda[n][0] * Qnk[n][0]
                 - R0divR[n] * SinTetta[1] * Pnk_tilda[n][1] * Qnk[n][0]
                 ;

            // D(Unk)/D(y) = d(Rn) / d(1/r)    * D(1/r)/D(y)    * Znk    * Qnk +
            //                 Rn * d(Znk)/d(z/r) * D(z/r)/D(y) * Qnk +
            //                 Rn * Znk * [D(Qnk)/D(x/r) * D(x/r)/D(y) + D(Qnk)/D(y/r)*D(y/r)/D(y)]
            //            = (n+1)* fm * (r0/r)**n * (-y/r**3) * Znk * Qnk +
            //              Rn * d(K+1)(Pn(sinTetta)/d(sintetta)**(k+1) * (-y*z/r**3) * Qnk +
            //              Rn * Znk * [D(Qnk)/D(x/r) * (- x*y/r**3) + D(Qnk)/D(y/r)*(1/r-y**2/r**3)]
            //            = (n+1)* fm * (r0/r)**n * (-y/r**3) * Znk * Qnk +
            //              Rn * d(K+1)(Pn(sinTetta)/d(sintetta)**(k+1) * (-y*z/r**3) * Qnk +
            //              Rn * Znk * [(Cnk*D(Xk)/D(x/r)+Snk*DYk)/D(x/r)) * (- x*y/r**3) + (Cnk*D(Xk)/D(y/r)+Snk*DYk)/D(y/r))*(1/r-y**2/r**3)]
            // as a result for example n=2 and k = 0
            // D(U20)/D(X) = (2+1)* fm * (r0/r)**2 * (-y/r**3) * d(P2(sinTetta))/d(sinTetta) * J2 +
            //              fm * r0**2 * (1/r)**3 * d(0+1)(P2(sinTetta)/d(sintetta)**(0+1) * (-y*z/r**3) * J2 +
            //              fm * r0**2 * (1/r)**3 * d(Pn(sinTetta))/d(sinTetta) * [D(Q20)/D(x/r) * ( - x*y/r**3) + D(Q20)/D(y/r)*(1/r-y**2/r**3)]
            //            = - 3 * fm * (ro/r)**2 * (y/r**3) * Pnk_tilda[2][0] * J2 
            //              -     fm * (r0/r)**2 * (1/r) * Pnk_tilda[2][1] * y*z/r**3 *J2 
            //                    fm * (r0/r)**2 * (1/r) Pnk_tilda[2][0] * [0*(-x*y/r**3) + 0*(1/r-y**2/r**3)]
            //Y += -(n+1) * R0divR[n] * Pnk_tilda[n][0] * Qnk[n][0]
            //     - R0divR[n] * SinTetta[1] * Pnk_tilda[n][1] * Qnk[n][0];//CNK[n][0]; 
            Y += -(n+1) * R0divR[n] * Pnk_tilda[n][0] * Qnk[n][0]
                 - R0divR[n] * SinTetta[1] * Pnk_tilda[n][1] * Qnk[n][0]
            ;

            // Rn = fm /r * (r0/r)**n
            // Znk =   d(K)  (Pn(sintetta))/d(sintetta)**(k)
            // Znk+1 = d(K+1)(Pn(sinTetta)/d(sintetta)**(k+1)

            // D(Unk)/D(z) = d(Rn) / d(1/r)    * D(1/r)/D(z)    * Znk    * Qnk +
            //                 Rn * d(Znk)/d(z/r) * D(z/r)/D(z) * Qnk +
            //                 Rn * Znk * [D(Qnk)/D(x/r) * D(x/r)/D(z) + D(Qnk)/D(y/r)*D(y/r)/D(z)]
            //            = (n+1)* fm * (r0/r)**n * (-z/r**3) * Znk * Qnk +
            //                     fm  * (r0/r)**n *1/r * d(K+1)(Pn(sinTetta)/d(sintetta)**(k+1) * (1/r-z**2/r**3) * Qnk +
            //                     fm  * (r0/r)**n *1//r * Znk * [D(Qnk)/D(x/r) * (- x*z/r**3) + D(Qnk)/D(y/r)*(-y*z/r**3)]
            //            = (n+1)* fm/r**2  * (r0/r)**n * (-z/r) * Znk * Qnk +
            //                     fm  * (r0/r)**n *1/r * d(K+1)(Pn(sinTetta)/d(sintetta)**(k+1) * 1/r* (1-z**2/r**2) * Qnk +
            //                     fm  * (r0/r)**n *1/r * Znk * 1/r * [(Cnk*D(Xk)/D(x/r)+Snk*DYk)/D(x/r)) * (- x*z/r**2) + (Cnk*D(Xk)/D(y/r)+Snk*DYk)/D(y/r))*(-y*z/r**2)]
            //            = (n+1)* fm/r**2  * (r0/r)**n * (-z/r) * Znk * Qnk +
            //                     fm/r**2  * (r0/r)**n * Znk+1 * (1-(z/r)**2) * Qnk +
            //                     fm/r**2  * (r0/r)**n * Znk * [(Cnk*D(Xk)/D(x/r)+Snk*DYk)/D(x/r)) * (- x/r * z/r) + (Cnk*D(Xk)/D(y/r)+Snk*DYk)/D(y/r))*(-y/r *z/r)]
            //            = fm/r**2  * (r0/r)**n ( (n+1)  * (-z/r) * Znk * Qnk +
            //                                     Znk+1 * (1-(z/r)**2) * Qnk +
            //                                     Znk * [(Cnk*D(Xk)/D(x/r)+Snk*DYk)/D(x/r)) * (- x/r * z/r) + (Cnk*D(Xk)/D(y/r)+Snk*DYk)/D(y/r))*(-y/r *z/r)]

            //Z += -(n+1) * R0divR[n] * Pnk_tilda[n][0] * Qnk[n][0] 
            //+ R0divR[n] * CosTetta[2]/ SinTetta[1] * Pnk_tilda[n][1] * Qnk[n][0];//CNK[n][0]; 
            Z += -(n+1) * R0divR[n] * Pnk_tilda[n][0] * Qnk[n][0]
            + R0divR[n] * CosTetta[2]/ SinTetta[1] * Pnk_tilda[n][1] * Qnk[n][0]
            ;
        }
        // second round
        */
        for (n= 2;n <=iLeg;n++)
        {
            // k=0 already done
            for (k = 0; k<=n; k++)
            {
                // D(Unk)/D(x) = d(Rn) / d(1/r)    * D(1/r)/D(x)    * Znk    * Qnk +
                //                 Rn * d(Znk)/d(z/r) * D(z/r)/D(x) * Qnk +
                //                 Rn * Znk * [D(Qnk)/D(x/r) * D(x/r)/D(x) + D(Qnk)/D(y/r)*D(y/r)/D(x)]

                //            = fm */r D((r0/r)**n)/D(1/r) * D(1/r)/D(x) * Znk * Qnk +
                //              fm/r (r0/r)**n * D(K+1)(Pn(sinTetta)/D(sintetta) * D(Z/r)/D(x) * Qnk +
                //              fm/r (r0/r)**n * Znk * [ (Cnk*D(Xk)/D(x/r)+Snk*D(Yk)/D(x/r)) * D(x/r)/D(x) + (Cnk*D(Xk)/D(y/r)+Snk*D(Yk)/D(y/r)) *D(y/r)/D(x) ]

                //            = fm * r0**n * (n+1)* (1/r)**n * (-x/r**3) * Znk * Qnk +
                //              fm/r (r0/r)**n * d(K+1)(Pn(sinTetta)/d(sintetta)**(k+1) * 1/r *(-x*z/r**2) * Qnk +
                //              fm/r (r0/r)**n * Znk * [(Cnk*D(Xk)/D(x/r)+Snk*D(Yk)/D(x/r)) * (1/r - x**2/r**3) + (Cnk*D(Xk)/D(y/r)+Snk*DYk)/D(y/r))*(-x*y/r**3)]

                //            = fm /r**2   *   -(n+1) * (r0/r)**n * x/r    Znk * Qnk +
                //              fm /r**2  *(r0/r)**n *   d(K+1)(Pn(sinTetta)/d(sintetta)        * -x/r * z/r *    Qnk +
                //              fm/r (r0/r)**n * Znk * 1/r * [(Cnk*XkDxr+Snk*YkDxr) * (1 - x**2/r**2) + (Cnk*XkDyr+Snk*YkDyr)*(-x*y/r**2)]

                //            = fm /r**2   * (r0/r)**n [  -(n+1) * Znk * Qnk x/r +
                //                                           Znk+1        * -x/r * SinTetta *    Qnk +
                //                                             Znk * ((Cnk*XkDxr+Snk*YkDxr) * (1 - (x/r)**2) + (Cnk*XkDyr+Snk*YkDyr)*(-x/r * y/r))
#if 0
                long double tempVal;
#if 1
                if (((XdivRval > CPV ) || (XdivRval < -CPV )))// && (((k+n)&1) == 1))
                {
#endif
                    //OneMinusXdivRInSquare_XdivRval[SatCalc][n][k] = tempVal = R0divR[n] * Pnk_tilda[n][k]*(D_Qnk_Dxr[n][k]*OneMinusXdivRInSquare2- D_Qnk_Dyr[n][k]*YdivRval);// (CNK[n][k]*XkDxr[k] + SNK[n][k]*YkDxr[k]) * OneMinusXdivRInSquare2;///XdivRval;
                    OneMinusXdivRInSquare_XdivRval[SatCalc][n][k] = tempVal = (R0divR[n] * Pnk_tilda[n][k]*(D_Qnk_Dxr[n][k]*(1-XdivRval*XdivRval)- D_Qnk_Dyr[n][k]*YdivRval*XdivRval))/XdivRval;
                    OldXSign[SatCalc][n][k] = XdivRval;
#if 1
                }
                else
                {
                    
                    if (((XdivRval >0) && (OldXSign[SatCalc][n][k] < 0)) || ((XdivRval <0) && (OldXSign[SatCalc][n][k] > 0)))
                    {
                        OneMinusXdivRInSquare_XdivRval[SatCalc][n][k] = tempVal = -OneMinusXdivRInSquare_XdivRval[SatCalc][n][k];
                        OldXSign[SatCalc][n][k] = - OldXSign[SatCalc][n][k];
                    }
                    else
                        tempVal = OneMinusXdivRInSquare_XdivRval[SatCalc][n][k];
                    //tempVal = (R0divR[n] * Pnk_tilda[n][k]*(D_Qnk_Dxr[n][k]*(1-XdivRval*XdivRval)- D_Qnk_Dyr[n][k]*YdivRval*XdivRval))/XdivRval;
                    //if ((OldXSign[SatCalc][n][k]/XdivRval) > 4)
                    {
                        printf("zero x ");
                    }
                        
                    //tempVal = OneMinusXdivRInSquare_XdivRval[SatCalc][n][k] * (OldXSign[SatCalc][n][k]/XdivRval);
                }
#endif
#endif
#if 0
                    X += R0divR[n] *
                                  (-(n+1)  /**XdivRval*/ *  Pnk_tilda[n][k] * Qnk[n][k]
                                   - Pnk_tilda[n][k+1] *  Qnk[n][k] /** XdivRval*/ * SinTetta
                                   //+ Pnk_tilda[n][k] * (/*(CNK[n][k]*XkDxr[k] + SNK[n][k]*YkDxr[k]) * OneMinusXdivRInSquare/XdivRval*/ //OneMinusXdivRInSquare_XdivRval[SatCalc][n][k]
                                   //                     - D_Qnk_Dyr[n][k]*YdivRval)//(CNK[n][k]*XkDyr[k] + SNK[n][k]*YkDyr[k])/**XdivRval*/*YdivRval)
                                                        
                                  )/*/XdivRval*/
                                  +tempVal
                    ;
#else
                    X += R0divR[n] *
                                  (-(n+1)  *XdivRval *  Pnk_tilda[n][k] * Qnk[n][k]
                                   - Pnk_tilda[n][k+1] *  Qnk[n][k] * XdivRval * SinTetta
                                   + Pnk_tilda[n][k]*(D_Qnk_Dxr[n][k]*(1-XdivRval*XdivRval)- D_Qnk_Dyr[n][k]*YdivRval*XdivRval)
                                   //+ Pnk_tilda[n][k] * (/*(CNK[n][k]*XkDxr[k] + SNK[n][k]*YkDxr[k]) * OneMinusXdivRInSquare/XdivRval*/ //OneMinusXdivRInSquare_XdivRval[SatCalc][n][k]
                                   //                     - D_Qnk_Dyr[n][k]*YdivRval)//(CNK[n][k]*XkDyr[k] + SNK[n][k]*YkDyr[k])/**XdivRval*/*YdivRval)
                                                        
                                  )/*/XdivRval*/

                    ;
#endif

                // D(Unk)/D(y) = d(Rn) / d(1/r)    * D(1/r)/D(y)    * Znk    * Qnk +
                //                 Rn * d(Znk)/d(z/r) * D(z/r)/D(y) * Qnk +
                //                 Rn * Znk * [D(Qnk)/D(x/r) * D(x/r)/D(y) + D(Qnk)/D(y/r)*D(y/r)/D(y)]

                //             = fm/r D((r0/r)**n)/D(1/r) * D(1/r)/D(y) * Znk * Qnk +
                //               fm/r (r0/r)**n * D(K+1)(Pn(sinTetta)/D(sintetta) * D(Z/r)/D(y) * Qnk +
                //               fm/r (r0/r)**n * Znk * [ (Cnk*D(Xk)/D(x/r)+Snk*D(Yk)/D(x/r)) * D(x/r)/D(y) + (Cnk*D(Xk)/D(y/r)+Snk*D(Yk)/D(y/r)) *D(y/r)/D(y) ]

                //            =  fm * r0**n * (n+1)* (1/r)**n * (-y/r**3) * Znk * Qnk +
                //              fm/r (r0/r)**n * Znk+1 * (-y*z/r**3) * Qnk +
                //              fm/r (r0/r)**n * Znk * [(Cnk*D(Xk)/D(x/r)+Snk*D(Yk)/D(x/r)) * (-xy/r**3) + (Cnk*D(Xk)/D(y/r)+Snk*D(Yk)/D(y/r))*(1/r-y**2/r**3)]

                //            = fm /r**2   * (r0/r)**n [  -(n+1) * Znk * *y/r * Qnk +
                //                                           Znk+1       * y/r * -SinTetta *    Qnk +
                //                                             Znk * ((Cnk*XkDxr+Snk*YkDxr) * (-x/r * y/r) + (Cnk*XkDyr+Snk*YkDyr)*(1-(y/r)**2))
#if 0
#if 1
                    if (((YdivRval > CPV ) || (YdivRval < -CPV )))// && (((k+n)&1) == 1))
                    {
#endif
                        //OneMinusYdivRInSquare_YdivRval[SatCalc][n][k] = tempVal= R0divR[n] *Pnk_tilda[n][k]*(-D_Qnk_Dxr[n][k]*XdivRval+D_Qnk_Dyr[n][k] * OneMinusYdivRInSquare2);//(CNK[n][k]*XkDyr[k] + SNK[n][k]*YkDyr[k])*OneMinusYdivRInSquare2;///YdivRval;
                        OneMinusYdivRInSquare_YdivRval[SatCalc][n][k] = tempVal= (R0divR[n] *Pnk_tilda[n][k]*(-D_Qnk_Dxr[n][k]*XdivRval*YdivRval +D_Qnk_Dyr[n][k] * (1-YdivRval*YdivRval)))/YdivRval;
                        OldYSign[SatCalc][n][k] = YdivRval;
#if 1
                    }
                    else
                    {
                        if (((YdivRval >0) && (OldYSign[SatCalc][n][k] < 0)) || ((YdivRval <0) && (OldYSign[SatCalc][n][k] > 0)))
                        {
                            OneMinusYdivRInSquare_YdivRval[SatCalc][n][k] = tempVal= - OneMinusYdivRInSquare_YdivRval[SatCalc][n][k];
                            OldYSign[SatCalc][n][k] = -OldYSign[SatCalc][n][k];
                        }
                        else
                            tempVal= OneMinusYdivRInSquare_YdivRval[SatCalc][n][k];
                        //tempVal= (R0divR[n] *Pnk_tilda[n][k]*(-D_Qnk_Dxr[n][k]*XdivRval*YdivRval +D_Qnk_Dyr[n][k] * (1-YdivRval*YdivRval)))/YdivRval;
                        //if ((OldYSign[SatCalc][n][k]/YdivRval)>4)
                            printf("zero y ");
                        //tempVal = OneMinusYdivRInSquare_YdivRval[SatCalc][n][k] * (OldYSign[SatCalc][n][k]/YdivRval);
                    }
#endif
#endif
#if 0
                    Y += R0divR[n] *
                                  (-(n+1) /**YdivRval*/ * Pnk_tilda[n][k] * Qnk[n][k]
                                     - Pnk_tilda[n][k+1] *  Qnk[n][k] /** YdivRval*/ * SinTetta
                                     //+ Pnk_tilda[n][k] * (-D_Qnk_Dxr[n][k]*XdivRval// + //(CNK[n][k]*XkDxr[k] + SNK[n][k]*YkDxr[k]) * XdivRval /**YdivRval*/ + 
                                         /*(CNK[n][k]*XkDyr[k] + SNK[n][k]*YkDyr[k])*OneMinusYdivRInSquare/YdivRval*/ //OneMinusYdivRInSquare_YdivRval[SatCalc][n][k]
                                     
                                     )/*/YdivRval*/
                            + tempVal
                    ;
#else
                    Y += R0divR[n] *
                                  (-(n+1) *YdivRval * Pnk_tilda[n][k] * Qnk[n][k]
                                     - Pnk_tilda[n][k+1] *  Qnk[n][k] * YdivRval * SinTetta
                                     + Pnk_tilda[n][k]*(-D_Qnk_Dxr[n][k]*XdivRval*YdivRval +D_Qnk_Dyr[n][k] * (1-YdivRval*YdivRval))
                                     
                                     )
                    ;

#endif
               
            //            = fm/r**2  * (r0/r)**n ( (n+1)  * (-z/r) * Znk * Qnk +
            //                                     Znk+1 * (1-(z/r)**2) * Qnk +
            //                                     Znk * [(Cnk*D(Xk)/D(x/r)+Snk*DYk)/D(x/r)) * (- x/r * z/r) + (Cnk*D(Xk)/D(y/r)+Snk*DYk)/D(y/r))*(-y/r *z/r)]
#if 0
#if 1
                    if (((SinTetta > CPV ) || (SinTetta < -CPV )))// && (((k+n)&1) == 1))
                    {
#endif
                        //OneMinusZdivRInSquare_ZdivRval[SatCalc][n][k] = tempVal=R0divR[n] *OneMinusSinTettaInSquare2 * Pnk_tilda[n][k+1] * Qnk[n][k];// /SinTetta[1];
                        OneMinusZdivRInSquare_ZdivRval[SatCalc][n][k] = tempVal =(Pnk_tilda[n][k+1] * Qnk[n][k]*R0divR[n]*(1-SinTetta*SinTetta))/SinTetta;
                        OldZSign[SatCalc][n][k] = SinTetta;
#if 1
                    }
                    else
                    {
                        if (((SinTetta >0) && (OldZSign[SatCalc][n][k] < 0)) || ((SinTetta <0) && (OldZSign[SatCalc][n][k] > 0)))
                        {
                            OneMinusZdivRInSquare_ZdivRval[SatCalc][n][k] = tempVal = - OneMinusZdivRInSquare_ZdivRval[SatCalc][n][k];
                            OldZSign[SatCalc][n][k] = -OldZSign[SatCalc][n][k];
                        }
                        else
                            tempVal = - OneMinusZdivRInSquare_ZdivRval[SatCalc][n][k];
                        //tempVal = OneMinusZdivRInSquare_ZdivRval[SatCalc][n][k] *(OldZSign[SatCalc][n][k]/SinTetta);
                        //tempVal =(Pnk_tilda[n][k+1] * Qnk[n][k]*R0divR[n]*(1-SinTetta*SinTetta))/SinTetta;
                        //if ((OldZSign[SatCalc][n][k]/SinTetta) > 4)
                        {
                            printf("zeroZ");
                        }
                    }
#endif
#endif
#if 0
                    Z += R0divR[n] *
                                (-(n+1)  /** SinTetta[1]*/ * Pnk_tilda[n][k] * Qnk[n][k] 
                                 //+ /*OneMinusSinTettaInSquare * Pnk_tilda[n][k+1] * Qnk[n][k] /SinTetta[1]*/ tempVal//OneMinusZdivRInSquare_ZdivRval[SatCalc][n][k]
                                 + Pnk_tilda[n][k] * (-D_Qnk_Dxr[n][k]*XdivRval - D_Qnk_Dyr[n][k]*YdivRval)//(CNK[n][k]*XkDxr[k] + SNK[n][k]*YkDxr[k]) * XdivRval/**SinTetta[1]*/ - (CNK[n][k]*XkDyr[k] + SNK[n][k]*YkDyr[k])*YdivRval/**SinTetta[1]*/)
                                 )/*/SinTetta[1]*/
                                 +tempVal
                    ;
#else

                    Z += R0divR[n] *
                                (-(n+1)  * SinTetta * Pnk_tilda[n][k] * Qnk[n][k] 
                                 + Pnk_tilda[n][k+1] * Qnk[n][k]*(1-SinTetta*SinTetta)
                                 + Pnk_tilda[n][k] * (-D_Qnk_Dxr[n][k]*XdivRval*SinTetta - D_Qnk_Dyr[n][k]*YdivRval*SinTetta)//(CNK[n][k]*XkDxr[k] + SNK[n][k]*YkDxr[k]) * XdivRval/**SinTetta[1]*/ - (CNK[n][k]*XkDyr[k] + SNK[n][k]*YkDyr[k])*YdivRval/**SinTetta[1]*/)
                                 )/*/SinTetta[1]*/
                    ;

#endif
            }
        }
        long double tempX = cos(-Lambda) * X - sin(-Lambda) * Y;
        long double tempY = sin(-Lambda) * X + cos(-Lambda) * Y;
        X = tempX;
        Y = tempY;
#if 0
        if (((XdivRval > CPV ) || (XdivRval < -CPV )))
        {
            fx[SatCalc] = X;
            X /= XdivRval;
            fsinX[SatCalc] =XdivRval;
        }
        else
        {
            printf("x");
            if (((fsinX[SatCalc]>0) && (XdivRval > 0)) || ((fsinX[SatCalc]<=0) && (XdivRval <= 0)))
            {
                X = fx[SatCalc]/fsinX[SatCalc];// Y = fy[SatCalc]; Z = fz[SatCalc];
            }
            else
            {
                fx[SatCalc]=-fx[SatCalc]; fsinX[SatCalc] = -fsinX[SatCalc];
                X = fx[SatCalc]/fsinX[SatCalc];//  Y = fy[SatCalc]; Z = fz[SatCalc];
            }
        }
        if (((YdivRval > CPV ) || (YdivRval < -CPV )))
        {
            fy[SatCalc] = Y;
            Y /= YdivRval;
            fsinY[SatCalc] =YdivRval;
        }
        else
        {
            printf("y");
            if (((fsinY[SatCalc]>0) && (YdivRval > 0)) || ((fsinY[SatCalc]<=0) && (YdivRval <= 0)))
            {
                //X = fx[SatCalc]; 
                Y = fy[SatCalc]/fsinY[SatCalc]; //Z = fz[SatCalc];
            }
            else
            {
                fy[SatCalc]=-fy[SatCalc]; fsinY[SatCalc] = -fsinY[SatCalc];
                //X = fx[SatCalc];  
                Y = fy[SatCalc]/fsinY[SatCalc];// Z = fz[SatCalc];
            }
        }
#endif
#ifndef _ACCOUNT_SIN
        if (((SinTetta > CPV ) || (SinTetta < -CPV )))
        {
            fz[SatCalc] = Z;
            Z /= SinTetta;
            fsinZ[SatCalc] =SinTetta;
        }
        else
        {
            printf("z");
            if (((fsinZ[SatCalc]>0) && (SinTetta > 0)) || ((fsinZ[SatCalc]<=0) && (SinTetta <= 0)))
            {
                //X = fx[SatCalc]; Y = fy[SatCalc]; 
                Z = fz[SatCalc]/fsinZ[SatCalc];
            }
            else
            {
                fz[SatCalc]=-fz[SatCalc]; fsinZ[SatCalc] = -fsinZ[SatCalc];
                //X = fx[SatCalc];  Y = fy[SatCalc]; 
                Z = fz[SatCalc]/fsinZ[SatCalc];
            }
        }
#endif
    };
    long double SummJ(void)
    {
        // this is a formula for gravitation potential (NOT a force)
        // to get a force needs to get analiticaly derivitive from Gravitation potencial
        // page 90 on Aksenov lectures : http://vadimchazov.narod.ru/lepa_zov/lesat.pdf
        //	- J2 * (r0/r)**2 * P2(sinPHI)  
        //	- J3 * (r0/r)**3 * P3(sinPHI) 
        //  - J4 * (r0/r)**4 * P4(sinPHI)
    
        long double Summ = 1.0;
        for (int n = 2; n <=iLeg; n++)
        {
            Summ += J[n]*R0divR[n]*P[n];
        }
        // for now no earth rotation acounted
        //+ SUM2=( (r0/r)**2 * P21(sinPHI) * (C21 * cos(1*Lambda) + S21*sin(1*Lanbda)) +
        //           (r0/r)**2 * P22(sinPhi) * (C22 *cos(2*Lambda) + S22*sin(2*Lambda))     )
        //Summ += R0divR[2] * LastPNK[2][1] * (CNK[2][1] * cos(Lambda) + SNK[2][1]*sin(Lambda)) +
        //       R0divR[2]*LastPNK[2][2]*(CNK[2][2]*cos(2.0*Lambda) + SNK[2][2]*sin(2.0*Lambda));
        for (int n= 2; n <= iLeg; n++)
        {
            for (int k =1; k <=n; k++)
            {
                Summ += R0divR[n] * Ptilda[n] *(CNK[n][k]*cos((long double)k*Lambda) +SNK[n][k]*sin((long double)k*Lambda));
            }
        }

        return Summ;
    };
#endif
} TRAOBJ, *PTRAOBJ;

#define MAX_IMPULSE_LINES 100


typedef struct TraImplObj
{
    int iLine;
    int iEngineOnSatellite;
    int EngineOn;
    int EngineDone;
    int ImplsPointer;
    int iCalculate;
    long double TotalImpulse;
    long double Weight;
    long double DeltaTime;
    int IteraPerSec;
    long double FireTime;
    long double Ang1;
    long double Ang2;
    long double XVec;
    long double YVec;
    long double ZVec;
    long double ValImpl[MAX_IMPULSE_LINES];
    int NearBody;
    long double TotalWeight;
    int AngleType;
    int AngleOnBody;
    long double OptimizationInitialStep;
    long double OptimizationDecCoef;
    long double OptimizationInitialStepCopy;
    long double OptimizationDecCoefCopy;
    long double OptimizationStop;
    int OptimizationFirstDirectionSwitch;
    long double SeartchForPeriod;
    int iCountApogPerig;
} TRAIMPLOBJ, *PTRAIMPLOBJ;

typedef struct TraOptimObj
{
    long double FireTime; // firing time of an engine
    long double Ang1; // first angle
    long double Ang2; // second angle
    long double XVec; // direction firing vector (X component)
    long double YVec; // direction (Y component)
    long double ZVec; // direction (Z component)
    int NearBody; 
    int AngleType;
    int AngleOnBody;
    //int OptimizationFirstDirectionSwitch;
    int EngineToOptimize;
    int TrajectoryOptimizationType;
    int LastEngine;
    int Calculate;
    long double OptimizationInitialStep;
    long double OptimizationDecCoef;
    long double OptimizationStop;
    int iNumberOfTryValues;
#define _VAL_TRY 30*24
    long double dValTry[_VAL_TRY]; 
    long double dValTryMaxMin[_VAL_TRY]; 
    //long double SeartchForPeriod;
    long double Period;
}TRAOPTIMOBJ, *PTRAOPTIMOBJ;

int EngineToOptimize = 4; // 0 == first engine firing - search for apogee 
                       // 1 == second engine firing - search for perigee
                       // 2 == third engine firing 
                       // 3 == 4th impulse
                       // 4 == 5th impulse
    
    
int TrajectoryOptimizationType = 0; 
          //1 - search for a minimum by adjusting time of firing
          //2 - search for a maximum by adjusting time of firing
          //3 - search for minimum by adjusting time of firing
          //4 - search fo minimum by adjusting angle of firing 

#define MINIMUM_BY_TIME 1
#define MAXIMUM_BY_TIME 2
#define MINIMUM_BY_ANGLE 4
#define MINIMUM_BY_WEIGHT 6

#define CALC_PERIGEE 0
#define CALC_APOGEE 1
#define CALC_TARGET_PRACTICE 3
#define CALC_TARGET_POINT 5
#define CALC_PERIOD 6 
#define CALC_MAX_FROM_EARTH 7
#define CALC_INIT_PERIOD 8
#define CALC_FIRE_FIRST_ENGINE_TIME 9
#define CALC_FIRE_SECOND_ENGINE_TIME 10
#define CALC_FIRE_THIRD_ENGINE_TIME_TRY_ONE 11
#define CALC_AT_APOGEE_DIFF_TO_3_4_DIST 12

#define COPYKEPLER(a1,b1,c1) memset(szTempo, 0, sizeof(szTempo)); memcpy(szTempo, b1, c1);  if (szTempo[0] == ' ') {szTempo[0] = '0';if (szTempo[1] == ' ') {szTempo[1] ='0';if (szTempo[2] == ' '){szTempo[2] ='0';}}}a1 = atof(szTempo);


long OldCurentTimeSec;
int OldCurentTimeTD;
int OldCurentIteraPerSec;

long double dMinFromNow = 3.0;
long double dStartJD = 0.0;//2451544.5; // if value dStartJD not set (==0.0) then use value from keplers elements of a satelite 0
// if it will be more then one satellite needs to set this value to a last epoch of all satellites
long double dStartTLEEpoch;
int JustFlySimulation =0;

long double SunX =.0;
long double SunY =.0;
long double SunZ = .0;
long double SunM = 1.9891E30;
long double GMSun;
long double SunR;
long double GMEarth;
long double GMEarthMoon;
long double GMMoon;

long double AU;
long double AUcalc;
long double EarthSmAxAU;

TRAOBJ SolarSystem;
TRAOBJ Sat;
#define MAX_OPTIM 30
int MaxOptim = MAX_OPTIM;
int StartOptim = 0;
TRAOPTIMOBJ Opt[MAX_OPTIM];
int iOptPtr = 0;
int iOptimizationStep = 0;


int iFirstMinMax = 0;
long double FirstMinMaxX2 = .0;
long double FirstMinMaxY2 = .0;
long double FirstMinMaxZ2 = .0;

long double DeltaMinMaxD = 1.0E60;


long double EarthX = .0;
long double EarthY = .0;
long double EarthZ = .0;
long double EarthX2 = .0;
long double EarthY2 = .0;
long double EarthZ2 = .0;
long double EarthR = 6371000.0;
long double EarthRP;
long double EarthRE;
long double EarthM = 5.9736E24;
long double MassRatioSunToEarthPlusMoon;
long double EarthTSolSec;
long double EarthCurTime;
long double EarthCurTimeS;
long double EarthSmAx;
long double EarthTDays;
long double EarthTSec;
long double EarthCalcKepler;

long double EarthVX = .0;
long double EarthVY = .0;
long double EarthVZ = .0;


long double MoonX = 363104000.0;
long double MoonY = .0;
long double MoonZ = .0;

long double MoonR = 1737100.0;
long double MoonRP;
long double MoonRE;
long double MoonM = 7.3477E22;
long double MassRatioEarthToMoon;


long double MoonVX = .0;
long double MoonVY = 1022.0;
long double MoonVZ = .0;
long double MoonTSec;
long double MoonCurTime;
long double MoonCurTimeS;

long double MoonTPeriod;
int MoonKeplerDone = 0;

long double StartLandingIteraPerSec = 0.0;
int iStartLandingIteraPerSec = 0;

long double Gbig = 0;//6.6725E-11;

BOOL OutLast = FALSE;

char szMoonKeplerLine1[1024];
char szMoonKeplerLine2[1024];
char szMoonKeplerLine3[1024];

char UseSatData[1024] = {"SGP4"};  // allowed initial data:
                                   // SGP - use SGP from Space Track Report 3 to calculate position and velocity based on TLE
                                   // SGP4 - use SPG4 to calulate initial position and velocity from TLE
                                   // SGP8 - use SGP8
                                   // KEPLER - use internal "kepler" function to calculate position
                                   // INTERNAL use of internal data
                                   // ProbTime=<time>, ProbC=<count of integral iterations>, ProbT=<delta time of iterations>
                                   // ProbX0=<X0>, ProbY0=<Y0>, ProbZ0=<Z0>, ProbVX0=<VX0>, ProbVY0=<VY0>, ProbVZ0=<VZ0>, 
                                   //   ProbIFX1=<integral Fx>, ProbIFY1=<integral Fy>, ProbIFZ1=<integral Fz>
                                   //   ProbIFX2=<integral Fx>, ProbIFY2=<integral Fy>, ProbIFZ2=<integral Fz>
                                   //   ProbIFX3=<integral Fx>, ProbIFY3=<integral Fy>, ProbIFZ3=<integral Fz>
                                   //   ProbIVX1=<integral VX>, ProbIVY1=<integral VY>, ProbIVZ1=<integral VZ>
                                   //   ProbIVX2=<integral VX>, ProbIVY2=<integral VY>, ProbIVZ2=<integral VZ>
                                   //   ProbIVX3=<integral VX>, ProbIVY3=<integral VY>, ProbIVZ3=<integral VZ>

char Mode[1024]={"PROP"}; // allowed modes:
                          //    PROP == (default) proparation of the orbit
                          //    SIM ==  simulation of the data from satellite
                          //    CALC == calculation of the orbit based on any of the data : PING, GPS, PULSAR 
                          //    OPTIM = calculation of the engines firing to reach the moon
char SimulationType[1024];
                          //    aloowed simulation modes
                          //    TLE - data == read TLE and calculate position on the specific time (TLE_EARTH_CRS,TLE_EARTH_TRS,TLE_SOLAR_CRS == 3 type of data
                          //    PING - data == simulate ping messages from ground station to satellite (at spesific time from all ground stations)
                          //    GPS  - data == simulate GPS's raw data from GPS satellites at specific time from GPS satellites
                          //    PULSAR - data == simulate PULSAR receving signal from all pulsars at specific time
                          // TLE and PING output data is the same: for PING:
                          //     Time=<time>, TimeErr=<time(d)>, PosX=<X(m)>, PosY=<Y(m)>, PosZ=<Z(m)>, PosErr=<error(m)> pingD1=<time(d) from GS->sat>, PingD11Err=<time(d)>
                          //         PingDel=<time(d) of processing data on sat>, PingDelErr=<time(d)>, PingD2=<time(d) from Sat to GS>, PingD2Err=<time(d)>
                          // for TLE:
                          //   Time=<time-from-simulation-output-time>, TimeErr=0, 
                          //           PosX=<X(m) position of the sat related to the earth>, PosY=<Y(m)>, PosZ=<Z(m)>, PosErr=<error(m) of the position>
                          //           pingD1=0, PingD11Err=0, PingDel=0, PingDelErr=0, PingD2=0, PingD2Err=0
                          // for GPS:
                          //  Time=<time-from-simulation-output-time>, GPS=<ID>, UTC=<time UTC from SAT>,
                          //       RawX=<X(m)> RawY=<Y(m)> RawZ=<Z(m)> RawVX=<VX(m)> RawVY=<VY(m)> RawVZ=<VZ(m)>
                          // for PULSAR:
                          //  Time=<time-from-simulation-output-time>, PULSAR=<ID>, DaltaT=<time btw two pulsars signals>



#define MAX_OUTPUT_TIMES 64
int SimulationOutputCount = 0;
long double SimulationOutputTime[MAX_OUTPUT_TIMES];
char SimulationTempOutputFile[1024]={"@trasimoutput.xml"};
char SimulationOutputFile[1024]={"@tra_sim_output.xml"};;
int UrlTraSimPort=80; 
char szURLTraSimFileName[1024];
char szTraSimFileName[1024];

char CalulationTempOutputFile[1024]={"@tracalc.xml"}; // in CALC mode the output file with 
char CalulationOutputFile[1024]={"@tra_calc.xml"}; // in CALC mode the output file with 
int UrlTraCalcPort=80; 
char szURLTraCalcFileName[1024];
char szTraCalcFileName[1024];
typedef struct Mesurement
{
    int NearBody;

    long double T;
    long double X, Y, Z;
    long double H,LAT, LON;
    long double Err;
    long double D1, Err1;
    long double T2, ErrT2;
    long double D3, ErrD3;
    long double VX;
    long double VY;
    long double VZ;
} MESAUREMENT, *PMEASUREMENT;

#define MAX_MEASURES 128
MESAUREMENT measures[MAX_MEASURES];
int iMAxMesaures;

int EnginesCount = 0;
#define MAX_ENGINES 6
TRAIMPLOBJ Engine[MAX_ENGINES];
int LastEngine = 0;
int iItaration = 0;


// ground stations
long double GrLat[10];
long double GrLong[10];
typedef struct tagPulsars
{
    int N;
    char Name[20];
    long double ELONG;
    long double ELAT;
    long double P0;
    long double S400mJy;

} PULSARS, *PPULSARS;

#define NPULSARS 150
int nPulsars= 0;
PULSARS Pulsars[150];


void CalcPlanetForces(TRAOBJ * SlS)
{
    int i;
    int j;
    // calculation of a forces
    for (i = 0; i < SlS->Elem; i++)
    {
        //if (SlS->flInUse[i] ==0)
        //    continue;

        long double *SlS_ForceDD_i_j = &SlS->ForceDD[i][0];
        long double *SlS_GM_j = &SlS->GM[0];
        long double *SlS_Distance2_i_j = &SlS->Distance2[i][0];
        for (j = 0; j < i; j++)
        {
            *SlS_ForceDD_i_j = * SlS_GM_j / *SlS_Distance2_i_j;
            SlS_ForceDD_i_j++;SlS_GM_j++;SlS_Distance2_i_j++;
        }
        SlS_ForceDD_i_j++;SlS_GM_j++;SlS_Distance2_i_j++;

/*
        for (j = 0; j < i; j++)
        {
            SlS->ForceDD[i][j] = SlS->GM[j] / SlS->Distance2[i][j];
        }
*/
        long double *SlS_Distance_i_j = &SlS->Distance[i][i+1];
        for (j = i+1; j < SlS->Elem; j++,SlS_ForceDD_i_j++,SlS_GM_j++,SlS_Distance2_i_j++,SlS_Distance_i_j++)
        {
            //if (i == j) 
            //    continue;
            //if (i > j)
            //{
            //    //SlS->ForceDD[i][j] = SlS->ForceDD[j][i];
            //    SlS->ForceDD[i][j] = SlS->GM[j] / SlS->Distance2[i][j];
            //    continue;
            //}
            //if (SlS->flInUse[j] ==0)
            //    continue;
            long double tD_Obj1Obj2 = (SlS->X[i] - SlS->X[j])*(SlS->X[i] - SlS->X[j]) + 
					    (SlS->Y[i] - SlS->Y[j])*(SlS->Y[i] - SlS->Y[j]) + 
					    (SlS->Z[i] - SlS->Z[j])*(SlS->Z[i] - SlS->Z[j]);

            //if (tD_Obj1Obj2 != SlS->Distance2[i][j])
            {
                *SlS_Distance2_i_j = tD_Obj1Obj2;
                SlS->Distance2[j][i] = tD_Obj1Obj2;
                double tD_ = sqrt(tD_Obj1Obj2);
                *SlS_Distance_i_j = tD_;
                SlS->Distance[j][i] = tD_;

                //if (tD_ != SlS->Distance[i][j])
                {
#if 1
                    //SlS->ForceDD[i][j] = /* SlS->M[i] * */SlS->GM[j] / SlS->Distance2[i][j];
                    *SlS_ForceDD_i_j = * SlS_GM_j / tD_Obj1Obj2;
#else
                    SlS->ForceDD[i][j] = SlS->GMxM[i][j] / SlS->Distance2[i][j];
                    SlS->ForceDD[j][i] = SlS->GMxM[j][i] / SlS->Distance2[j][i];

#endif
                }
            }
        }
    }

    for (i = 0; i < SlS->Elem; i++)
    {
        SlS->FX[i] = 0.0;
        SlS->FY[i] = 0.0;
        SlS->FZ[i] = 0.0;

        //if (SlS->flInUse[i] ==0)
        //    continue;
        long double *SlS_ForceDD_i = &(SlS->ForceDD[i][0]);
        long double *SlS_Distance_i = &(SlS->Distance[i][0]);
        for (j = 0; j < SlS->Elem; j++,SlS_ForceDD_i++, SlS_Distance_i++)
        {
            if (i == j) continue;
            //if (SlS->flInUse[j] ==0)
            //continue;
            long double SlS_ForceDD_i_j_div_SlS_Distance_i_j = *SlS_ForceDD_i/ *SlS_Distance_i;
            SlS->FX[i] += -( SlS->X[i] - SlS->X[j]) * SlS_ForceDD_i_j_div_SlS_Distance_i_j;
            SlS->FY[i] += -( SlS->Y[i] - SlS->Y[j]) * SlS_ForceDD_i_j_div_SlS_Distance_i_j;
            SlS->FZ[i] += -( SlS->Z[i] - SlS->Z[j]) * SlS_ForceDD_i_j_div_SlS_Distance_i_j;
        }
    }

}

int printcount =0;
void CalcSatForces(TRAOBJ * SlS, TRAOBJ * Sat, long double TimeOfCalc)
{
    int i;
    int j;
//    double Summ;
//    double Temp;
    long double DX1,DY1,DZ1;
    long double DX,DY,DZ;


    // calculation of a forces
    // loop for all calulated satellites
    for (i = 0; i < Sat->Elem; i++)
    {
       // loop for all selestial bodies
        long double *Sat_Distance2_i_j = &Sat->Distance2[i][0];
        long double *Sat_Distance_i_j  = &Sat->Distance[i][0];
        long double *Sat_ForceDD_i_j   = &Sat->ForceDD[i][0];
        long double *SlS_GM_j = &SlS->GM[0];
        long double *Sat_DeltaVX_i_j = &Sat->DeltaVX[i][0];
        long double *Sat_DeltaVY_i_j = &Sat->DeltaVY[i][0];
        long double *Sat_DeltaVZ_i_j = &Sat->DeltaVZ[i][0];
        for (j = 0; j < SlS->Elem; j++, Sat_Distance2_i_j++, Sat_Distance_i_j++, Sat_ForceDD_i_j++, SlS_GM_j++, Sat_DeltaVX_i_j++, Sat_DeltaVY_i_j++, Sat_DeltaVZ_i_j++)
        {
            // do we account that? Sun == yes Moon == yes but Saturn == probably no
            //if (SlS->flInUse[j] ==0)
            //    continue;
            // that is the distance*distance from the satellite to selestial body
            long double ValX0 = (Sat->X[i] - SlS->X[j]);
            long double ValY0 = (Sat->Y[i] - SlS->Y[j]);
            long double ValZ0 = (Sat->Z[i] - SlS->Z[j]);

            long double tD_Obj1Obj2 = ValX0*ValX0 + ValY0*ValY0 + ValZ0*ValZ0;
            
            *Sat_Distance2_i_j = tD_Obj1Obj2;
            long double tD_ = sqrt(tD_Obj1Obj2);
            *Sat_Distance_i_j = tD_;
            
#define FAST_CALCULATIONS
#ifdef FAST_CALCULATIONS

            //Sat->ForceDD_ = Sat->ForceDD[i][j];
            *Sat_DeltaVX_i_j =0;
            *Sat_DeltaVY_i_j =0;
            *Sat_DeltaVZ_i_j =0;

            if (j == Sat->LegBody)
            {
                //long double ModelCoef = SlS->GM[j]/ GM_MODEL;
                *Sat_ForceDD_i_j = GM_MODEL / *Sat_Distance2_i_j;

                Sat->R0divR[0] = 1;
                Sat->R0divR[1] = R0_MODEL/tD_;
                if (*Sat_Distance_i_j < 20*R0_MODEL)
                {
                    long double oXdivR = ValX0 /tD_;
                    long double oYdivR = ValY0 /tD_;
                    long double oZdivR = ValZ0 /tD_;

                    Sat->FastSummXYZ(ValX0,ValY0,ValZ0,Sat->Distance[i][j],DX1,DY1,DZ1, DX,DY,DZ,i);
#define _NO_GM_CORRECTION 1
#ifndef _NO_GM_CORRECTION
                    *Sat_DeltaVX_i_j =DX/ModelCoef;
                    *Sat_DeltaVY_i_j =DY/ModelCoef;
                    *Sat_DeltaVZ_i_j =DZ/ModelCoef;
#else
                    *Sat_DeltaVX_i_j =DX1*oXdivR + DX;
                    *Sat_DeltaVY_i_j =DY1*oYdivR + DY;
                    *Sat_DeltaVZ_i_j =DZ1*oZdivR + DZ;
                    //printf("\n %04d %20.18f %20.18f %20.18f %20.18f %20.18f %20.18f %20.18f", printcount++, DX1, DX1*oXdivR, DX1*oYdivR, DX1*oZdivR, DX, DY, DZ); 
#endif
                }
            }
            else
            {
                *Sat_ForceDD_i_j = *SlS_GM_j / *Sat_Distance2_i_j; // to get real force need to multiply on mass of the satellite
            }


#else
#endif
        }
    }
    long double *Sat_FX_i = &Sat->FX[0];
    long double *Sat_FY_i = &Sat->FY[0];
    long double *Sat_FZ_i = &Sat->FZ[0];
    // calculation of a XYZ forces
    for (i = 0; i < Sat->Elem; i++,Sat_FX_i++,Sat_FY_i++,Sat_FZ_i++)
    {
        *Sat_FX_i = 0.0;
        *Sat_FY_i = 0.0;
        *Sat_FZ_i = 0.0;

        long double *Sat_DeltaVX_i_j = &Sat->DeltaVX[i][0];
        long double *Sat_DeltaVY_i_j = &Sat->DeltaVY[i][0];
        long double *Sat_DeltaVZ_i_j = &Sat->DeltaVZ[i][0];
        long double *Sat_ForceDD_i_j = &Sat->ForceDD[i][0];
        long double *Sat_Distance_i_j =  &Sat->Distance[i][0];
        for (j = 0; j < SlS->Elem; j++, Sat_DeltaVX_i_j++, Sat_DeltaVY_i_j++, Sat_DeltaVZ_i_j++, Sat_ForceDD_i_j++, Sat_Distance_i_j++)
        {
            //if (SlS->flInUse[j] ==0)
            //continue;
            if (j == Sat->LegBody)
            {
                //Sat->FX[i] += -( Sat->X[i] - SlS->X[j])  * Sat->ForceDD[i][j]/Sat->Distance[i][j] + Sat->DeltaVX[i][j]*Sat->ForceDD[i][j];
                //Sat->FY[i] += -( Sat->Y[i] - SlS->Y[j])  * Sat->ForceDD[i][j]/Sat->Distance[i][j] + Sat->DeltaVY[i][j]*Sat->ForceDD[i][j];
                //Sat->FZ[i] += -( Sat->Z[i] - SlS->Z[j])  * Sat->ForceDD[i][j]/Sat->Distance[i][j] + Sat->DeltaVZ[i][j]*Sat->ForceDD[i][j];

                *Sat_FX_i += - *Sat_DeltaVX_i_j* *Sat_ForceDD_i_j;
                *Sat_FY_i += - *Sat_DeltaVY_i_j* *Sat_ForceDD_i_j;
                *Sat_FZ_i += - *Sat_DeltaVZ_i_j* *Sat_ForceDD_i_j;

#if 1
                if (Sat->ProbSquare[i])
                {
                    // account Air force:
                    long double AirFX = Sat->VX[i] - SlS->VX[j];
                    long double AirFY = Sat->VY[i] - SlS->VY[j];
                    long double AirFZ = Sat->VZ[i] - SlS->VZ[j];
                    long double AirNorm = sqrt(AirFX*AirFX + AirFY*AirFY + AirFZ*AirFZ);
                    long double AbsAir = AirNorm* Sat->ro[i] * Sat->ProbSquare[i]/2*SlS->TimeSl_2;
                    //long double AbsAir = AirNorm* Sat->ro[i] * 2004.0*SlS->TimeSl_2; // is it? Is ISS looks like square with side= 56.014 m? => S area= 3137.679m^2
                    //long double AbsAir = AirNorm* Sat->Ro * 1568.8395*SlS->TimeSl_2; // is it? Is ISS looks like square with side= 56.014 m? => S area= 3137.679m^2
                    *Sat_FX_i -=AirFX *AbsAir;
                    *Sat_FY_i -=AirFY *AbsAir;
                    *Sat_FZ_i -=AirFZ *AbsAir;
                }
#endif
            }
            else
            {
                long double Sat_ForceDD_i_j_div_Sat_Distance_i_j = *Sat_ForceDD_i_j/ *Sat_Distance_i_j;
                *Sat_FX_i += -( Sat->X[i] - SlS->X[j]) * Sat_ForceDD_i_j_div_Sat_Distance_i_j;
                *Sat_FY_i += -( Sat->Y[i] - SlS->Y[j]) * Sat_ForceDD_i_j_div_Sat_Distance_i_j;
                *Sat_FZ_i += -( Sat->Z[i] - SlS->Z[j]) * Sat_ForceDD_i_j_div_Sat_Distance_i_j;
            }
        }
    }
}
#define VERY_BASIC
#ifdef VERY_BASIC
#if 0
void IteraSolarSystem(BOOL ForceWasCalculated, TRAOBJ * SlS)
{
    int i;
    //int j;
    // calculation of a[i] based on x[i]
    CalcPlanetForces(SlS);
    // calculation of velocities and positions 
    for (i = 0; i < SlS->Elem; i++)
    {
        // this is original formula
        SlS->VX[i] += SlS->FX[i] * SlS->TimeSl/* / SlS->M[i]*/;
        SlS->VY[i] += SlS->FY[i] * SlS->TimeSl/* / SlS->M[i]*/;
        SlS->VZ[i] += SlS->FZ[i] * SlS->TimeSl/* / SlS->M[i]*/;

        SlS->X[i] += SlS->VX[i]*SlS->TimeSl;
        SlS->Y[i] += SlS->VY[i]*SlS->TimeSl;
        SlS->Z[i] += SlS->VZ[i]*SlS->TimeSl;

    }
}
#else
#define NO_SEPARATION_VEL_POS 1
void IteraSolarSystem(BOOL ForceWasCalculated, TRAOBJ * SlS)
{
    int i;
    //int j;
    // calculation of a[i] based on x[i]
    CalcPlanetForces(SlS);
    // calculation of velocities and positions 

    if (SlS->RunOne)
    {
        SlS->RunOne = FALSE;
        for (i = 0; i < SlS->Elem; i++)
        {
            SlS->_position_[i].ZeroIntegral();
            SlS->_velosity_[i].ZeroIntegral();

#ifdef NO_SEPARATION_VEL_POS
            SlS->_position_[i].X0 = SlS->X[i]/ SlS->TimeSl_2+ SlS->VX[i]/SlS->TimeSl;
            SlS->_position_[i].Y0 = SlS->Y[i]/ SlS->TimeSl_2+ SlS->VY[i]/SlS->TimeSl;
            SlS->_position_[i].Z0 = SlS->Z[i]/ SlS->TimeSl_2+ SlS->VZ[i]/SlS->TimeSl;

#else
            SlS->_position_[i].X0 = SlS->X[i]/ SlS->TimeSl_2; SlS->_position_[i].VX0 = SlS->VX[i]/SlS->TimeSl;
            SlS->_position_[i].Y0 = SlS->Y[i]/ SlS->TimeSl_2; SlS->_position_[i].VY0 = SlS->VY[i]/SlS->TimeSl;
            SlS->_position_[i].Z0 = SlS->Z[i]/ SlS->TimeSl_2; SlS->_position_[i].VZ0 = SlS->VZ[i]/SlS->TimeSl;
#endif

            SlS->_velosity_[i].X0 = SlS->VX[i]/SlS->TimeSl;
            SlS->_velosity_[i].Y0 = SlS->VY[i]/SlS->TimeSl;
            SlS->_velosity_[i].Z0 = SlS->VZ[i]/SlS->TimeSl;
        }
    }
    for (i = 0; i < SlS->Elem; i++)
    {
#ifdef NO_SEPARATION_VEL_POS
        SlS->_position_[i].Add((SlS->_velosity_[i].x())+ SlS->FX[i],
                                    (SlS->_velosity_[i].y())+ SlS->FY[i],
                                    (SlS->_velosity_[i].z())+ SlS->FZ[i]);

        SlS->_velosity_[i].Add(SlS->FX[i],
                                   SlS->FY[i],
                                   SlS->FZ[i]);
        SlS->_position_[i].adjustAll();
        SlS->_velosity_[i].adjustall();
        SlS->_position_[i].getIntegral(SlS->X[i], SlS->Y[i], SlS->Z[i]);

#else
        SlS->_position_[i].Addpos((SlS->_velosity_[i].x()), SlS->FX[i],
                                    (SlS->_velosity_[i].y()), SlS->FY[i],
                                    (SlS->_velosity_[i].z()), SlS->FZ[i]);

        SlS->_velosity_[i].Add(SlS->FX[i],
                                   SlS->FY[i],
                                   SlS->FZ[i]);
        SlS->_position_[i].adjustAllpos();
        SlS->_velosity_[i].adjustall();
        SlS->_position_[i].getIntegralpos(SlS->X[i], SlS->Y[i], SlS->Z[i]);
#endif
        SlS->X[i] = (SlS->X[i]+ SlS->_velosity_[i].X0 *SlS->_velosity_[i].nX0)* SlS->TimeSl_2;   
        SlS->Y[i] = (SlS->Y[i]+ SlS->_velosity_[i].Y0 *SlS->_velosity_[i].nX0)* SlS->TimeSl_2;   
        SlS->Z[i] = (SlS->Z[i]+ SlS->_velosity_[i].Z0 *SlS->_velosity_[i].nX0)* SlS->TimeSl_2;
        SlS->_velosity_[i].getIntegral(SlS->VX[i], SlS->VY[i], SlS->VZ[i]);
        SlS->VX[i] *= SlS->TimeSl; 
        SlS->VY[i] *= SlS->TimeSl; SlS->VZ[i] *= SlS->TimeSl;
        SlS->_position_[i].nX0++;
        SlS->_velosity_[i].nX0++;

    }
}

#endif
#if 0
void IteraSat(int TimeDirection, TRAOBJ * SlS, TRAOBJ * Sat, long double TimeOfCalc)
{
    int i;
    //int j;
    Sat->Lambda = GreenwichAscensionFromTLEEpoch(TimeOfCalc,Sat->precEps,Sat->precTet,Sat->precZ,Sat->nutEpsilon,Sat->nutDFeta);

    CalcSatForces(SlS, Sat, TimeOfCalc);

    for (i = 0; i < Sat->Elem; i++)
    {
        Sat->X[i] +=Sat->VX[i]*SlS->TimeSl +Sat->FX[i] * TimeSl_2;
        Sat->Y[i] +=Sat->VY[i]*SlS->TimeSl +Sat->FY[i] * TimeSl_2;
        Sat->Z[i] +=Sat->VZ[i]*SlS->TimeSl +Sat->FZ[i] * TimeSl_2;

        Sat->VX[i] += Sat->FX[i] * SlS->TimeSl /* Sat->M[i]*/;
        Sat->VY[i] += Sat->FY[i] * SlS->TimeSl /* Sat->M[i]*/;
        Sat->VZ[i] += Sat->FZ[i] * SlS->TimeSl /* Sat->M[i]*/;


    }
}
#else
void IteraSat(int TimeDirection, TRAOBJ * SlS, TRAOBJ * Sat, long double TimeOfCalc)
{
    int i;
    //int j;

    Sat->Lambda = GreenwichAscensionFromTLEEpoch(TimeOfCalc,Sat->precEps,Sat->precTet,Sat->precZ,Sat->nutEpsilon,Sat->nutDFeta);

#define TEST_STATIC_EARTH 1
#ifdef TEST_STATIC_EARTH
    Sat->precEps =0;
    Sat->precTet =0;
    Sat->precZ =0;
    Sat->nutEpsilon =0;
    Sat->nutDFeta = 0;
    Sat->Lambda = 0;
#endif

    CalcSatForces(SlS, Sat, TimeOfCalc);

    if (Sat->RunOne)
    {
        for (i = 0; i < Sat->Elem; i++)
        {
           
            Sat->_position_[i].ZeroIntegral();
            Sat->_velosity_[i].ZeroIntegral();
#ifdef NO_SEPARATION_VEL_POS
            Sat->_position_[i].X0 = Sat->X[i]/ SlS->TimeSl_2 + Sat->VX[i]/SlS->TimeSl;
            Sat->_position_[i].Y0 = Sat->Y[i]/ SlS->TimeSl_2 + Sat->VY[i]/SlS->TimeSl;
            Sat->_position_[i].Z0 = Sat->Z[i]/ SlS->TimeSl_2 + Sat->VZ[i]/SlS->TimeSl;

#else
            Sat->_position_[i].X0 = Sat->X[i]/ SlS->TimeSl_2; Sat->_position_[i].VX0 = Sat->VX[i]/SlS->TimeSl;
            Sat->_position_[i].Y0 = Sat->Y[i]/ SlS->TimeSl_2; Sat->_position_[i].VY0 = Sat->VY[i]/SlS->TimeSl;
            Sat->_position_[i].Z0 = Sat->Z[i]/ SlS->TimeSl_2; Sat->_position_[i].VZ0 = Sat->VZ[i]/SlS->TimeSl;
#endif

            Sat->_velosity_[i].X0 = Sat->VX[i]/SlS->TimeSl;
            Sat->_velosity_[i].Y0 = Sat->VY[i]/SlS->TimeSl;
            Sat->_velosity_[i].Z0 = Sat->VZ[i]/SlS->TimeSl;

        }
    }
    for (i = 0; i < Sat->Elem; i++)
    {
#ifdef NO_SEPARATION_VEL_POS
        Sat->_position_[i].Add((Sat->_velosity_[i].x())+ Sat->FX[i],
                                (Sat->_velosity_[i].y())+ Sat->FY[i],
                                (Sat->_velosity_[i].z())+ Sat->FZ[i]);
        Sat->_velosity_[i].Add(Sat->FX[i],
                                   Sat->FY[i],
                                   Sat->FZ[i]);
        Sat->_position_[i].adjustAll();
        Sat->_velosity_[i].adjustall();
        Sat->_position_[i].getIntegral(Sat->X[i], Sat->Y[i], Sat->Z[i]);
#else
        Sat->_position_[i].Addpos((Sat->_velosity_[i].x()), Sat->FX[i],
                                (Sat->_velosity_[i].y()), Sat->FY[i],
                                (Sat->_velosity_[i].z()), Sat->FZ[i]);
        Sat->_velosity_[i].Add(Sat->FX[i],
                                   Sat->FY[i],
                                   Sat->FZ[i]);
        Sat->_position_[i].adjustAllpos();
        Sat->_velosity_[i].adjustall();
        Sat->_position_[i].getIntegralpos(Sat->X[i], Sat->Y[i], Sat->Z[i]);
#endif
        Sat->X[i] = (Sat->X[i]+ Sat->_velosity_[i].X0 *Sat->_velosity_[i].nX0)* SlS->TimeSl_2;   
        Sat->Y[i] = (Sat->Y[i]+ Sat->_velosity_[i].Y0 *Sat->_velosity_[i].nX0)* SlS->TimeSl_2;   
        Sat->Z[i] = (Sat->Z[i]+ Sat->_velosity_[i].Z0 *Sat->_velosity_[i].nX0)* SlS->TimeSl_2;
        Sat->_velosity_[i].getIntegral(Sat->VX[i], Sat->VY[i], Sat->VZ[i]);
        Sat->VX[i] *= SlS->TimeSl; Sat->VY[i] *= SlS->TimeSl; Sat->VZ[i] *= SlS->TimeSl;
        Sat->_position_[i].nX0++;
        Sat->_velosity_[i].nX0++;
    }
}

#endif
#endif
void FireEngine(int TimeDirection, int DeltaTimeFromStart, TRAIMPLOBJ * Engine, TRAOBJ *Sat, int iSat, long double DirX, long double DirY, long double DirZ)
{
    long double VectorValue = sqrt(DirX*DirX + DirY*DirY +DirZ*DirZ);
    long double coeff = 1.0/VectorValue;
    long double dirX = DirX*coeff;
    long double dirY = DirY*coeff;
    long double dirZ = DirZ*coeff;
    // direction of a force is oposit the direction of a firing engine
    long double ForceX = -dirX * Engine->ValImpl[DeltaTimeFromStart];
    long double ForceY = -dirY * Engine->ValImpl[DeltaTimeFromStart];
    long double ForceZ = -dirZ * Engine->ValImpl[DeltaTimeFromStart];
    long double VX = ForceX* Engine->DeltaTime / Sat->M[iSat];
    long double VY = ForceY* Engine->DeltaTime / Sat->M[iSat];
    long double VZ = ForceZ* Engine->DeltaTime / Sat->M[iSat];
    
    Sat->VX[iSat] += VX;
    Sat->VY[iSat] += VY;
    Sat->VZ[iSat] += VZ;

    Sat->X[iSat] += VX * Engine->DeltaTime;
    Sat->Y[iSat] += VY * Engine->DeltaTime;
    Sat->Z[iSat] += VZ * Engine->DeltaTime;
    Sat->M[iSat] -= Engine->Weight * Engine->ValImpl[DeltaTimeFromStart]*Engine->DeltaTime / Engine->TotalImpulse;
}
long double GetRadius(TRAOBJ * SlS, int iBody, long double LongOnMoon,long double LatiOnMoon)
{
    long double dR = 1000000.0; // just for init == bogus radius 1000km
    // TBD earth NOT round
    if (iBody == EARTH)
    {
        dR = EarthR;
    }
    // TBD with the moon the same 
    if (iBody == MOON)
    {
        dR = MoonR;
    }
    return dR;
}
long double GetRadius(TRAOBJ * SlS, int iBody, TRAOBJ * Sat, int iSat)
{
    double dR = 1000000.0; // just for init == bogus radius 1000km
    // TBD earth NOT round
    if (iBody == EARTH)
    {
        dR = EarthR;
    }
    // TBD with the moon the same 
    if (iBody == MOON)
    {
        dR = MoonR;
    }
    return dR;
}
long double Targetlongitude = -15.0; // dolgota
long double Targetlatitude = -2.0; // shirota
// view from north pole to equator plane 
/// x to right
//  y to up
//  z perpendicular xy and to north
// x to west (negative axe to east) 
// y to grinvich meridian ( 0 longitude) west is a negative angle, east positive
// z to north
//   LAT = latitude * pi/180    // shirota
//   LON = longitude * pi/180   // dolgota
//   Y =  R * cos(LAT) * cos(LON)
//   Z =  R * sin(LAT) 
//   X = -R * cos(LAT) * sin(LON)
//
// (1) sin(LAT) = z/R  => LAT = arcsin(z/R)
//
// (2) sin(LON) = - X / (R * cos(LAT))
//     LON = arcsin(- X / (R * cos(LAT)))
//     cos(LON) = Y / (R * cos(LAT))
//                                             AY
//      0-> PI/2     sin(LON)<0 cos(LON)>0     | sin(LON) >0 cos(LON) >0      0 -> -PI/2
//      -------------------------------------------------------------------------------> X
//      PI/2->PI     sin(LON)<0 cos(LON)<0     | sin(LON)>0 cos(LON) <0    -PI/2 -> -PI

void getLongLatiMoon(double &LongOnMoon,double &LatiOnMoon, TRAOBJ *SlS, int iRefMOON,int iRefEARTH, TRAOBJ *Sat, int iSat)
{
    double dREM = sqrt((SlS->X[iRefMOON] - SlS->X[iRefEARTH])*(SlS->X[iRefMOON] - SlS->X[iRefEARTH])+
                       (SlS->Y[iRefMOON] - SlS->Y[iRefEARTH])*(SlS->Y[iRefMOON] - SlS->Y[iRefEARTH])+
                       (SlS->Z[iRefMOON] - SlS->Z[iRefEARTH])*(SlS->Z[iRefMOON] - SlS->Z[iRefEARTH]));
    double dRM = sqrt((SlS->X[iRefMOON] - Sat->X[iSat])*(SlS->X[iRefMOON] - Sat->X[iSat])+
                       (SlS->Y[iRefMOON] - Sat->Y[iSat])*(SlS->Y[iRefMOON] - Sat->Y[iSat])+
                       (SlS->Z[iRefMOON] - Sat->Z[iSat])*(SlS->Z[iRefMOON] - Sat->Z[iSat]));
    double SatZSin = (Sat->Z[0] -SlS->Z[iRefMOON])/ dRM;
    double EarthZSin = (SlS->Z[iRefEARTH] -SlS->Z[iRefMOON])/ dREM;
    double SatLatiAsin = asin(SatZSin);
    double EarthLatiAsin = asin(EarthZSin);
    LatiOnMoon = (SatLatiAsin-EarthLatiAsin)*180.0/M_PI;
	double SatZCos = cos(SatLatiAsin);
	double EarthZCos = cos(EarthLatiAsin);

    double SatXSin = -(Sat->X[0] -SlS->X[iRefMOON])/ dRM/ SatZCos;
    double EarthXSin = -(SlS->X[iRefEARTH] -SlS->X[iRefMOON])/ dREM/ EarthZCos;

    double SatYCos = (Sat->Y[0] -SlS->Y[MOON])/ dRM/ SatZCos ;
    double EarthYCos = (SlS->Y[iRefEARTH] -SlS->Y[iRefMOON])/ dREM/ EarthZCos;


    double SatLongAsin = asin(SatXSin);
    // check all quarters
    if ((SatXSin >= 0.0) && (SatYCos>=0.0))
        ;
    else if ((SatXSin < 0.0) && (SatYCos>=0.0))
        ;
    else if ((SatXSin < 0.0) && (SatYCos < 0.0))
        SatLongAsin += M_PI/2.0;
    else
        SatLongAsin -= M_PI/2.0;

    double EarthLongAsin = asin(EarthXSin);

    if ((EarthXSin >= 0.0) && (EarthYCos>=0.0))
        ;
    else if ((EarthXSin < 0.0) && (EarthYCos>=0.0))
        ;
    else if ((EarthXSin < 0.0) && (EarthYCos < 0.0))
        EarthLongAsin += M_PI/2.0;
    else
        EarthLongAsin -= M_PI/2.0;

    LongOnMoon = (SatLongAsin-EarthLongAsin)*180.0/M_PI;
}
// PosXMoon,PosYMoon,PosZMoon - is a point on a moon surface ; coordinates are common
void getXYZMoon(double LongOnMoon,double LatiOnMoon,double &PosXMoon,double &PosYMoon,double &PosZMoon, TRAOBJ *SlS,int iRefMOON,int iRefEARTH, double dRadius)
{
    double dREM = sqrt((SlS->X[iRefMOON] - SlS->X[iRefEARTH])*(SlS->X[iRefMOON] - SlS->X[iRefEARTH])+
                       (SlS->Y[iRefMOON] - SlS->Y[iRefEARTH])*(SlS->Y[iRefMOON] - SlS->Y[iRefEARTH])+
                       (SlS->Z[iRefMOON] - SlS->Z[iRefEARTH])*(SlS->Z[iRefMOON] - SlS->Z[iRefEARTH]));
    double EarthZSin = (SlS->Z[iRefEARTH] -SlS->Z[iRefMOON])/ dREM;
    double EarthLatiAsin = asin(EarthZSin);
	double EarthZCos = cos(EarthLatiAsin);
    double EarthLatiDeg = EarthLatiAsin * 180.0/M_PI;
    double SatLatideg = LatiOnMoon + EarthLatiDeg;
    double SatLatiAsin = SatLatideg * M_PI/180.0;
    double SatZSin = sin(SatLatiAsin);
	double SatZCos = cos(SatLatiAsin);

    double EarthXSin = - (SlS->X[iRefEARTH] -SlS->X[iRefMOON])/ dREM/EarthZCos;
    double EarthYCos = (SlS->Y[iRefEARTH] -SlS->Y[iRefMOON])/ dREM/EarthZCos;
    double EarthLongAsin = asin(EarthXSin);
    if ((EarthXSin >= 0.0) && (EarthYCos>=0.0))
        ;
    else if ((EarthXSin < 0.0) && (EarthYCos>=0.0))
        ;
    else if ((EarthXSin < 0.0) && (EarthYCos < 0.0))
        EarthLongAsin += M_PI/2.0;
    else
        EarthLongAsin -= M_PI/2.0;

    double SatLongAsin = LongOnMoon + EarthLongAsin* 180.0/M_PI;
    double SatXSin = sin(SatLongAsin* M_PI/180.0);
    double SatYCos = cos(SatLongAsin* M_PI/180.0);

    
    PosZMoon =   dRadius * SatZSin + SlS->Z[iRefMOON];
    PosXMoon = - dRadius * SatXSin * SatZCos + SlS->X[iRefMOON];
    PosYMoon =   dRadius * SatYCos * SatZCos + SlS->Y[iRefMOON];
}
void GetXYZfromLatLong(double Long,double Lat,double &PosX,double &PosY,double &PosZ, double dRadius)
{
//   LAT = latitude * pi/180    // shirota
//   LON = longitude * pi/180   // dolgota
//   Y =  R * cos(LAT) * cos(LON)
//   Z =  R * sin(LAT) 
//   X = -R * cos(LAT) * sin(LON)

    PosZ =   dRadius * sin(Lat* M_PI/180.0);
    PosX = - dRadius * cos(Lat* M_PI/180.0) * sin(Long* M_PI/180.0);
    PosY =   dRadius * cos(Lat* M_PI/180.0) * cos(Long* M_PI/180.0);
}

#ifdef _DO_VISUALIZATION
#define IMAGE_W 1280
#define IMAGE_H 720
int RGBReferenceBody = EARTH;
unsigned char bRGBImage[IMAGE_W*IMAGE_H*3];
int bRGBImageW = IMAGE_W;
int bRGBImageH = IMAGE_H;
double dRGBScale = 1000000000.0;
int iProfile = 0; // 0 == XY , 1 == YZ, 2 == XZ 3 == -YZ 4 == -XZ 5==-XY
// 0 or XY is a view from North to south, 5 (- XY) is a view from south to north
// 1 or YZ is a view to easter

int iMaxSeq = 128;
int iCounterToSkip = 0;
int iMaxCounter = 24*60*60;

                                  // mer      ven       ear      mar      jup         sat       urn      nep       plt       moon        sun
unsigned char PlanetColors[16*3] ={50,50,50, 0,255,0, 0,0,255, 127,0,0, 127,127,0, 127,0,127, 0,127,127, 0,64,64, 64,0,64, 127,127,127, 255,0,0};
unsigned char SatColors[16*3] ={0,0,0, 20,20,20, 30,30,30,};
char szXYZ[6][5] ={"XY", "YZ","XZ", "_YZ", "_XZ", "_XY"};
void putpixel(unsigned char *bRGB, int X, int Y)
{
    int iRow = (X + bRGBImageW/2) + (bRGBImageH - (Y + bRGBImageH/2))*bRGBImageW;
    if ((iRow*3 >=0) && (iRow*3 < (sizeof(bRGBImage) -3)))
    {
        memcpy(&bRGBImage[iRow*3],bRGB, 3);
    }
}
void DrawFinalBody(TRAOBJ *SlS, int iBodyReference, TRAOBJ *Sat, int iSec,char *szInitName, TRAOBJ *XYZReference, int iXYZReference, double Scale, int &StartSequence)
{
    double X1 = SlS->X[iBodyReference] - XYZReference->X[iXYZReference];
    double Y1 = SlS->Y[iBodyReference] - XYZReference->Y[iXYZReference];
    double Z1 = SlS->Z[iBodyReference] - XYZReference->Z[iXYZReference];
    double X2;
    double Y2;
    int i;
    double dRadius = GetRadius(SlS, iBodyReference, Sat, 0);
    switch(iProfile)
    {
    case 0: X2 = X1; Y2 = Y1;break; 
    case 1: X2 = Y1; Y2 = Z1;break; 
    case 2: X2 = X1; Y2 = Z1;break; 
    case 3: X2 = -Y1; Y2 = Z1;break;
    case 4: X2 = -X1; Y2 = Z1;break;
    case 5: X2 = -X1; Y2 = Y1;break; 
    default: break;
    }
    // draw circle
    for (i = 0; i < 365; i++)
    {
        double dDeg = ((double)i) * M_PI /180;
        double X2C = X2 + cos(dDeg)*dRadius;
        double Y2C = Y2 + sin(dDeg)*dRadius;

        if (-Scale < X2C  && X2C < Scale)
        {
            if (((-Scale * bRGBImageH/ bRGBImageW) < Y2C)  && Y2C < ((Scale* bRGBImageH/ bRGBImageW)))
            {
                putpixel(&PlanetColors[iBodyReference*3], (int)(X2C/Scale*bRGBImageH), (int)(Y2C/Scale*bRGBImageH));
            }
        }
    }
    // draw sun day & night lights
    double X1S = SlS->X[SUN] - XYZReference->X[iXYZReference];
    double Y1S = SlS->Y[SUN] - XYZReference->Y[iXYZReference];
    double Z1S = SlS->Z[SUN] - XYZReference->Z[iXYZReference];
    double DS = sqrt(X1S*X1S + Y1S*Y1S + Z1S*Z1S);
    switch(iProfile)
    {
    case 0: X1S = X1S; Y1S = Y1S;break; 
    case 1: X1S = Y1S; Y1S = Z1S;break; 
    case 2: X1S = X1S; Y1S = Z1S;break; 
    case 3: X1S = -Y1S; Y1S = Z1S;break;
    case 4: X1S = -X1S; Y1S = Z1S;break;
    case 5: X1S = -X1S; Y1S = Y1S;break; 
    default: break;
    }
    double dAngleSin = X1S/DS;
    double dAngleCos = Y1S/DS;
    for (i = -(int)dRadius; i < (int)dRadius; i+=1000)
    {
        double X2C = X2 + -dAngleCos*((double)i);
        double Y2C = Y2 + dAngleSin*((double)i);
        if (-Scale < X2C  && X2C < Scale)
        {
            if (((-Scale * bRGBImageH/ bRGBImageW) < Y2C)  && Y2C < ((Scale* bRGBImageH/ bRGBImageW)))
            {
                putpixel(&PlanetColors[iXYZReference*3], (int)(X2C/Scale*bRGBImageH), (int)(Y2C/Scale*bRGBImageH));
            }
        }

    }

    // draw direction to earth
    X1S = SlS->X[EARTH] - XYZReference->X[iXYZReference];
    Y1S = SlS->Y[EARTH] - XYZReference->Y[iXYZReference];
    Z1S = SlS->Z[EARTH] - XYZReference->Z[iXYZReference];
    DS = sqrt(X1S*X1S + Y1S*Y1S + Z1S*Z1S);
    switch(iProfile)
    {
    case 0: X1S = X1S; Y1S = Y1S;break; 
    case 1: X1S = Y1S; Y1S = Z1S;break; 
    case 2: X1S = X1S; Y1S = Z1S;break; 
    case 3: X1S = -Y1S; Y1S = Z1S;break;
    case 4: X1S = -X1S; Y1S = Z1S;break;
    case 5: X1S = -X1S; Y1S = Y1S;break; 
    default: break;
    }
    dAngleSin = X1S/DS;
    dAngleCos = Y1S/DS;
    for (i = 0; i < dRadius; i+=1000)
    {
        double X2C = X2 + dAngleSin*((double)i);
        double Y2C = Y2 + dAngleCos*((double)i);
        if (-Scale < X2C  && X2C < Scale)
        {
            if (((-Scale * bRGBImageH/ bRGBImageW) < Y2C)  && Y2C < ((Scale* bRGBImageH/ bRGBImageW)))
            {
                putpixel(&PlanetColors[iXYZReference*3], (int)(X2C/Scale*bRGBImageH), (int)(Y2C/Scale*bRGBImageH));
            }
        }

    }
    // draw last satelite point
    X1 = Sat->X[0] - XYZReference->X[iXYZReference];
    Y1 = Sat->Y[0] - XYZReference->Y[iXYZReference];
    Z1 = Sat->Z[0] - XYZReference->Z[iXYZReference];
    switch(iProfile)
    {
    case 0: X2 = X1; Y2 = Y1;break; 
    case 1: X2 = Y1; Y2 = Z1;break; 
    case 2: X2 = X1; Y2 = Z1;break; 
    case 3: X2 = -Y1; Y2 = Z1;break;
    case 4: X2 = -X1; Y2 = Z1;break;
    case 5: X2 = -X1; Y2 = Y1;break; 
    default: break;
    }

    if (-Scale < X2  && X2 < Scale)
    {
        if (((-Scale * bRGBImageH/ bRGBImageW) < Y2)  && Y2 < ((Scale* bRGBImageH/ bRGBImageW)))
        {
            putpixel(&SatColors[0], (int)(X2/Scale*bRGBImageH), (int)(Y2/Scale*bRGBImageH));
        }
    }
    if (StartSequence++ < iMaxSeq)
    {
        char szName[256];
        sprintf(szName, "%s%s%05d.jpg", szInitName, &szXYZ[iProfile],StartSequence-1);
        write_JPEG_file(szName, 80, bRGBImageW, bRGBImageH, 3,  bRGBImage, JCS_RGB);
    }
    // draw North pole on a moon
    if (iBodyReference == MOON)
    {

    }
}
void DrawAnimationSequence(TRAOBJ *SlS, TRAOBJ *Sat, int iSec,char *szInitName, TRAOBJ *XYZReference, int iXYZReference, double Scale, int &StartSequence, int storeNow)
{
    int i;
    //int j;

    if ((StartSequence == 0) && (storeNow ==0))
    {
        memset(bRGBImage, 255, sizeof(bRGBImage));
        iCounterToSkip = iMaxCounter;
        StartSequence++;
    }
    for (i = 0; i < SlS->Elem; i++)
    {
        double X1 = SlS->X[i] - XYZReference->X[iXYZReference];
        double Y1 = SlS->Y[i] - XYZReference->Y[iXYZReference];
        double Z1 = SlS->Z[i] - XYZReference->Z[iXYZReference];
        double X2;
        double Y2;
        switch(iProfile)
        {
        case 0: X2 = X1; Y2 = Y1;break; 
        case 1: X2 = Y1; Y2 = Z1;break; 
        case 2: X2 = X1; Y2 = Z1;break; 
        case 3: X2 = -Y1; Y2 = Z1;break;
        case 4: X2 = -X1; Y2 = Z1;break;
        case 5: X2 = -X1; Y2 = Y1;break; 
        default: break;
        }
        if (-Scale < X2  && X2 < Scale)
        {
            if (((-Scale * bRGBImageH/ bRGBImageW) < Y2)  && Y2 < ((Scale* bRGBImageH/ bRGBImageW)))
            {
                putpixel(&PlanetColors[i*3], (int)(X2/Scale*bRGBImageH), (int)(Y2/Scale*bRGBImageH));
            }
        }
    }
    for (i = 0; i < Sat->Elem; i++)
    {
        double X1 = Sat->X[i] - XYZReference->X[iXYZReference];
        double Y1 = Sat->Y[i] - XYZReference->Y[iXYZReference];
        double Z1 = Sat->Z[i] - XYZReference->Z[iXYZReference];
        double X2;
        double Y2;
        switch(iProfile)
        {
        case 0: X2 = X1; Y2 = Y1;break; 
        case 1: X2 = Y1; Y2 = Z1;break; 
        case 2: X2 = X1; Y2 = Z1;break; 
        case 3: X2 = -Y1; Y2 = Z1;break;
        case 4: X2 = -X1; Y2 = Z1;break;
        case 5: X2 = -X1; Y2 = Y1;break;
        default: break;
        }
        if (-Scale < Y2  && Y2 < Scale)
        {
            if ((-Scale * bRGBImageW/ bRGBImageH) < X2  && X2 < (Scale* bRGBImageW/ bRGBImageH))
            {
                putpixel(&SatColors[i*3], (int)(X2/Scale*bRGBImageH), (int)(Y2/Scale*bRGBImageH));
            }
        }
    }
    // store last image
    if ((--iCounterToSkip <= 0) || (storeNow == 1))
    {
        if (storeNow == 1)
        {
            iCounterToSkip++;
        }
        else
            iCounterToSkip = iMaxCounter;
        if (StartSequence++ < iMaxSeq)
        {
            char szName[256];
            sprintf(szName, "%s%s%05d.jpg", szInitName, &szXYZ[iProfile],StartSequence-1);
            //DeleteFile(szName);
            write_JPEG_file (szName, 80, bRGBImageW, bRGBImageH, 3,  bRGBImage, JCS_RGB);

        }
    }

}
#endif

int RunOrVoidEngine(int TimeDirection, TRAIMPLOBJ * Engines, TRAOBJ * SlS, TRAOBJ *Sat, 
                     long long &CurentTimeSec, int &CurentTimeTD, int &CurentIteraPerSec, double StartTimeSec)
{
    int iRet = 0;
    int i,j;
    double SecCalc;
    double DTempo;
    for(i = 0; i < Sat->Elem; i++)
    {
        if (Sat->flInUse)
        {
            for (j = 0; j < EnginesCount; j++)
            {
                if (Engines[j].iEngineOnSatellite == i)
                {
                    if (Engines[j].EngineDone == 0)
                    {
                        if (Engines[j].EngineOn)
                        {
                            // engine is ON
                            iRet = 1;
                            if ((Engines[j].ImplsPointer) < Engines[j].iLine)
                            {
                                FireEngine(1,Engines[j].ImplsPointer, &Engines[j], Sat, i, Engines[j].XVec, Engines[j].YVec, Engines[j].ZVec);
                                double VX = Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[EARTH];
                                double VY = Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[EARTH];
                                double VZ = Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[EARTH];
                                DTempo = sqrt(VX*VX+VY*VY+VZ*VX);
                                
                                VX = Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[MOON];
                                VY = Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[MOON];
                                VZ = Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[MOON];
                                DTempo = sqrt(VX*VX+VY*VY+VZ*VZ);
                                if (j ==4)
                                    printf("\n velocity = %f ", DTempo);
                                double X = Sat->X[Engines[j].iEngineOnSatellite] - SlS->X[MOON];
                                double Y = Sat->Y[Engines[j].iEngineOnSatellite] - SlS->Y[MOON];
                                double Z = Sat->Z[Engines[j].iEngineOnSatellite] - SlS->Z[MOON];
                                DTempo = sqrt(X*X+Y*Y+Z*Z);
                                if (j ==4)
                                    printf(" distance = %f ", DTempo- GetRadius(SlS, MOON, Sat, Engines[j].iEngineOnSatellite));

                            }
                            if ((++(Engines[j].ImplsPointer)) >= Engines[j].iLine)
                            {
                                if (Engines[j].ImplsPointer % Engines[j].IteraPerSec ==0)
                                {
                                    printf("\n cutoff engine=====> %d at= %f",j,Engines[j].FireTime+Engines[j].DeltaTime*Engines[j].iLine);
                                    // engine done
                                    iRet = 0;
                                    Engines[j].EngineDone = 1;
                                    Engines[j].iCountApogPerig = 0;
                                    SlS->TimeSl = SlS->TimeSlOld;
                                    CurentTimeSec = OldCurentTimeSec + Engines[j].ImplsPointer / Engines[j].IteraPerSec;
                                    CurentTimeTD = OldCurentTimeTD;
                                    CurentIteraPerSec = OldCurentIteraPerSec;
                                }
                            }
                        }
                        else
                        {
                            // skip firing engines which we are not interesting
                            if (j > LastEngine)
                                continue;
                            // engine is OFF
                            // SecCalc = CurentTimeSec * CurentIteraPerSec + CurentTimeTD;
                            SecCalc = ((double)CurentTimeSec) + ((double)CurentTimeTD) / ((double)CurentIteraPerSec);
                            if ((Engines[j].FireTime) <= SecCalc)
                            {
								unsigned char EngineColor[3]= {255,0,0};
								double X1 = Sat->X[j] - SolarSystem.X[EARTH];
								double Y1 = Sat->Y[j] - SolarSystem.Y[EARTH];
								double Z1 = Sat->Z[j] - SolarSystem.Z[EARTH];
								double X2;
								double Y2;
#ifdef _DO_VISUALIZATION
								switch(iProfile)
								{
									case 0: X2 = X1; Y2 = Y1;break; 
									case 1: X2 = Y1; Y2 = Z1;break; 
									case 2: X2 = X1; Y2 = Z1;break; 
									case 3: X2 = -Y1; Y2 = Z1;break;
									case 4: X2 = -X1; Y2 = Z1;break;
									case 5: X2 = -X1; Y2 = Y1;break; 
									default: break;
								}
								if (-dRGBScale < X2  && X2 < dRGBScale)
								{
									if (((-dRGBScale * bRGBImageH/ bRGBImageW) < Y2)  && Y2 < ((dRGBScale* bRGBImageH/ bRGBImageW)))
									{
										putpixel(&EngineColor[i*3], (int)(X2/dRGBScale*bRGBImageH), (int)(Y2/dRGBScale*bRGBImageH));
									}
								}
#endif
								printf("\n fire engine=====> %d at= %f",j,Engines[j].FireTime);
                                iRet = 1;
                                Engines[j].EngineOn = 1;
                                Engines[j].ImplsPointer = 0;
                                SlS->TimeSlOld = SlS->TimeSl;
                                SlS->TimeSl = Engines[j].DeltaTime;
                                OldCurentTimeSec = CurentTimeSec;
                                OldCurentTimeTD = CurentTimeTD;
                                OldCurentIteraPerSec = CurentIteraPerSec;
                                CurentTimeTD = 0;
                                CurentIteraPerSec = Engines[j].IteraPerSec;

                                // for now engine fire just in direction of a velocity around nearbody
                                double VX = Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[Engines[j].AngleOnBody];
                                double VY = Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[Engines[j].AngleOnBody];
                                double VZ = Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[Engines[j].AngleOnBody];
                                DTempo = sqrt(VX*VX+VY*VY+VZ*VX);
								// setting both vectors to 1.0 will fire engine in direction
								// ortogonal vector (not in direction of velocity)
								//if ((Engines[j].Ang1 == 1.0) && (Engines[j].Ang2 == 1.0))
                                if (Engines[j].AngleType == 4) // 4 - same direction as vector of velocity to nearbody // this is a brake impulse to land on the moon
                                {
                                    Engines[j].XVec = (Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[Engines[j].AngleOnBody]);
                                    Engines[j].YVec = (Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[Engines[j].AngleOnBody]);
                                    Engines[j].ZVec = (Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[Engines[j].AngleOnBody]);

                                }
                                if (Engines[j].AngleType == 3) // 3 - oposit vector of velocity
                                {
                                    Engines[j].XVec = -(Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[Engines[j].AngleOnBody]);
                                    Engines[j].YVec = -(Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[Engines[j].AngleOnBody]);
                                    Engines[j].ZVec = -(Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[Engines[j].AngleOnBody]);
                                }
                                if (Engines[j].AngleType == 0) // 0 - tangent line to orbit (elipse) oposit velocity  to nearbody
                                {
                                    //Engines[j].XVec = -VX;
                                    //Engines[j].YVec = -VY;
                                    //Engines[j].ZVec = -VZ;
                                    // equation of a plane perpendicular to a vector from center of earth to setelite
                                    // first calculates radius vector (R=(Xs,Ys,Zs)) of a satellite's point reletive to earth (P=(Xs,Yx,Zs))
                                    double Xs = Sat->X[Engines[j].iEngineOnSatellite] - SlS->X[Engines[j].AngleOnBody];
                                    double Ys = Sat->Y[Engines[j].iEngineOnSatellite] - SlS->Y[Engines[j].AngleOnBody];
                                    double Zs = Sat->Z[Engines[j].iEngineOnSatellite] - SlS->Z[Engines[j].AngleOnBody];
                                    // N = (A,B,C) is a normal to a plane (the needs to be in same direction of a radius vector)
                                    DTempo = sqrt(Xs*Xs+Ys*Ys+Zs*Zs);
                                    double Xn = Xs/DTempo;
                                    double Yn = Ys/DTempo;
                                    double Zn = Zs/DTempo;
                                    // PLane : A*(x-Xs) + B*(y-Ys) + C*(z-Zs) = 0
                                    // or Xn*(x-Xs) + Yn*(y-Ys) + Zn*(z-Zs) = 0
                                    // vector (Q=(Xq,Yq,Zq)) perpendicular to R and starting point is P, 4 equation:
                                    //(1)  (x - x1)(y2-y1) = (x2-x1)(y-y1) 
                                    //(2)  (y - y1)(z2-z1) = (y2-y1)(z-z1)
                                    //(3)  (z - z1)(x2-x1) = (z2-z1)(x-x1)
                                    //(4)  Xn*(x-Xs) + Yn*(y-Ys) + Zn*(z-Zs) = 0
                                    // for calculations:
                                    // first calculate 2 vector M1 and M2 ortogonal X and VX
                                    // (1) Xs*XM + Ys*YM + Zs*ZM = 0 => ZM = - (Xs*XM + Ys*YM)/ Zs
                                    // 
                                    // (2) VX*XM + VY*YM + VZ*ZM = 0 => VY*YM = - (VX*XM +VZ*ZM) => VY*YM = - (VX*XM -VZ*(Xs*XM + Ys*YM)/ Zs)
                                    // VY*YM = - ((VX*XM*Zs/Zs -VZ*(Xs*XM + Ys*YM)/ Zs)) => VY*YM = - (VX*XM*Zs -VZ*(Xs*XM + Ys*YM))/ Zs => VY*YM = - (VX*XM*Zs - VZ*Xs*XM - VZ*Ys*YM)/ Zs =>
                                    // VY*YM = - (VX*XM*Zs - VZ*Xs*XM)/ Zs + VZ*Ys*YM/ Zs => VY*YM - VZ*Ys*YM/ Zs = - (VX*XM*Zs - VZ*Xs*XM)/ Zs => YM*(VY*Zs - VZ*Ys)/ Zs = - (VX*XM*Zs - VZ*Xs*XM)/ Zs
                                    // YM*(VY*Zs - VZ*Ys) = - (VX*XM*Zs - VZ*Xs*XM) = > YM = - (VX*XM*Zs - VZ*Xs*XM)/(VY*Zs - VZ*Ys) => YM = - XM * (VX*Zs - VZ*Xs)/(VY*Zs - VZ*Ys)
                                    double XM =  1.0;
                                    double YM = - XM * (VX*Zs - VZ*Xs)/(VY*Zs - VZ*Ys);
                                    double ZM = - (Xs*XM + Ys*YM)/ Zs;
                                    // second calcualtes 2 vectors D1 D2 ortogonal to X and M1
                                    // (3) Xs*Xd + Ys*Yd + Zs*Zd = 0 => Zd = - (Xs*Xd + Ys*Yd)/Zs 
                                    //
                                    // (4) XM*Xd + YM*Yd + ZM*Zd = 0 => YM*Yd = -(XM*Xd + ZM*Zd) => YM*Yd = -(XM*Xd - ZM*(Xs*Xd + Ys*Yd)/Zs) => YM*Yd = -(XM*Xd*Zs - ZM*Xs*Xd - ZM*Ys*Yd)/Zs =>
                                    // YM*Yd = -(XM*Xd*Zs - ZM*Xs*Xd)/Zs + ZM*Ys*Yd/Zs => YM*Yd - ZM*Ys*Yd/Zs = -(XM*Xd*Zs - ZM*Xs*Xd)/Zs => Yd*(YM*Zs/Zs - ZM*Ys/Zs) = -(XM*Xd*Zs - ZM*Xs*Xd)/Zs
                                    // Yd*(YM*Zs - ZM*Ys) = -(XM*Xd*Zs - ZM*Xs*Xd) => Yd = -(XM*Xd*Zs - ZM*Xs*Xd)/(YM*Zs - ZM*Ys) => Yd = -Xd*(XM*Zs - ZM*Xs)/(YM*Zs - ZM*Ys)
                                    double Xd1 =  1.0;
                                    double Yd1 = -Xd1*(XM*Zs - ZM*Xs)/(YM*Zs - ZM*Ys);
                                    double Zd1 = - (Xs*Xd1 + Ys*Yd1)/Zs ;
                                    double Xd2 =  -1.0;
                                    double Yd2 = -Xd2*(XM*Zs - ZM*Xs)/(YM*Zs - ZM*Ys);
                                    double Zd2 = - (Xs*Xd2 + Ys*Yd2)/Zs ;
                                    // conformation: D and X are ortogonal and M and D is ortogonal
                                    DTempo = sqrt(Xs*Xd1+Ys*Yd1+Zs*Zd1);
                                    DTempo = sqrt(Xs*Xd2+Ys*Yd2+Zs*Zd2);
                                    DTempo = sqrt(Xs*XM+Ys*YM+Zs*ZM);
                                    // calculation - which of a vectors D1 or D2 close to vector of velocity
                                    // cos(alfa) = ( (x2 -x1)(x4-x3) + (y2-y1)(y4-y3) + (z2-z1)(z4-z3) )/ ( sqrt( (x2-x1)^2 + (y2-y1)^2 +(z2-z1)^2 )*sqrt( (x4-x3)^2 + (y4-y3)^2 +(z4-z3)^2 )
                                    double cosAlfa1 = (Xd1*VX + Yd1*VY + Zd1*VZ) / sqrt(Xd1*Xd1 + Yd1*Yd1+ Zd1*Zd1) / sqrt(VX*VX + VY*VY +VZ*VZ);
                                    double cosAlfa2 = (Xd2*VX + Yd2*VY + Zd2*VZ) / sqrt(Xd2*Xd2 + Yd2*Yd2+ Zd2*Zd2) / sqrt(VX*VX + VY*VY +VZ*VZ);

                                    if (cosAlfa1 < cosAlfa2)
                                    {
                                        Engines[j].XVec = -Xd2;
                                        Engines[j].YVec = -Yd2;
                                        Engines[j].ZVec = -Zd2;
                                    }
                                    else
                                    {
                                        Engines[j].XVec = -Xd1;
                                        Engines[j].YVec = -Yd1;
                                        Engines[j].ZVec = -Zd1;
                                    }
                                    if (j==4) // for a brake impulse into a vector of velociti around moon
                                    {
                                        //Engines[j].XVec = -(Sat->X[Engines[j].iEngineOnSatellite] - SlS->X[MOON]);
                                        //Engines[j].YVec = -(Sat->Y[Engines[j].iEngineOnSatellite] - SlS->Y[MOON]);
                                        //Engines[j].ZVec = -(Sat->Z[Engines[j].iEngineOnSatellite] - SlS->Z[MOON]);

                                        Engines[j].XVec = (Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[MOON]);
                                        Engines[j].YVec = (Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[MOON]);
                                        Engines[j].ZVec = (Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[MOON]);
                                    }
                                }
								//else if ((Engines[j].Ang1 != 0.0) && (Engines[j].Ang2 != 0.0))
                                else if (Engines[j].AngleType == 1) // 1 - two angles set with reference to NearBody centre direction
								{
								}
                                else if (Engines[j].AngleType == 2) // 2 - three angles set vector fire (constant all fire time) 
								{
									//Engines[j].XVec = 8;
                                    //Engines[j].YVec = 0;
                                    //Engines[j].ZVec = -16;
                                    Engines[j].XVec = Engines[j].XVec;
                                    Engines[j].YVec = Engines[j].YVec;
                                    Engines[j].ZVec = Engines[j].ZVec;
								}

                            }
                        }
                    }
                }
            }
        }
    }
    return (iRet);
}


long double TimeSl = 0;//0.01;
long double TimeSlOld = 0;//0.01;
long double TimeSl_2 = 0;

#define CALC_SOLAR_SYSTEM 1
void AssignFromNASAData(TRAOBJ * SlS, double JDSec)
{
    double aproxim;
    //double RBarisMoon;
    //double RBarisEarth;
    //double VEarthOrbit;
    //double VMoonOrbit;
    //double VDelta;
    double Temp0;
    double Temp1;
    double Temp2;
    double Temp3;
    double Temp4;

    stateType  State;
    double dEMRAT = Find_DataInHeader("EMRAT ");
    double dAU = Find_DataInHeader("AU    ")*1000.0;
	// store
	AU = dAU;
    SlS->Elem = 11;
    aproxim = 0.58782958984375;
    aproxim = 1.0;
    aproxim = 1.0;//1.0496393116944882060883002708885;
#define PlanetsCount SlS->Elem
//#define PlanetsCount PLANET_COUNT
    for (int i = 0; i < PlanetsCount; i++)
    {
        SlS->flInUse[i] = 1;        
        for (int j = 0; j < PlanetsCount; j++)
        {
            SlS->Distance2[i][j] = 0.0;
        }
        Interpolate_State( JDSec , i , &State );
        SlS->X[i] = State.Position[0]*1000.0;
        SlS->Y[i] = State.Position[1]*1000.0;
        SlS->Z[i] = State.Position[2]*1000.0;
        SlS->VX[i] = State.Velocity[0]*1000.0;
        SlS->VY[i] = State.Velocity[1]*1000.0;
        SlS->VZ[i] = State.Velocity[2]*1000.0;
        switch(i)
        {
        case 0: SlS->GM[i] = Find_DataInHeader("GM1   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 1: SlS->GM[i] = Find_DataInHeader("GM2   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 2: SlS->GM[i] = Find_DataInHeader("GMB   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);//*(dEMRAT)/(dEMRAT+1.0);
            SlS->GM[i] *=(dEMRAT)/(dEMRAT+1); 
            SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 3: SlS->GM[i] = Find_DataInHeader("GM4   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 4: SlS->GM[i] = Find_DataInHeader("GM5   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 5: SlS->GM[i] = Find_DataInHeader("GM6   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 6: SlS->GM[i] = Find_DataInHeader("GM7   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 7: SlS->GM[i] = Find_DataInHeader("GM8   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 8: SlS->GM[i] = Find_DataInHeader("GM9   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 9: SlS->GM[i] = Find_DataInHeader("GMB   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);
            SlS->GM[i] /=(dEMRAT+1); 
            SlS->M[i] = SlS->GM[i]/Gbig;
            {
                double BSX = SlS->X[EARTH];
                double BSY = SlS->Y[EARTH];
                double BSZ = SlS->Z[EARTH];
                double BSVX = SlS->VX[EARTH];
                double BSVY = SlS->VY[EARTH];
                double BSVZ = SlS->VZ[EARTH];
#if 0
                SlS->X[i] += SlS->X[EARTH];
                SlS->Y[i] += SlS->Y[EARTH];
                SlS->Z[i] += SlS->Z[EARTH];
                SlS->VX[i] += SlS->VX[EARTH];
                SlS->VY[i] += SlS->VY[EARTH];
                SlS->VZ[i] += SlS->VZ[EARTH];
#else
                SlS->X[EARTH] = BSX - (SlS->X[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                SlS->Y[EARTH] = BSY - (SlS->Y[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                SlS->Z[EARTH] = BSZ - (SlS->Z[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                Temp4 = sqrt(
                                (SlS->X[9])*(SlS->X[9])+
                                (SlS->Y[9])*(SlS->Y[9])+
                                (SlS->Z[9])*(SlS->Z[9])
                                );
                printf("\n D Earth - Moon %f ", Temp4);
                Temp1 = sqrt(
                                ((SlS->X[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9])))*
                                ((SlS->X[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9]))) +
                                ((SlS->Y[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9])))*
                                ((SlS->Y[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9]))) +
                                ((SlS->Z[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9])))*
                                ((SlS->Z[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9])))
                                );

                 printf("\n D BC  - Moon %f ", Temp1);
                 Temp1 = sqrt(
                                SlS->GM[2] / Temp1
                                );

                 Temp2 = sqrt(
                                (SlS->VX[9])*(SlS->VX[9])+
                                (SlS->VY[9])*(SlS->VY[9])+
                                (SlS->VZ[9])*(SlS->VZ[9])
                                );
                 Temp3 = Find_DataInHeader("GMB   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);
                 SlS->X[MOON] = SlS->X[EARTH] + SlS->X[MOON];
                 SlS->Y[MOON] = SlS->Y[EARTH] + SlS->Y[MOON];
                 SlS->Z[MOON] = SlS->Z[EARTH] + SlS->Z[MOON];

                 SlS->VX[EARTH] = BSVX - /*aproxim**/(SlS->VX[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                 SlS->VY[EARTH] = BSVY - /*aproxim**/(SlS->VY[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                 SlS->VZ[EARTH] = BSVZ - /*aproxim**/(SlS->VZ[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                 Temp0 = (/*aproxim**/(SlS->VX[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON])))*
                                (/*aproxim**/(SlS->VX[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]))) +
                                (/*aproxim**/(SlS->VY[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON])))*
                                (/*aproxim**/(SlS->VY[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]))) +
                                (/*aproxim**/(SlS->VZ[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON])))*
                                (/*aproxim**/(SlS->VZ[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON])));
                 SlS->VX[MOON] = SlS->VX[EARTH] + SlS->VX[MOON];
                 SlS->VY[MOON] = SlS->VY[EARTH] + SlS->VY[MOON];
                 SlS->VZ[MOON] = SlS->VZ[EARTH] + SlS->VZ[MOON];
#endif
            }
            break;
        case 10: SlS->GM[i] = Find_DataInHeader("GMS   ") *dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0); SlS->M[i] = SlS->GM[i]/Gbig;break;
        }
    }

    printf("\n Earth velocity =%f", sqrt(Temp0));
    printf("\n Moon sqrt =%f", Temp1);
    printf("\n Moon velocity N =%f", Temp2);

    // this is done to reduce errors and avid unnessary 5 mul/div operations
    // temporary X_, VX_ will just added (in paralel can be done actualy) 
    SlS->TimeSl = TimeSl;
    SlS->TimeSl_2 = TimeSl*TimeSl;
    for (int i = 0; i <SlS->Elem; i++)
    {
        SlS->VX_[i] = 0;
        SlS->VY_[i] = 0;
        SlS->VZ_[i] = 0;

        SlS->X_[i] = 0;
        SlS->Y_[i] = 0;
        SlS->Z_[i] = 0;

        SlS->X0divDt2[i]=SlS->X[i]* SlS->M[i] /SlS->TimeSl_2;
        SlS->Y0divDt2[i]=SlS->Y[i]* SlS->M[i] /SlS->TimeSl_2;
        SlS->Z0divDt2[i]=SlS->Z[i]* SlS->M[i] /SlS->TimeSl_2;

        SlS->VX0divDt[i]=SlS->VX[i]* SlS->M[i] /SlS->TimeSl;
        SlS->VY0divDt[i]=SlS->VY[i]* SlS->M[i] /SlS->TimeSl;
        SlS->VZ0divDt[i]=SlS->VZ[i]* SlS->M[i] /SlS->TimeSl;

        for (int j = 0; j < SlS->Elem; j++)
        {
            SlS->GMxM[i][j] = SlS->GM[i]*SlS->M[j];
        }
    }
    SlS->CountNx = 0; SlS->CountNy = 0; SlS->CountNz = 0;
    SlS->RunOne = TRUE;
}


// main engine to dump keplers elements as it is (no drag)
void DumpKeplers(long double &T,long double &Ecc, long double &Incl, long double &AssNode, long double &ArgPer, long double &MeanAnm, long double Mass, long double mass, 
                    long double &X, long double &Y, long double &Z, long double &VX, long double &VY, long double &VZ)
{
	// see http://www.projectpluto.com/source.htm or http://www.projectpluto.com/lunar.zip
	// code based on classel.cpp
	//const double *v = r + 3;
	//const double r_dot_v = r[0] * v[0] + r[1] * v[1] + r[2] * v[2];
	long double r_dot_v = X*VX + Y*VY + Z*VZ;
	//const double dist = sqrt( r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
	long double R = sqrt(X*X + Y*Y + Z*Z);
	//const double v2 = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
	long double Vsq = VX*VX + VY*VY + VZ*VZ;
	//const double inv_major_axis = 2. / dist - v2 / gm;
	long double GbigMass = Gbig * Mass;
	long double InvMAxis = 2.0 / R - Vsq / GbigMass;
	long double h0, n0;
	long double h[3], e[3], ecc2;
	long double ecc, perihelion_speed, gm_over_h0;
	int i;

	//h[0] = r[1] * v[2] - r[2] * v[1];
	h[0]   = Y * VZ   - Z * VY;
	//h[1] = r[2] * v[0] - r[0] * v[2];
	h[1] = Z * VX - X * VZ;
	// h[2] = r[0] * v[1] - r[1] * v[0];
	h[2] = X * VY - Y * VX;
	n0 = h[0] * h[0] + h[1] * h[1];
	h0 = n0 + h[2] * h[2];
	n0 = sqrt( n0);
	h0 = sqrt( h0);

	//elem->asc_node = atan2( h[0], -h[1]);
	AssNode= atan2( h[0], -h[1]);
	//if (AssNode < 0.0)
	//	AssNode = 2*M_PI + AssNode;
    // elem->incl = asine( n0 / h0);
	Incl = asin( n0 / h0);
    if( h[2] < 0.)                   /* retrograde orbit */
         Incl = M_PI - Incl;
	//e[0] = (v[1] * h[2] - v[2] * h[1]) / gm - r[0] / dist;
	e[0] = (VY * h[2] - VZ * h[1]) / GbigMass - X / R;
	//e[1] = (v[2] * h[0] - v[0] * h[2]) / gm - r[1] / dist;
	e[1] = (VZ * h[0] - VX * h[2]) / GbigMass - Y / R;
	//e[2] = (v[0] * h[1] - v[1] * h[0]) / gm - r[2] / dist;
	e[2] = (VX * h[1] - VY * h[0]) / GbigMass - Z / R;
	ecc2 = 0.;
	for( i = 0; i < 3; i++)
	{
		ecc2 += e[i] * e[i];
	}
	//elem->minor_to_major = sqrt( fabs( 1. - ecc2));
	long double BdivA = sqrt( abs( 1. - ecc2));
	//ecc = elem->ecc = sqrt( ecc2);
	ecc = Ecc = sqrt( ecc2);
	for( i = 0; i < 3; i++)
	{
		e[i] /= ecc;
	}
	gm_over_h0 = GbigMass / h0;
	//perihelion_speed = gm_over_h0 + sqrt( gm_over_h0 * gm_over_h0 - inv_major_axis * gm);
	perihelion_speed = gm_over_h0 + sqrt( gm_over_h0 * gm_over_h0 - InvMAxis * GbigMass);
	//elem->q = h0 / perihelion_speed;
	long double q = h0 / perihelion_speed;
	long double major_axis;
	long double t0;
	//long double perih_time;
	long double w0;
	if( InvMAxis)
    {
		//elem->major_axis = 1. / inv_major_axis;
		major_axis = 1. / InvMAxis;
		//elem->t0 = elem->major_axis * sqrt( fabs( elem->major_axis) / gm);
		t0 = major_axis * sqrt( abs( major_axis) / GbigMass);
		T = sqrt(4.0*M_PI*M_PI*abs(major_axis)*abs(major_axis)*abs(major_axis)/GbigMass);
		// or T = 2*PI*t0
		// from formula T*T = sqrt(4*pi^2*a^3/(G*m))
    }
	const long double cos_arg_per = (h[0] * e[1] - h[1] * e[0]) / n0;

	if( cos_arg_per < .7 && cos_arg_per > -.7)
		ArgPer = acos( cos_arg_per);
	else
    {
		const long double sin_arg_per = (e[0] * h[0] * h[2] + e[1] * h[1] * h[2] - e[2] * n0 * n0) / (n0 * h0);
		if (n0 * h0)
		{
			ArgPer = abs( asin( sin_arg_per));
			if( cos_arg_per < 0.)
				ArgPer = M_PI - ArgPer;
		}
		else
			ArgPer = 0.0;

	}
	if( e[2] < 0.)
		ArgPer = M_PI + M_PI - ArgPer;

	if( InvMAxis > 0.)         /* elliptical case */
    {
		const long double e_cos_E = 1. - R * InvMAxis;
		const long double e_sin_E = r_dot_v / sqrt( GbigMass * major_axis);
		const long double ecc_anom = atan2( e_sin_E, e_cos_E);

		MeanAnm = ecc_anom - ecc * sin( ecc_anom);
/*    elem->t0 = elem->major_axis * sqrt( elem->major_axis / gm);   */
		//elem->perih_time = t - elem->mean_anomaly * elem->t0;
		//perih_time = t - MeanAnm * t0;
	}
	else if( InvMAxis < 0.)         /* hyperbolic case */
    {
		const long double z = (1. - R * InvMAxis) / ecc;
		long double f = log( z + sqrt( z * z - 1.));

		if( r_dot_v < 0.)
			f = -f;
		MeanAnm = ecc * sinh( f) - f;
		//elem->perih_time = t - elem->mean_anomaly * fabs( elem->t0);
		//perih_time = t - MeanAnm * abs( t0);
		h0 = -h0;
	}
	else              /* parabolic case */
    {
		long double tau;

		tau = sqrt( R / q - 1.);
		if( r_dot_v < 0.)
			tau = -tau;
		w0 = (3. / M_SQRT2) / (q * sqrt( q / GbigMass));
/*    elem->perih_time = t - tau * (tau * tau / 3. + 1) *                   */
/*                                      elem->q * sqrt( 2. * elem->q / gm); */
	    //elem->perih_time = t - tau * (tau * tau / 3. + 1) * 3. / elem->w0;
		//perih_time = t - tau * (tau * tau / 3. + 1) * 3. / w0;
    }

	//for( i = 0; i < 3; i++)
	//	elem->perih_vec[i] = e[i];
	//elem->sideways[0] = (e[2] * h[1] - e[1] * h[2]) / h0;
	//elem->sideways[1] = (e[0] * h[2] - e[2] * h[0]) / h0;
	//elem->sideways[2] = (e[1] * h[0] - e[0] * h[1]) / h0;
	//elem->angular_momentum = h0;
}

//A brief header is given below:
//
//Des'n     H     G   Epoch     M        Peri.      Node       Incl.       e            n           a        Reference #Obs #Opp    Arc    rms  Perts   Computer
//
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//00001    3.34  0.12 K118R 199.31747   72.44742   80.37910   10.58595  0.0785634  0.21418897   2.7665466  0 MPO110568  6063  94 1802-2006 0.61 M-v 30h MPCW       0000      (1) Ceres              20061025
//00002    4.13  0.11 K118R 181.70142  310.06331  173.12644   34.84160  0.2312416  0.21365561   2.7711488  0 MPO135420  7253  93 1827-2008 0.59 M-v 28h MPCW       0000      (2) Pallas             20080101
//00003    5.33  0.32 K118R 122.32357  248.18733  169.91025   12.98086  0.2551627  0.22576192   2.6711744  0 MPO135420  6278  91 1824-2008 0.60 M-v 38h MPCW       0000      (3) Juno               20080308
//00004    3.20  0.32 K118R  56.40276  149.88186  103.90428    7.13461  0.0883124  0.27164416   2.3612165  0 MPO135420  6449  82 1827-2007 0.60 M-v 18h MPCW       0000      (4) Vesta              20070808
//00005    6.85  0.15 K118R 334.02337  358.78351  141.61007    5.36742  0.1903560  0.23868879   2.5738390  0 MPO 41498  2178 100 1845-2002 0.56 M-v 38h Goffin     0000      (5) Astraea            20021114
//00006    5.71  0.24 K118R  76.23230  239.28896  138.72650   14.75022  0.2022525  0.26104401   2.4247124  0 MPO135420  5011  81 1848-2008 0.55 M-v 38h MPCW       0007      (6) Hebe               20080222
//00007    5.51  0.15 K118R 111.53561  145.26277  259.65080    5.52306  0.2305428  0.26737788   2.3862672  0 MPO135420  4443  76 1848-2008 0.60 M-v 38h MPCW       0000      (7) Iris               20080308
//00008    6.49  0.28 K118R  70.05922  285.18420  110.93525    5.88786  0.1564761  0.30182794   2.2010492  0 MPO 25662  2438 102 1847-2000 0.54 M-v 38h Goffin     0000      (8) Flora              20001115
//00009    6.28  0.17 K118R 248.44234    6.24383   68.94919    5.57547  0.1227453  0.26749937   2.3855446  0 MPO 25662  2131  96 1822-2001 0.54 M-v 38h Goffin     0000      (9) Metis              20011024
//00010    5.43  0.15 K118R  15.29657  313.01188  283.41502    3.84094  0.1164623  0.17722252   3.1389913  0 MPC 35055  2261 104 1849-1999 0.53 M-v 38h Goffin     0000     (10) Hygiea             19990306
//00011    6.55  0.15 K118R 281.05531  195.04403  125.60104    4.62566  0.0990377  0.25651561   2.4531655  0 MPO135420  3974  82 1850-2007 0.63 M-v 38h MPCW       0000     (11) Parthenope         20070725
//00012    7.24  0.22 K118R  79.04846   69.82359  235.48673    8.36699  0.2207436  0.27628481   2.3347016  0 MPO 57621  2635  86 1850-2003 0.56 M-v 38h Goffin     0000     (12) Victoria           20030921
//00013    6.74  0.15 K118R 240.86929   80.14640   43.27015   16.54560  0.0853678  0.23830803   2.5765798  0 MPO  2601   946  54 1850-2000 0.77 M-v 38h Williams   0000     (13) Egeria             20000131
//00014    6.30  0.15 K118R 221.96593   97.35232   86.20615    9.10849  0.1656321  0.23651727   2.5895689  0 MPO   595  1765  84 1851-2000 0.54 M-v 38h Goffin     0000     (14) Irene              20000402
//00015    5.28  0.23 K118R   2.13972   97.67316  293.21965   11.73525  0.1886022  0.22924203   2.6440716  0 MPO 25662  2071  91 1851-2001 0.52 M-v 38h Goffin     0000     (15) Eunomia            20010712
//00016    5.90  0.20 K118R  98.10135  226.95821  150.29920    3.09929  0.1374216  0.19745426   2.9207320  0 MPC 35055  1831  96 1852-1998 0.53 M-v 38h Goffin     0000     (16) Psyche             19980614

//this function transformed from original code to cross check another functions
void setup_orbit_vectors( long double &e_epoch, long double &e_ecc, long double &e_incl, long double &e_asc_node, long double &e_arg_per,long double &e_mean_anomaly,
	long double &e_q, long double &e_major_axis,long double &e_t0,long double &e_w0,long double &e_angular_momentum,long double &e_perih_time,
	long double &e_minor_to_major, long double &e_lon_per,
	long double &e_sideways_x, long double &e_sideways_y, long double &e_sideways_z,
	long double &vec_x, long double &vec_y,long double &vec_z,long double gm)
{
   long double sin_incl = sin( e_incl), cos_incl = cos( e_incl);
   //double *vec;
   long double vec_len;
   //double up[3];
   long double up_x, up_y, up_z;
   //int i;

   e_minor_to_major = sqrt( abs( (long double)1. - e_ecc * e_ecc));
   e_lon_per = e_asc_node + atan2( sin( e_arg_per) * cos_incl,
                                       cos( e_arg_per));
   //vec = e->perih_vec;

   vec_x = cos( e_lon_per);
   vec_y = sin( e_lon_per);
   vec_z = (sin_incl / cos_incl) * sin( e_lon_per - e_asc_node);
   //vec_len = sqrt( 1. + vec[2] * vec[2]);
   vec_len = sqrt( 1. + vec_z * vec_z);
   //for( i = 0; i < 3; i++)
   //   vec[i] /= vec_len;
   vec_x /= vec_len;
   vec_y /= vec_len;
   vec_z /= vec_len;
            /* 'up' is a vector perpendicular to the plane of the orbit */
   up_x =  sin( e_asc_node) * sin_incl;
   up_y = -cos( e_asc_node) * sin_incl;
   up_z = cos_incl;

   e_sideways_x = up_y * vec_z - up_z * vec_y;
   e_sideways_y = up_z * vec_x - up_x * vec_z;
   e_sideways_z = up_x * vec_y - up_y * vec_x;
}
// this function transformed from original code to cross check another functions
void derive_quantities( long double &e_epoch, long double &e_ecc, long double &e_incl, long double &e_asc_node, long double &e_arg_per,long double &e_mean_anomaly,
	long double &e_q, long double &e_major_axis,long double &e_t0,long double &e_w0,long double &e_angular_momentum,long double &e_perih_time,
	long double &e_minor_to_major, long double &e_lon_per,
	long double &e_sideways_x, long double &e_sideways_y, long double &e_sideways_z,
	long double &vec_x, long double &vec_y,long double &vec_z,long double gm)
{
   if( e_ecc != 1.)    /* for non-parabolic orbits: */
      {
      e_major_axis = e_q / abs(1. - e_ecc);
      e_t0 = e_major_axis * sqrt( e_major_axis / gm);
      }
   else
      {
      e_w0 = (3. / sqrt((long double)2.0)) / (e_q * sqrt( e_q / gm));
      e_major_axis = e_t0 = 0.;
      }
  //setup_orbit_vectors( e);
}
// this function transformed from original code to cross check another functions
void do_element_setup( long double &e_epoch, long double &e_ecc, long double &e_incl, long double &e_asc_node, long double &e_arg_per,long double &e_mean_anomaly,
	long double &e_q, long double &e_major_axis,long double &e_t0,long double &e_w0,long double &e_angular_momentum,long double &e_perih_time,
	long double &e_minor_to_major, long double &e_lon_per,
	long double &e_sideways_x, long double &e_sideways_y, long double &e_sideways_z,
	long double &vec_x, long double &vec_y,long double &vec_z,long double gm, long double T)
{
	//elem->mean_anomaly  *= PI / 180.;
	//elem->arg_per       *= PI / 180.;
	//elem->asc_node      *= PI / 180.;
	//elem->incl          *= PI / 180.;
	long double Temp = (((gm * T * T / 4.0) / M_PI) / M_PI);
    long double A = pow(Temp, (long double)1.0 / (long double)3.0);

    //A= EarthSmAx;
    long double B = A * sqrt(1.0 - e_ecc * e_ecc);
	e_major_axis =  A;
	e_q = e_major_axis * (1. - e_ecc);
	//derive_quantities( elem, gm);
	if( e_ecc != 1.)    /* for non-parabolic orbits: */
	{
		e_major_axis = e_q / abs(1. - e_ecc);
		e_t0 = e_major_axis * sqrt( e_major_axis / gm);
    }
	else
    {
		e_w0 = (3. / sqrt((long double)2.0)) / (e_q * sqrt( e_q / gm));
		e_major_axis = e_t0 = 0.;
    }
	//setup_orbit_vectors( e);
	{
		long double sin_incl = sin( e_incl), cos_incl = cos( e_incl);
		//double *vec;
		long double vec_len;
		//double up[3];
		long double up_x, up_y, up_z;
		//int i;

		e_minor_to_major = sqrt( abs( (long double)1. - e_ecc * e_ecc));
		e_lon_per = e_asc_node + atan2( sin( e_arg_per) * cos_incl,
                                       cos( e_arg_per));
		//vec = e->perih_vec;

		vec_x = cos( e_lon_per);
		vec_y = sin( e_lon_per);
		vec_z = (sin_incl / cos_incl) * sin( e_lon_per - e_asc_node);
		//vec_len = sqrt( 1. + vec[2] * vec[2]);
		vec_len = sqrt( 1. + vec_z * vec_z);
		//for( i = 0; i < 3; i++)
		//   vec[i] /= vec_len;
		vec_x /= vec_len;
		vec_y /= vec_len;
		vec_z /= vec_len;
            /* 'up' is a vector perpendicular to the plane of the orbit */
		up_x =  sin( e_asc_node) * sin_incl;
		up_y = -cos( e_asc_node) * sin_incl;
		up_z = cos_incl;

		e_sideways_x = up_y * vec_z - up_z * vec_y;
		e_sideways_y = up_z * vec_x - up_x * vec_z;
		e_sideways_z = up_x * vec_y - up_y * vec_x;
	}   
	e_angular_momentum = sqrt( gm * e_q * (1. + e_ecc));
	e_perih_time = e_epoch - e_mean_anomaly * e_t0;
	//e_is_asteroid = 1;
	//elem->central_obj = 0;
}


#define MAX_ITERATIONS 7
long double asinh( long double z)
{
   return( log( z + sqrt( z * z + 1.)));
}
long double near_parabolic( long double ecc_anom, long double e)
{
   long double anom2 = (e > 1. ? ecc_anom * ecc_anom : -ecc_anom * ecc_anom);
   long double term = e * anom2 * ecc_anom / 6.;
   long double rval = (1. - e) * ecc_anom - term;
   int n = 4;

   while( fabs( term) > 1e-15)
      {
      term *= anom2 / (double)(n * (n + 1));
      rval -= term;
      n += 2;
      }
   return( rval);
}

#define THRESH 1.e-8
#define MIN_THRESH 1.e-15
// from the same source - good sample of a keplers solution
long double kepler(long double ecc, long double mean_anom)
{
   long double curr, err, thresh, offset = 0.;
   long double delta_curr = 1.;
   int is_negative = 0, n_iter = 0;

   if( !mean_anom)
      return( 0.);

   if( ecc < .3)     /* low-eccentricity formula from Meeus,  p. 195 */
      {
      curr = atan2( sin( mean_anom), cos( mean_anom) - ecc);
            /* two correction steps,  and we're done */
      for( n_iter = 2; n_iter; n_iter--)
         {
         err = curr - ecc * sin( curr) - mean_anom;
         curr -= err / (1. - ecc * cos( curr));
         }
      return( curr);
      }

   if( ecc < 1.)
      if( mean_anom < -M_PI || mean_anom > M_PI)
         {
         double tmod = fmod( mean_anom, (long double)M_PI * (long double)2.);

         if( tmod > M_PI)             /* bring mean anom within -pi to +pi */
            tmod -= 2. * M_PI;
         else if( tmod < -M_PI)
            tmod += 2. * M_PI;
         offset = mean_anom - tmod;
         mean_anom = tmod;
         }

   if( mean_anom < 0.)
      {
      mean_anom = -mean_anom;
      is_negative = 1;
      }

   curr = mean_anom;
   thresh = THRESH * fabs( 1. - ecc);
               /* Due to roundoff error,  there's no way we can hope to */
               /* get below a certain minimum threshhold anyway:        */
   if( thresh < MIN_THRESH)
      thresh = MIN_THRESH;
   if( (ecc > .8 && mean_anom < M_PI / 3.) || ecc > 1.)    /* up to 60 degrees */
      {
      double trial = mean_anom / fabs( 1. - ecc);

      if( trial * trial > 6. * fabs(1. - ecc))   /* cubic term is dominant */
         {
         if( mean_anom < M_PI)
            trial = pow( 6. * mean_anom,(long double)1.0/(long double)3.0);
         else        /* hyperbolic w/ 5th & higher-order terms predominant */
            trial = asinh( mean_anom / ecc);
         }
      curr = trial;
      }
   if( ecc > 1. && mean_anom > 4.)    /* hyperbolic, large-mean-anomaly case */
      curr = log( mean_anom);

   if( ecc < 1.)
      while( fabs( delta_curr) > thresh)
         {
         if( n_iter++ > MAX_ITERATIONS)
            err = near_parabolic( curr, ecc) - mean_anom;
         else
            err = curr - ecc * sin( curr) - mean_anom;
         delta_curr = -err / (1. - ecc * cos( curr));
         curr += delta_curr;
         }
   else
      while( fabs( delta_curr) > thresh)
         {
         if( n_iter++ > MAX_ITERATIONS)
            err = -near_parabolic( curr, ecc) - mean_anom;
         else
            err = ecc * sinh( curr) - curr - mean_anom;
         delta_curr = -err / (ecc * cosh( curr) - 1.);
         curr += delta_curr;
         }
   return( is_negative ? offset - curr : offset + curr);
}

// this function transformed from original code to cross check another functions
int posn_and_vel( long double &e_epoch, long double &e_ecc, long double &e_incl, long double &e_asc_node, long double &e_arg_per,long double &e_mean_anomaly,
	long double &e_q, long double &e_major_axis,long double &e_t0,long double &e_w0,long double &e_angular_momentum,long double &e_perih_time,
	long double &e_minor_to_major, long double &e_lon_per,
	long double &e_sideways_x, long double &e_sideways_y, long double &e_sideways_z,
	long double &e_perih_vec_x,long double &e_perih_vec_y,long double &e_perih_vec_z,
	long double &loc_x, long double &loc_y, long double &loc_z, long double &loc_r,long double &vel_x,long double &vel_y,long double &vel_z,long double t, long double gm)
{
	t -= e_perih_time;
	if( e_ecc != 1.)    /* not parabolic */
	{
		t /= e_t0;
		if( e_ecc < 1.)     /* elliptical case;  throw out extra orbits */
        {                    /* to fit mean anom between -PI and PI */
			t = fmod( (long double)t, (long double)M_PI * 2.);
			if( t < -M_PI) t += 2. * M_PI;
			if( t >  M_PI) t -= 2. * M_PI;
		}
		e_mean_anomaly = t;
	}
	//posn_part_ii( elem, t, loc, vel);
	{
		long double true_anom, r, x, y, r0;

		if( e_ecc == 1.)    /* parabolic */
		{
			long double g = e_w0 * t * .5;

			y = pow( g + sqrt( g * g + 1.), (long double)1.0/ (long double)3.0);
			true_anom = 2. * atan( y - 1. / y);
		}
		else           /* got the mean anomaly;  compute eccentric,  then true */
		{
			long double ecc_anom;

			ecc_anom = kepler( e_ecc, e_mean_anomaly);
			if( e_ecc > 1.)     /* hyperbolic case */
			{
				x = (e_ecc - cosh( ecc_anom));
				y = sinh( ecc_anom);
			}
			else           /* elliptical case */
			{
				x = (cos( ecc_anom) - e_ecc);
				y =  sin( ecc_anom);
			}
			y *= e_minor_to_major;
			true_anom = atan2( y, x);
		}

		r0 = e_q * (1. + e_ecc);
		r = r0 / (1. + e_ecc * cos( true_anom));
		x = r * cos( true_anom);
		y = r * sin( true_anom);
		loc_x = e_perih_vec_x * x + e_sideways_x * y;
		loc_y = e_perih_vec_y * x + e_sideways_y * y;
		loc_z = e_perih_vec_z * x + e_sideways_z * y;
		loc_r = r;
		//if( vel && (elem->angular_momentum != 0.))
		{
			long double angular_component = e_angular_momentum / (r * r);
			long double radial_component = e_ecc * sin( true_anom) *
                                e_angular_momentum / (r * r0);
			long double x1 = x * radial_component - y * angular_component;
			long double y1 = y * radial_component + x * angular_component;
			//int i;

			//for( i = 0; i < 3; i++)
			//   vel[i] = elem->perih_vec[i] * x1 + elem->sideways[i] * y1;
			vel_x = e_perih_vec_x * x1 + e_sideways_x * y1;
			vel_y = e_perih_vec_y * x1 + e_sideways_y * y1;
			vel_z = e_perih_vec_z * x1 + e_sideways_z * y1;
		}
	}

   return( 0);
}
// today value is in Gbig * Mass = 398600441499999.87 in m**3/s**2
//#define BIG_XKE 7.43669161331734132e-2

// was based in SGP4 on G=398600.8 km**3/s**2
//#define R0_MODEL 6378136.30

#define BIG_XKE .743669161E-1


// see http://www.amsat.org/amsat/keps/kepmodel.html
// or http://en.wikipedia.org/wiki/Orbital_elements
//    SatEpoch  - satellite epoch
//    T         - orbit period in sec 
//                 for Mean Motion (revolutions/day) needs T = 60*60*24 / Mean_Motion
//    Ecc       - Eccentricity
//    Incl      - Inclination
//    AssNode   - Longitude of ascending node (where the orbit passes upward through the reference plane)
//    ArgPer    - Argument of perihelion angle to per (lower point) point
//    MeanAnm   - Mean Anomaly (degrees)
//    Mass      - Mass of first body
//    mass      - Mass of second body
//                assuming:
//     Z  - pointed up
//     Y  - to right
//     X  - to point of view
//
//                or:
//     Z  - point north from ecliptic
//     X  - to easter
//     Y  - to point of view
// XY plain is equatorial plain for earth's satellites, or for planets it is a ecliptic 
// plane (the plane of the Earth's orbit around the Sun). In both cases X points to easter/
// this function now does not care about drag - which is bad 
void KeplerPosition(long double SatEpoch, long double CurTime, long double T,long double Ecc, long double Incl, long double AssNode, long double ArgPer, long double MeanAnm, long double BSTAR, long double GM, int doCorrection, 
                    long double &Xm, long double &Ym, long double &Zm, long double &VX, long double &VY, long double &VZ, long double ProbMeanMotion)
{
    long double XMNPDA_XMNPDA = 24.0*60.0*60.0;//1440.0; // XMNPDA time units(minutes) /day 1440.0
	long double XMNPDA = 24.0*60.0;//1440.0; // XMNPDA time units(minutes) /day 1440.0
	long double TEMP_=2*M_PI/XMNPDA/XMNPDA; // 2*pi / (1440 **2)
	long double TEMP_TEMP_=2*M_PI/XMNPDA_XMNPDA/XMNPDA_XMNPDA; // 2*pi / (1440 **2)
	long double XNO=ProbMeanMotion*TEMP_*XMNPDA; // rotation per day * 2*pi /1440 == rotation per day on 1 unit (1 min/sec)
	long double XNO_XNO=ProbMeanMotion*TEMP_TEMP_*XMNPDA_XMNPDA; // rotation per day * 2*pi /1440 == rotation per day on 1 unit (1 min/sec)
	long double XKE = BIG_XKE;//.743669161E-1;
	long double XKMPER = 6378.1350;
	//IF (IFLAG .EQ. 0) GO TO 100
	//* RECOVER ORIGINAL MEAN MOTION (XNODP) AND SEMIMAJOR AXIS (AODP)
	//* FROM INPUT ELEMENTS
	//A1=(XKE/XNO)**TOTHRD;
	long double XJ2 = 1.082616E-3;
	long double XJ3 = -.253881E-5;
	long double XJ4 = -1.65597E-6;
	long double AE = 1.0;
	long double QO =120.0;
	long double SO = 78.0;

	long double CK2=.5*XJ2*AE*AE;
	//CK4=-.375*XJ4*AE**4
	long double CK4=-.375*XJ4*AE*AE*AE*AE;
	long double QOMS2T=pow(((QO-SO)*AE/XKMPER),(long double)4.0);
	long double S=AE*(1.+SO/XKMPER);
	//A1=(XKE/XNO)**TOTHRD;
	long double A1=pow((XKE/XNO),(long double)2.0/(long double)3.0);
	long double A1_A1=pow((XKE/XNO_XNO),(long double)2.0/(long double)3.0);
	long double COSIO=cos(Incl);
	long double THETA2=COSIO*COSIO;
	long double X3THM1=3.*THETA2-1.;
	long double EOSQ=Ecc*Ecc;
	long double BETAO2=1.-EOSQ;
	long double BETAO=sqrt(BETAO2);
	long double DEL1=1.5*CK2*X3THM1/(A1*A1*BETAO*BETAO2);
	//AO=A1*(1.-DEL1*(.5*TOTHRD+DEL1*(1.+134./81.*DEL1)))
	long double AO=A1*(1.-DEL1*(.5*(2.0/3.0)+DEL1*(1.+134./81.*DEL1)));
	long double DELO=1.5*CK2*X3THM1/(AO*AO*BETAO*BETAO2);
    // ProbMeanMotion = XNO / (2*pi) * 1440.0
	long double XNODP=XNO/(1.+DELO);
    if (doCorrection)
    {
        T = 1.0/ (XNODP / M_PI/2.0 * 1440.0) * 24.0 * 60.0 * 60.0;
    }
    // and this is a semimajor axis
	long double AODP=AO/(1.-DELO);
    if (doCorrection)
    {
    }
	//* INITIALIZATION
	//* FOR PERIGEE LESS THAN 220 KILOMETERS, THE ISIMP FLAG IS SET AND
	//* THE EQUATIONS ARE TRUNCATED TO LINEAR VARIATION IN SQRT A AND
	//* QUADRATIC VARIATION IN MEAN ANOMALY. ALSO, THE C3 TERM, THE
	//* DELTA OMEGA TERM, AND THE DELTA M TERM ARE DROPPED.
	int ISIMP=0;
	//IF((AODP*(1.-EO)/AE) .LT. (220./XKMPER+AE)) ISIMP=1
	if((AODP*(1.-Ecc)/AE) < (220./XKMPER+AE)) 
		ISIMP=1;
	//* FOR PERIGEE BELOW 156 KM, THE VALUES OF
	//* S AND QOMS2T ARE ALTERED
	long double S4=S;
	long double QOMS24=QOMS2T;
	long double PERIGE=(AODP*(1.-Ecc)-AE)*XKMPER;
	//IF(PERIGE .GE. 156.) GO TO 10
	if (PERIGE >= 156.) 
		goto M_10;
	S4=PERIGE-78.;
	//IF(PERIGE .GT. 98.) GO TO 9
	if (PERIGE >=98.) 
		goto M_9;
	S4=20.;
M_9:
	//QOMS24=((120.-S4)*AE/XKMPER)**4;
	QOMS24=pow(((120.-S4)*AE/XKMPER),4);
	S4=S4/XKMPER+AE;
M_16:
M_10:
	long double PINVSQ=1./(AODP*AODP*BETAO2*BETAO2);
	long double TSI=1./(AODP-S4);
	long double ETA=AODP*Ecc*TSI;
	long double ETASQ=ETA*ETA;
	long double EETA=Ecc*ETA;
	long double PSISQ=abs(1.-ETASQ);
	//COEF=QOMS24*TSI**4
	long double COEF=QOMS24*TSI*TSI*TSI*TSI;
	//COEF1=COEF/PSISQ**3.5;
	long double COEF1=COEF/pow(PSISQ,(long double)3.5);

	long double C2=COEF1*XNODP*(AODP*(1.+1.5*ETASQ+EETA*(4.+ETASQ))+.75* CK2*TSI/PSISQ*X3THM1*(8.+3.*ETASQ*(8.+ETASQ)));
	long double C1=BSTAR*C2;
	long double SINIO=sin(Incl);
	//A3OVK2=-XJ3/CK2*AE**3;
	long double A3OVK2=-XJ3/CK2*(AE*AE*AE);
	long double C3=COEF*TSI*A3OVK2*XNODP*AE*SINIO/Ecc;
	long double X1MTH2=1.-THETA2;
	long double C4=2.*XNODP*COEF1*AODP*BETAO2*(ETA*(2.+.5*ETASQ)+Ecc*(.5+2.*ETASQ)-2.*CK2*TSI/
			(AODP*PSISQ)*(-3.*X3THM1*(1.-2.*EETA+ETASQ* (1.5-.5*EETA))+.75*X1MTH2*(2.*ETASQ-EETA* (1.+ETASQ))*cos(2.*ArgPer)));
	long double C5=2.*COEF1*AODP*BETAO2*(1.+2.75*(ETASQ+EETA)+EETA*ETASQ);
	long double THETA4=THETA2*THETA2;
	long double TEMP1=3.*CK2*PINVSQ*XNODP;
	long double TEMP2=TEMP1*CK2*PINVSQ;
	long double TEMP3=1.25*CK4*PINVSQ*PINVSQ*XNODP;
	long double XMDOT=XNODP+.5*TEMP1*BETAO*X3THM1+.0625*TEMP2*BETAO* (13.-78.*THETA2+137.*THETA4);
	long double X1M5TH=1.-5.*THETA2;
	long double OMGDOT=-.5*TEMP1*X1M5TH+.0625*TEMP2*(7.-114.*THETA2+ 395.*THETA4)+TEMP3*(3.-36.*THETA2+49.*THETA4);
	long double XHDOT1=-TEMP1*COSIO;
	long double XNODOT=XHDOT1+(.5*TEMP2*(4.-19.*THETA2)+2.*TEMP3*(3.-7.*THETA2))*COSIO;
	long double OMGCOF=BSTAR*C3*cos(ArgPer);
	long double XMCOF=-(2.0/3.0)*COEF*BSTAR*AE/EETA;
	long double XNODCF=3.5*BETAO2*XHDOT1*C1;
	long double T2COF=1.5*C1;
	long double XLCOF=.125*A3OVK2*SINIO*(3.+5.*COSIO)/(1.+COSIO);
	long double AYCOF=.25*A3OVK2*SINIO;
	//DELMO=(1.+ETA*COS(XMO))**3
	long double DELMO=pow((1.+ETA*cos(MeanAnm)),3);
	long double SINMO=sin(MeanAnm);
	long double X7THM1=7.*THETA2-1.;
	// IF(ISIMP .EQ. 1) GO TO 90
	if (ISIMP == 1) 
		goto M_90;
	long double C1SQ=C1*C1;
	long double D2=4.*AODP*TSI*C1SQ;
	long double TEMP=D2*TSI*C1/3.;
	long double D3=(17.*AODP+S4)*TEMP;
	long double D4=.5*TEMP*AODP*TSI*(221.*AODP+31.*S4)*C1;
M_17:
	long double T3COF=D2+2.*C1SQ;
	long double T4COF=.25*(3.*D3+C1*(12.*D2+10.*C1SQ));
	long double T5COF=.2*(3.*D4+12.*C1*D3+6.*D2*D2+15.*C1SQ*(2.*D2+C1SQ));
M_90:
	//IFLAG=0;
	//* UPDATE FOR SECULAR GRAVITY AND ATMOSPHERIC DRAG
M_100:
    long double TSINCE = (CurTime - SatEpoch)*(24.0 * 60.0* 60.0);
	long double XMDF=MeanAnm+XMDOT*TSINCE;
	long double OMGADF=ArgPer+OMGDOT*TSINCE;
	long double XNODDF=AssNode+XNODOT*TSINCE;
	long double OMEGA=OMGADF;
	long double XMP=XMDF;
	long double TSQ=TSINCE*TSINCE;
	long double XNODE=XNODDF+XNODCF*TSQ;
	long double TEMPA=1.-C1*TSINCE;
	long double TEMPE=BSTAR*C4*TSINCE;
	long double TEMPL=T2COF*TSQ;
	// IF(ISIMP .EQ. 1) GO TO 110
	if (ISIMP == 1) 
		goto M_110;
	long double DELOMG=OMGCOF*TSINCE;
	// DELM=XMCOF*((1.+ETA*COS(XMDF))**3-DELMO)
	long double DELM=XMCOF*(pow((1.+ETA*cos(XMDF)),3)-DELMO);
	TEMP=DELOMG+DELM;
	XMP=XMDF+TEMP;
	OMEGA=OMGADF-TEMP;
	long double TCUBE=TSQ*TSINCE;
	long double TFOUR=TSINCE*TCUBE;
	TEMPA=TEMPA-D2*TSQ-D3*TCUBE-D4*TFOUR;
	TEMPE=TEMPE+BSTAR*C5*(sin(XMP)-SINMO);
	TEMPL=TEMPL+T3COF*TCUBE+TFOUR*(T4COF+TSINCE*T5COF);
M_110:
	//A=AODP*TEMPA**2;
	//long double A=AODP*TEMPA*TEMPA;
	long double Eee=Ecc-TEMPE;



    long double Omega0 = ArgPer;

	long double TettaDelta = 0.0;

    // Tetta = contrclockwise angle from perihelion
	// Mean Anomaly
    // [aka "M0" or "MA" or "Phase"]
	// 	Mean anomaly is simply an angle that marches uniformly in time from 0 to 360 degrees during one revolution. It is defined to be 0 degrees at perigee, and therefore is 180 degrees at apogee. 
	// The mean anomaly increases uniformly from 0 to 2*PI() radians during each orbit. However, it is not an angle. 
	// Due to Kepler's second law, the mean anomaly is proportional to the area swept by the focus-to-body line since the last periapsis.
    // The mean anomaly is usually denoted by the letter M, and is given by the formula
	// cos(TrueAnomaly) = (cos(E) - e) / (1 - e*cos(E))
	// and E - is a essentric anomaly formula is:
	// M = E - e*sin(E) 
	// first calculates how many orbits was done from a epoche time till current moment of time
	TettaDelta = CurTime - SatEpoch;
	TettaDelta  *= (24.0 * 60.0 * 60.0);
	TettaDelta /= T;
	int iTettaDelta = (int)TettaDelta;
	TettaDelta -= iTettaDelta;
    TettaDelta *= T;
    TettaDelta /= 24.0*60.0*60.0;
	TettaDelta *= 2.0 * M_PI;


	long double M = MeanAnm + TettaDelta;
    if (doCorrection)
    {
        //M = XMP;
        Ecc = Eee;
        //ArgPer = OMEGA;
        //AssNode = XNODE;
    }
    //// find E
    long double E = M;
    long double ENext = E - Ecc * sin(E);
    long double DeltaE = abs(ENext - M);
	long double PresM = abs(M) * 1.0E-15;
	int iAdditionalAttempts = 3;
    while (iAdditionalAttempts > 0)
    {
        ENext = E - Ecc * sin(E);
        DeltaE = abs(ENext - M);
		if (PresM >= DeltaE)
			iAdditionalAttempts--;
	
		E = E - ( ENext - M) /2;
    }

	long double CosPhi = (cos(E) - Ecc)/(1.0 -Ecc*cos(E));



	long double Tetta = acos(CosPhi);
	// for conformation see: http://www.jgiesen.de/kepler/kepler.html
    
	// first calulate a = (G*M1*T*T/(4*Pi*Pi))in power 1/3
    long double Temp = ((((GM * T * T) / 4.0) / M_PI) / M_PI);
    long double A = pow(Temp, (long double)1.0 / (long double)3.0);

    //A= EarthSmAx;
    long double B = A * sqrt(1.0 - Ecc * Ecc);

    //printf("\n Calc A      = %f", A);
	// calulates R
    // X - pointed right and to perihelion
    // Y - pointed down
    // Z is not in use X-Y is a orbit plain
    // see pic1.bmp
    long double R = (B * B / ( 1.0 + Ecc * cos(Tetta))) / A;
    long double X0 = R*cos(Tetta);
	long double Y0 = R*sin(Tetta);
	long double Z0 = 0.0;

    long double VR = sqrt(((GM))*A/B/B) * Ecc * sin(Tetta);
    long double VN = sqrt(((GM))*A/B/B) * (1.0 +Ecc *cos(Tetta));

    int DirectionContrClock = 1;

    if (AssNode >=0.0 && AssNode < M_PI)
        DirectionContrClock = 0;
    long double VXm0;
    long double VYm0;
    long double VZm0;
    long double M_TrAnom[4]={-1,1,1,1};
	long double M_argper[4] = {1,-1,1,1};
	long double M_incl[4] = {1,-1,1,1};
	long double M_AsNode[4] = {1,-1,1,1};
    //if (DirectionContrClock)
    //{
    //    VXm0 =  -sin(Tetta) * VN - cos(Tetta) * VR;//- cos(Tetta) * VN + sin(Tetta) * VR;// - cos(Tetta) * VN + sin(Tetta) * VR;
    //    VYm0 = cos(Tetta) * VN - sin(Tetta) * VR;//- sin(Tetta) * VN - cos(Tetta) * VR;//  sin(Tetta) * VN - cos(Tetta) * VR;
    //    VZm0 = 0.0;
    //
    //}
    //else
    {
        VXm0 = M_TrAnom[0]*sin(Tetta) * VN + M_TrAnom[1]*cos(Tetta) * VR;
        VYm0 = M_TrAnom[2]*cos(Tetta) * VN + M_TrAnom[3]*sin(Tetta) * VR;
        VZm0 = 0.0;
    }

    // perihelium direction adjust:
    // rotation vector (X0,Y0) by angle omega clockwise will get vector (X1,Y1)
    //
    
    long double X1 = X0 * cos(ArgPer) - Y0 * sin(ArgPer);
    long double Y1 = X0 * sin(ArgPer) + Y0 * cos(ArgPer);
    long double Z1 = Z0;

    long double VXm1 = M_argper[0]*VXm0 * cos(ArgPer) + M_argper[1]* VYm0 * sin(ArgPer);
    long double VYm1 = M_argper[2]*VXm0 * sin(ArgPer) + M_argper[3]*VYm0 * cos(ArgPer);
    long double VZm1 = VZm0;

    // inclanation direction adjust 
    // incl (satellite) = incl
    long double X2 = X1;
    long double Y2 = Y1 * cos(Incl) - Z1 * sin(Incl);
    long double Z2 = Y1 * sin(Incl) + Z1 * cos(Incl);;

    long double VXm2 = VXm1;
    long double VYm2 = M_incl[0]*VYm1 * cos(Incl) + M_incl[1]* VZm1 * sin(Incl);
    long double VZm2 = M_incl[2]*VYm1 * sin(Incl) + M_incl[3]*VZm1 * cos(Incl);

    // Assending Node last opartion 
    long double X3 = X2 * cos(AssNode) - Y2 * sin(AssNode);
    long double Y3 = X2 * sin(AssNode) + Y2 * cos(AssNode);
    long double Z3 = Z2;

    long double VXm3 = M_AsNode[0]*VXm2 * cos(AssNode) + M_AsNode[1]*VYm2 * sin(AssNode);
    long double VYm3 = M_AsNode[2]*VXm2 * sin(AssNode) + M_AsNode[3]*VYm2 * cos(AssNode);
    long double VZm3 = VZm2;

    Xm = X3;
    Ym = Y3;
    Zm = Z3;
	
    VX = VXm3;
    VY = VYm3;
    VZ = VZm3;
}
double ConvertDateTimeToTLEEpoch(int iDay, int iMonth, int iYear, int iHour, int iMin, int iSec, int iMills);
long double ConvertJulianDayToDateAndTime(double JulianDay, SYSTEMTIME *ThatTime)
{
    long daysfrom2000 = (long)(JulianDay - 2451544.5); // noon 1 jan 2000
    long double flInDay = (JulianDay - 2451544.5) - (long double)daysfrom2000; 
    long double RetTime = flInDay;
    flInDay += 1.0/(60.0*60.0*24.0*1000); // last one is for rounding milliseconds
    int iYear = 0;
    daysfrom2000 += 1; // 1Jan must be 1;
    while (daysfrom2000 > 366)
    {
        switch(iYear)
        {
        case 24:daysfrom2000-=366;break;
        case 23:daysfrom2000-=365;break;
        case 22:daysfrom2000-=365;break;
        case 21:daysfrom2000-=365;break;
        case 20:daysfrom2000-=366;break;
        case 19:daysfrom2000-=365;break;
        case 18:daysfrom2000-=365;break;
        case 17:daysfrom2000-=365;break;
        case 16:daysfrom2000-=366;break;
        case 15:daysfrom2000-=365;break;
        case 14:daysfrom2000-=365;break;
        case 13:daysfrom2000-=365;break;
        case 12:daysfrom2000-=366;break;
        case 11:daysfrom2000-=365;break;
        case 10:daysfrom2000-=365;break;
        case 9:daysfrom2000-=365;break;
        case 8:daysfrom2000-=366;break;
        case 7:daysfrom2000-=365;break;
        case 6:daysfrom2000-=365;break;
        case 5:daysfrom2000-=365;break;
        case 4:daysfrom2000-=366;break;
        case 3:daysfrom2000-=365;break;
        case 2:daysfrom2000-=365;break;
        case 1:daysfrom2000-=365;break;
        case 0:daysfrom2000-=366;break;
        }
        iYear++;
    }
    ThatTime->wYear = iYear+2000;
    int iMonth =1;
    int iComp, iDecr;
    int DaysFromTheBeginigOfTheYear= daysfrom2000;  // 1 Jan is 0 day == but in TLE 01/01/00 00:00:00 will be 00001.00000
    while(1)
    {
        switch(iMonth)
        {
        case 1: iComp = 31; iDecr = 31; break; // jan
        case 2: if (iYear%4 ==0) //leap year    //feb
                {
                    iComp = 29; iDecr = 29;
                }
                else
                {
                    iComp = 28; iDecr = 28;
                }
                break;
        case 3: iComp = 31; iDecr = 31; break; // mar
        case 4: iComp = 30; iDecr = 30; break; // apr
        case 5: iComp = 31; iDecr = 31; break; // may
        case 6: iComp = 30; iDecr = 30; break; // jun
        case 7: iComp = 31; iDecr = 31; break; //jul
        case 8: iComp = 31; iDecr = 31; break; // aug
        case 9: iComp = 30; iDecr = 30; break; //sep
        case 10: iComp = 31; iDecr = 31; break; // oct
        case 11: iComp = 30; iDecr = 30; break; // nov
        }
        if (daysfrom2000 < iComp)
                break;
        daysfrom2000 -=iDecr;
        if (++iMonth == 12) // what ?? getout!!!
            break;
    }
    int iDay  = daysfrom2000;//+1;
    
    int iHour = (int)(flInDay*24);
    int iMinutes = ((flInDay - ((double)iHour)/24.0))*(24.0*60.0);
    int iSec =  (int)( ((flInDay - ((double)iHour)/24.0) - ((double)iMinutes)/(24.0*60.0))*(24.0*60.0*60.0));
    int iMils = (int)((flInDay - ((double)iHour)/(24.0) - ((double)iMinutes)/(24.0*60.0) - ((double)iSec)/(24.0*60.0*60.0))*(24.0*60.0*60.0*1000.0));
    ThatTime->wMonth = iMonth;
    ThatTime->wDay = iDay;
    ThatTime->wHour = iHour;
    ThatTime->wMinute = iMinutes;
    ThatTime->wSecond = iSec;
    ThatTime->wMilliseconds = iMils;
    ThatTime->wDayOfWeek = 0;
    //RetTime += (long double)DaysFromTheBeginigOfTheYear + (long double)(iYear*1000);//-1.0/(60.0*60.0*24.0*1000);
    return ConvertDateTimeToTLEEpoch(ThatTime->wDay, ThatTime->wMonth, ThatTime->wYear, ThatTime->wHour, ThatTime->wMinute, ThatTime->wSecond, ThatTime->wMilliseconds);
}
long double ConverTLEEpochDate2JulianDay(long double KeplerDate)
{
    // TLE elements is 1 day based - needs to minus at the end one day
    int iYear = (int)(KeplerDate /1000);
    // date as it is = 2000/01/01     2451544.5, 2451910.5, 2452275.5, 2452640.5, 2453005.5, 2453371.5, 2453736.5, 2013-2456293.5
    // 
    double t2000_01_01_01 = 2451544.5;
    switch(iYear)
    {
        // add years = if you still alive !!! or just put formula if ((iYear-1)%4 == 0) t2000_01_01_01+=366; else t2000_01_01_01+=365;
    case 24:t2000_01_01_01+=365;
    case 23:t2000_01_01_01+=365;
    case 22:t2000_01_01_01+=365;
    case 21:t2000_01_01_01+=366;
    case 20:t2000_01_01_01+=365;
    case 19:t2000_01_01_01+=365;
    case 18:t2000_01_01_01+=365;
    case 17:t2000_01_01_01+=366;
    case 16:t2000_01_01_01+=365;
    case 15:t2000_01_01_01+=365;
    case 14:t2000_01_01_01+=365;
    case 13:t2000_01_01_01+=366;
    case 12:t2000_01_01_01+=365;
    case 11:t2000_01_01_01+=365;
    case 10:t2000_01_01_01+=365;
    case  9:t2000_01_01_01+=366;
    case  8:t2000_01_01_01+=365;
    case  7:t2000_01_01_01+=365;
    case  6:t2000_01_01_01+=365;
    case  5:t2000_01_01_01+=366;
    case  4:t2000_01_01_01+=365;
    case  3:t2000_01_01_01+=365;
    case  2:t2000_01_01_01+=365;
    case  1:t2000_01_01_01+=366;
    case  0:;
        // minus years = add if you interesting in anything from last century or use formala!!
    }
    //long it2000_01_01_01 = t2000_01_01_01;
    //double RestOfTheDay = t2000_01_01_01 - (double)it2000_01_01_01;
    return t2000_01_01_01// - RestOfTheDay 
            + KeplerDate - ((long double)(iYear*1000))
            -1; // epoch date is 1== 1 Jan - needs to adjust one day.
}


int iDayOfTheYearZeroBase(int iDay, int iMonth, int iYear)
{
	int iDays = iDay-1;
	switch(iMonth-1)
	{
	case 11:// november
		iDays+=30;
	case 10:// october
		iDays+=31;
	case 9:// september
		iDays+=30;
	case 8://august
		iDays+=31;
	case 7:// july
		iDays+=31;
	case 6:// june
		iDays+=30;
	case 5:// may
		iDays+=31;
	case 4:// april
		iDays+=30;
	case 3:// march
		iDays+=31;
	case 2:// february
		if ((iYear %4) ==0) // leap year
			iDays+=29;
		else
			iDays+=28;
	case 1:iDays+=31; // january
	case 0:iDays+=0;
		break;
	}
	return iDays;
}
double ConvertDateTimeToTLEEpoch(int iDay, int iMonth, int iYear, int iHour, int iMin, int iSec, int iMills)
{
    // An epoch of 98001.00000000 corresponds to 0000 UT on 1998 January 01in other words, 
    // midnight between 1997 December 31 and 1998 January 01. 
    // An epoch of 98000.00000000 would actually correspond to the beginning of 1997 December 31strange as that might seem. 
    // Note that the epoch day starts at UT midnight (not noon) and that all times are measured mean solar rather than sidereal time units.
    int mYear = iYear-2000;
    int mDays = iDayOfTheYearZeroBase(iDay, iMonth, iYear)+1;
	long mCurSec = iHour * 60*60;
    mCurSec += iMin *60;
    mCurSec += iSec;
	double dEpoch = mYear *1000.0 + mDays;
	dEpoch += (((double)mCurSec)+ ((double)iMills/1000.))/ (24.0*60.0*60.0);
    return dEpoch;
}

long double SubEpoch(long double One, long double Two)
{
    int Y1 = (int)(One /1000);
    int Y2 = (int)(Two /1000);
    if (Y1 < 20)
        Y1 +=100;
    if (Y2 < 20)
        Y2+=100;
    int N1=(Y1-69)/4;
	if (Y1 < 70) 
		N1=(Y1-72)/4;
    int N2=(Y2-69)/4;
	if (Y2 < 70) 
		N2=(Y2-72)/4;
    if (Y1-Y2 != 0) 
    {
        return ( (Y1-Y2-1)* 365.0 + (N1 - N2) + (One - Y1*1000.0) + (365 - Two + Y2*1000.0));
    }
    else
    {
        return One - Two;
    }
}
char szURLTraVisualFileName[3*_MAX_PATH];
char szURLTraVisualServer[3*_MAX_PATH];
char szTraVisualFileName[_MAX_PATH*3]={"travisual.xml"};
int UrlTraVisualPort=80;
BOOL VisualFileSet = FALSE;
BOOL ParsURL(char * URLServer, int *port, char* URL,  char * szParsingName)
{
    char sztemp[3*_MAX_PATH];
    *port=80;
    strcpy(URL,szParsingName);
    //strcpy(szTraVisualFileName, "@travisual.xml");
    strcpy(URLServer,URL);
    char *iFirst = strstr(URLServer,"http://");
    if (iFirst)
    {
        iFirst += 7;
        iFirst = strstr(iFirst,"/");
        if (iFirst)
        {
            *iFirst++=0;
            strcpy(URL,iFirst);
            iFirst = strstr(&URLServer[7],":");
            if (iFirst)  // found :8080 port number
            {
                *port = atoi(iFirst+1);
                *iFirst =  0;
            }
            strcpy(sztemp,&URLServer[7]);
            strcpy(URLServer,sztemp);
        }
        else
        {
            printf(" URL:%s is wrong", szParsingName);
            exit(3);
        }
        return TRUE;
    }
    return FALSE;
}
void ConvertDateFromXML(char *pszQuo, long double &ld_TotalDays, long double &ld_dStartJD, long double &ld_dStartTLEEpoch)
{
    ld_TotalDays = 0;
    ld_dStartJD = atof(pszQuo);    // format: <TRA:setting name="dStartJD0" value="2455625.1696833" />
    if (ld_dStartJD <=0) // negativge value set current date munis amount of the minutes (negative -3 mean = total time == 3 minutes starting from curent time)
    {                 // i.e. -60 = total 60 minutes starting from -57 min, and 3 minutes in a future
        SYSTEMTIME MyTime;
        TIME_ZONE_INFORMATION tmzone;
        //SYSTEMTIME ThatTime;

        int Iret = GetTimeZoneInformation(&tmzone); 
        GetSystemTime(&MyTime);
        //double dEpoch = ConvertDateTimeToTLEEpoch(1, 1, 2013, 0, 0, 0, 0);
        //dStartJD = ConverTLEEpochDate2JulianDay(dEpoch);
         double dEpoch = ConvertDateTimeToTLEEpoch(MyTime.wDay, MyTime.wMonth, MyTime.wYear, MyTime.wHour, MyTime.wMinute, MyTime.wSecond, MyTime.wMilliseconds);
         ld_dStartJD = ConverTLEEpochDate2JulianDay(dEpoch);
				
        ld_TotalDays = (60.0*atof(pszQuo))/(24.0*60.0*60);
        // negative value !!! + 3 minutes
        ld_dStartJD +=ld_TotalDays + (60.0*dMinFromNow)/(24.0*60.0*60);
    }
    else
    {
        int iYear = (int)(ld_dStartJD/1000);
        if ((iYear > 0) && (iYear < 24)) // this is a <TRA:setting name="dStartJD" value="11291.79166666" />
        {
            ld_dStartJD = ConverTLEEpochDate2JulianDay(ld_dStartJD);
        }
        else
        {                     // 012345678901234567890
            if (ld_dStartJD<=31) // DD/MM/YY HH:MM:SS:MLS format
            {
                int iDD = atoi(&pszQuo[0]);
                int iMO = atoi(&pszQuo[3]);
                int iYY = atoi(&pszQuo[6]);
                int iHH = atoi(&pszQuo[9]);
                int iMM = atoi(&pszQuo[12]);
                int iSS = atoi(&pszQuo[15]);
                int iMLS = atoi(&pszQuo[18]);
                double dTLEEpoch = ConvertDateTimeToTLEEpoch(iDD, iMO, iYY+2000, iHH, iMM, iSS,iMLS);
                //int iDays = iDayOfTheYearZeroBase(iDD, iMO, iYY+2000);
                //int iCurSec = iHH * 60*60;
                //iCurSec += iMM *60;
				//iCurSec += iSS;
				//dStartJD = iYY *1000.0 + iDays;
				//dStartJD += (((double)iCurSec)+ ((double)iMLS/1000.))/ (24.0*60.0*60.0);
				//dStartJD = ConverEpochDate2JulianDay(dStartJD);
                ld_dStartJD = ConverTLEEpochDate2JulianDay(dTLEEpoch);
            }
            else // in a normal format
            {
            }
        }
    }
    SYSTEMTIME ThatTime;
    ld_dStartTLEEpoch = ConvertJulianDayToDateAndTime(ld_dStartJD, &ThatTime);
}
// rotate any point around vector on a angle 
void RotationAngleVect(long double &X, long double &Y, long double &Z, long double Angle, long double VectX, long double VectY, long double VectZ)
{
	// see http://en.wikipedia.org/wiki/Rotation_matrix

	// first make sure that Vector around rotation is a unit vector
	long double dLength = sqrt(VectX*VectX + VectY*VectY + VectZ*VectZ);
	VectX /= dLength;
	VectY /= dLength;
	VectZ /= dLength;
	long double RotX = (cos(Angle) + VectX*VectX*(1-cos(Angle)))*X +
		          (VectX*VectY*(1-cos(Angle)) - VectZ*sin(Angle)) * Y +
				  (VectX*VectZ*(1-cos(Angle)) + VectY*sin(Angle)) *Z;

	long double RotY = (VectY*VectX*(1-cos(Angle)) + VectZ*sin(Angle))*X +
		          (cos(Angle) + VectY*VectY*(1-cos(Angle)))*Y +
				  (VectY*VectZ*(1-cos(Angle)) - VectX*sin(Angle))*Z;

	long double RotZ = (VectZ*VectX*(1-cos(Angle)) - VectY*sin(Angle))*X+
		          (VectZ*VectY*(1-cos(Angle)) + VectX*sin(Angle))*Y+
				  (cos(Angle) + VectZ*VectZ*(1-cos(Angle)))*Z;
	X = RotX;
	Y = RotY;
	Z = RotZ;
}
// calculates angle btw vectors
long double AngleBtw(long double X1,long double Y1,long double Z1,long double X2,long double Y2,long double Z2)
{
	long double v1Len = sqrt(X1*X1 + Y1*Y1 + Z1*Z1);
	long double v2Len = sqrt(X2*X2 + Y2*Y2 + Z2*Z2);
	long double Cosv1v2 = (X1*X2 + Y1*Y2 + Z1*Z2)/v1Len/v2Len;
	long double Angle = acos(Cosv1v2);
	return (Angle * 180 /M_PI);
}
long double AngleBtwNorm(long double X1,long double Y1,long double Z1,long double X2,long double Y2,long double Z2)
{
	long double v1Len = 1.0;
	long double v2Len = 1.0;
	long double Cosv1v2 = (X1*X2 + Y1*Y2 + Z1*Z2)/v1Len/v2Len;
	long double Angle = acos(Cosv1v2);
	return Angle;
}

// calculates ortogonal vector
void Ort(long double &Xpr, long double &Ypr, long double &Zpr, long double u1, long double u2, long double u3, long double v1, long double v2, long double v3)
{
    Xpr = u2*v3 - u3*v2;
    Ypr = u3*v1 - u1*v3;
    Zpr = u1*v2-u2*v1;
    double prMod = sqrt(Xpr*Xpr + Ypr*Ypr +Zpr*Zpr);
    Xpr/=prMod;Ypr/=prMod;Zpr/=prMod;
}
void SUN_08 (int IYEAR,int IDAY,int IHOUR,int MIN,int ISEC,
	long double &GST,long double &SLONG,long double &SRASN,long double &SDEC)
{
	//C*******************************************************************
	//c
	//      SUBROUTINE SUN_08 (IYEAR,IDAY,IHOUR,MIN,ISEC,GST,SLONG,SRASN,SDEC)
	//C
	//C  CALCULATES FOUR QUANTITIES NECESSARY FOR COORDINATE TRANSFORMATIONS
	//C  WHICH DEPEND ON SUN POSITION (AND, HENCE, ON UNIVERSAL TIME AND SEASON)
	//C
	//C-------  INPUT PARAMETERS:
	//C  IYR,IDAY,IHOUR,MIN,ISEC -  YEAR, DAY, AND UNIVERSAL TIME IN HOURS, MINUTES,
	//C    AND SECONDS  (IDAY=1 CORRESPONDS TO JANUARY 1).
	//C
	//C-------  OUTPUT PARAMETERS:
	//C  GST - GREENWICH MEAN SIDEREAL TIME, SLONG - LONGITUDE ALONG ECLIPTIC
	//C  SRASN - RIGHT ASCENSION,  SDEC - DECLINATION  OF THE SUN (RADIANS)
	//C  ORIGINAL VERSION OF THIS SUBROUTINE HAS BEEN COMPILED FROM:
	//C  RUSSELL, C.T., COSMIC ELECTRODYNAMICS, 1971, V.2, PP.184-196.
	//C
	//C  LAST MODIFICATION:  MARCH 31, 2003 (ONLY SOME NOTATION CHANGES)
	//C
	//C     ORIGINAL VERSION WRITTEN BY:    Gilbert D. Mead
	//C
    long double DJ,FDAY;
    long double RAD = 180.0/M_PI;//57.295779513;
	//C
    //IF(IYEAR.LT.1901.OR.IYEAR.GT.2099) RETURN
	if(IYEAR < 1901 || IYEAR>2099) 
		return;
    FDAY=(IHOUR*3600.0+MIN*60.0+ISEC)/86400.0;
    DJ=365*(IYEAR-1900)+(IYEAR-1901)/4+IDAY-0.5+FDAY;
    long double T=DJ/36525.0;
    long double VL=fmod((long double)279.696678+(long double)0.9856473354*(long double)DJ,(long double)360.0);
    GST=fmod((long double)279.690983+(long double)0.9856473354*(long double)DJ+(long double)360.0*FDAY+(long double)180.0,(long double)360.0)/RAD;
    long double G=fmod((long double)358.475845+(long double)0.985600267*(long double)DJ,(long double)360.0)/RAD;
    SLONG=(VL+(1.91946-0.004789*T)*sin(G)+0.020094*sin(2.0*G))/RAD;
    //IF(SLONG.GT.6.2831853) SLONG=SLONG-6.2831853
	if(SLONG > (M_PI*2))//6.2831853) 
		SLONG=SLONG-(M_PI*2);//6.2831853;
    //IF (SLONG.LT.0.) SLONG=SLONG+6.2831853
	if (SLONG < 0.0) 
		SLONG=SLONG+(M_PI*2);//6.2831853;
    long double OBLIQ=(23.45229-0.0130125*T)/RAD;
    long double SOB=sin(OBLIQ);
    long double SLP=SLONG-9.924E-5;
	//C
	//C   THE LAST CONSTANT IS A CORRECTION FOR THE ANGULAR ABERRATION DUE TO
	//C   EARTH'S ORBITAL MOTION
	//C
    long double SIND=SOB*sin(SLP);
    long double COSD=sqrt((long double)1.-SIND*SIND);
    long double SC=SIND/COSD;
    SDEC=atan(SC);
    SRASN=M_PI-atan2(cos(OBLIQ)/SOB*SC,-cos(SLP)/COSD);
    //RETURN
    //  END
}
/*
FUNCTION ACTAN(SINX,COSX)
COMMON/C2/DE2RA,PI,PIO2,TWOPI,X3PIO2
ACTAN=0.
IF (COSX.EQ.0. ) GO TO 5
IF (COSX.GT.0. ) GO TO 1
ACTAN=PI
GO TO 7
1 IF (SINX.EQ.0. ) GO TO 8
IF (SINX.GT.0. ) GO TO 7
ACTAN=TWOPI
GO TO 7
5 IF (SINX.EQ.0. ) GO TO 8
IF (SINX.GT.0. ) GO TO 6
ACTAN=X3PIO2
GO TO 8
6 ACTAN=PIO2
GO TO 8
7 TEMP=SINX/COSX
ACTAN=ACTAN+ATAN(TEMP)
8 RETURN
END
*/
/*
FUNCTION FMOD2P(X)
COMMON/C2/DE2RA,PI,PIO2,TWOPI,X3PIO2
FMOD2P=X
I=FMOD2P/TWOPI
FMOD2P=FMOD2P-I*TWOPI
IF(FMOD2P.LT.0) FMOD2P=FMOD2P+TWOPI
RETURN
END
*/
// The function subroutine THETAG is passed the epoch time exactly as it appears on the input element cards.
// The routine converts this time to days since 1950 Jan 0.0 UTC, stores this in the COMMON E1,
// and returns the right ascension of Greenwich at epoch (in radians).

// usefull: http://en.wikipedia.org/wiki/Equation_of_time
//          http://www2.arnes.si/~gljsentvid10/sidereal.htm
//          http://www.iausofa.org/2001_0331/sofa/eqeq94.for
//          http://www.iausofa.org/2001_0331/sofa/gmst82.for
//          http://misc.gis.tu-berlin.de/igg/htdocs-kw/fileadmin/Daten_MCA/EM1/bsp.pdf
//          http://misc.gis.tu-berlin.de/igg/htdocs-kw/fileadmin/Daten_MCA/EM1/a6.pdf

long double GreenwichAscensionFromTLEEpoch(long double EP, long double &preEps, long double &preTetta, long double &preZ, long double &nutEpsilon, long double &nutDFeta)
{
    
	//FUNCTION THETAG(EP)
	//COMMON /E1/XMO,XNODEO,OMEGAO,EO,XINCL,XNO,XNDT2O,XNDD6O,BSTAR,
	//1 X,Y,Z,XDOT,YDOT,ZDOT,EPOCH,DS50
	//DOUBLE PRECISION EPOCH,D,THETA,TWOPI,YR,TEMP,EP,DS50
	long double EPOCH,D,THETA,TWOPI,YR,TEMP,DS50;
    long double THETAG;
    long double DaysFromJ2000;
    long iDaysFromJ2000;
    long double PartOfTheDay;
    long double CenturyFromJ2000;

    long double Tstar;
    long double dFeta,dEpsilon;
    long double _Epsilon;
    long double H0;
    long double DeltaH;
    // J000 == 2451545,0 JD == 01/Jan/2000 12:00

	TWOPI=2.0*M_PI;//6.28318530717959D0
	YR=(EP+2.e-7)*1.e-3;
	int JY=(int)(YR);
    
	YR=JY;
	D=EP-YR*1.e3;
	//IF(JY.LT.10) JY=JY+80
    preEps = 0;
    preTetta = 0;
    preZ = 0;

#if 1    
    if (JY < 20) // just from J2000 == 
    {
        // from J2000:
        // 24110.54841sec / 12/60/60 * M_PI= 1.7533685592332655129130610478964 
        //8640184.812866
        // 
        int N;
        if (JY == 0)
            N = 0;
        else 
            N = (JY-1)/4+1;
        // tle epoch jan 1 (0 day of the year) is the day number 1 and noon is 0.5 day (has to be minused)
        // also it referce as d0
        DaysFromJ2000=365.0*(JY) +N + D-1.0-0.5;  
        // that is integer value of d0 the days
        iDaysFromJ2000= (long)(DaysFromJ2000);
        // that is also T0 == d0/36525
        CenturyFromJ2000 = DaysFromJ2000/36525.0;
        // that is Tstar==Deltat == (JD( at 0 hour of day ) - JD (J2000 at 12 hour UT))/36525
        Tstar =(((long double)iDaysFromJ2000)+0.5)/36525.0;
        PartOfTheDay = D - (double long)(long)D;
        // from https://www2.mps.mpg.de/homes/fraenz/systems/systems2art/node3.html
        dFeta = -0.0048*sin((125-0.05295*DaysFromJ2000)*M_PI/180) - 0.0004*cos((200.9 +1.97129*DaysFromJ2000)*M_PI/180);
        dEpsilon = 0.0026 * cos((125-0.05295*DaysFromJ2000)*M_PI/180) - 0.0002*sin((200.9 +1.97129*DaysFromJ2000)*M_PI/180);
        //dFeta = dFeta *M_PI / 180;
        // Epsilon = _Epsilon + dEpsilon (page 12 from http://www.scharmn.narod.ru/AVD/bookAES2nn.pdf) 
        _Epsilon = 23.43921111 + (-0.013004167 + (-0.000000164 - 0.000000504*Tstar)*Tstar)*Tstar;
        nutEpsilon = _Epsilon + dEpsilon;
        nutEpsilon = nutEpsilon *M_PI / 180;
        nutDFeta = dFeta *M_PI / 180;
        DeltaH = dFeta * cos(nutEpsilon)/360.0;
        //H0 = 24110.54841 + (8640184.812866 + (0.093104- 6.2e-10*Tstar)*Tstar)*Tstar +   (PartOfTheDay-DeltaH)*86401.84812866;//86636.555367908688 // wrong!!!
        //H0 = 24110.54841 + (8640184.812866 + (0.093104- 6.2e-10*Tstar)*Tstar)*Tstar +   (PartOfTheDay-DeltaH)*86636.555367908688;//
        //H0 = 24110.54841 + (8640184.812866 + (0.093104- 6.2e-10*Tstar)*Tstar)*Tstar +   (PartOfTheDay-DeltaH)*86636.555367908577283124054644656;
        H0 = 24110.54841 + (8640184.812866 + (0.093104- 6.2e-10*Tstar)*Tstar)*Tstar +   (1.002737909350795+(5.9006e-11 -5.9E-15*Tstar)*Tstar)*86400*(PartOfTheDay-DeltaH);//*86401.84812866;//86636.555367908688
        THETAG = H0/86400 * 2.0*M_PI;
        THETAG =fmod(THETAG, (long double)2.0*M_PI);
        preEps = (2306.2181 + (0.30188 + 0.017998*Tstar)*Tstar)*Tstar; // in seconds
        preTetta = (2004.3109  + (0.42665 - 0.041833*Tstar)* Tstar)*Tstar; // in seconds
        preZ = preEps + (0.79280 + 0.018203* Tstar)* Tstar*Tstar;  // in seconds
        // now in radians;
        preEps = preEps *M_PI / (180*60*60);
        preTetta = preTetta * M_PI / (180*60*60);
        preZ = preZ * M_PI*2 / (180*60*60);
        return THETAG;
    }
#endif
	if(JY < 20) 
		JY=JY+100;
	int N=(JY-69)/4;
	//IF(JY.LT.70) N=(JY-72)/4
	if (JY < 70) 
		N=(JY-72)/4;
	DS50=7305.0 + 365.0*(JY-70) +N + D;
    // 6.3003880987 = 1.0027379093054531539043156765359
    // 1.9801110581855904429828570117483 it is bigger then 1.72944494 (==in days = 0.27524971100626634345509703401275 in sec= 23781.575030941412074520383738702)
    // difference from J2000 is 328.9733790585879254796162612984 sec == 5min+28.9733790585879254796162612984sec
    // difference in 
    // i.e 8640184.812866*Tstar + 0.093104*Tstar*Tstar- 6.2e-10*Tstar*Tstar*Tstar ==1239946.4147585845
    // 
	THETA=1.72944494 + 6.3003880987*DS50;
    
	TEMP=THETA/TWOPI;
	int I=(int)(TEMP);
	TEMP=I;
	THETAG=THETA-TEMP*TWOPI;
	//IF(THETAG.LT.0.D0) THETAG=THETAG+TWOPI
	if(THETAG < 0.0) 
		THETAG=THETAG+TWOPI;
	return THETAG;
	//RETURN
	//END
}
// in FORTARN variable with a name begining with I is an integer variable 
// The function subroutine FMOD2P is
// passed an angle in radians and returns the angle in radians within the range of 0 to 2 PI.
long double FMOD2P(long double X)
{
	// COMMON/C2/DE2RA,PI,PIO2,TWOPI,X3PIO2
	//double DE2RA,PI,PIO2,TWOPI,X3PIO2;
	long double FMOD2P;
	int I;
	FMOD2P=X;
	//I=FMOD2P/TWOPI;
	I=(int)(FMOD2P/(2.0*M_PI));
	//FMOD2P=FMOD2P-I*TWOPI;
	FMOD2P=FMOD2P-I*(2.0*M_PI);
	//IF(FMOD2P.LT.0) FMOD2P=FMOD2P+TWOPI
	if (FMOD2P < 0.0) 
		FMOD2P=FMOD2P+2.0*M_PI;
	return FMOD2P;
//RETURN
//END
}
// strange function :The function subroutine ACTAN is passed the values of sine and cosine in that order and
// it returns the angle in radians within the range of 0 to 2 pi
long double ACTAN(long double SINX,long double COSX)
{
	long double ACTAN,TEMP;
	//COMMON/C2/DE2RA,PI,PIO2,TWOPI,X3PIO2
	long double X3PIO2 = 3.0*M_PI/2.0;
	long double PIO2 = M_PI/2.0;
	ACTAN=0.0;
	if (COSX == 0.0) goto M_5;
	if (COSX > 0.0) goto M_1;
	ACTAN=M_PI;
	goto M_7;
M_1:
	if (SINX == 0.0) goto M_8;
	if (SINX > 0.0) goto M_7;
	ACTAN=2.0*M_PI;
	goto M_7;
M_5:
	if (SINX == 0.0) goto M_8;
	if (SINX > 0.0) goto M_6;
	ACTAN=X3PIO2;
	goto M_8;
M_6:
	ACTAN=PIO2;
	goto M_8;
M_7:
	TEMP=SINX/COSX;
	ACTAN=ACTAN+atan(TEMP);
M_8:
	return ACTAN;
	//RETURN
	//END
}
#define _USE_ORIGINAL 1
// original and less acurate
void SGP(long double TS, long double XNDT2O,long double XNDD6O,/*double IEXP,*/long double nuBSTAR,/*double IBEXP,*/long double XINCL, long double XNODEO,long double EO, long double OMEGAO, long double XMO, long double XNO, 
	long double &X,long double &Y,long double &Z,long double &XDOT,long double &YDOT,long double &ZDOT)
{
	//* SGP 31 OCT 80
    //SUBROUTINE SGP(IFLAG,TSINCE)
	long double TSINCE = TS;
	//COMMON/E1/XMO,XNODEO,OMEGAO,EO,XINCL,XNO,XNDT2O,XNDD6O,BSTAR,
	//1 X,Y,Z,XDOT,YDOT,ZDOT,EPOCH,DS50
	//COMMON/C1/CK2,CK4,E6A,QOMS2T,S,TOTHRD,
	//1 XJ3,XKE,XKMPER,XMNPDA,AE
	//DATA DE2RA,E6A,PI,PIO2,QO,SO,TOTHRD,TWOPI,X3PIO2,XJ2,XJ3,
	//1 XJ4,XKE,XKMPER,XMNPDA,AE/.174532925E-1,1.E-6,
	//2 3.14159265,1.57079633,120.0,78.0,.66666667,
	//4 6.2831853,4.71238898,1.082616E-3,-.253881E-5,
	//5 -1.65597E-6,.743669161E-1,6378.135,1440.,1./
	//double DE2RA= .174532925E-1;
	// double E6A = 1.E-6;
	//double PI= 3.14159265;
	//double PIO2 = 1.57079633;
	//double QO= 120.0;
	//double SO= 78.0;
	//double TOTHRD= .66666667;
	//double TWOPI = 6.2831853;
	//double X3PIO2 = 4.71238898;
#if _USE_ORIGINAL
	long double XKE = BIG_XKE;//.743669161E-1;
	//long double XKMPER = 6378.1350;
	long double XJ2 = 1.082616E-3; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -.253881E-5; // the third gravitational zonal harmonic of the Earth
    double E6A = 1.E-6;
#else
	long double XKE = 7.43669161331734132e-2;
//	long double XKMPER = 6378.137;
	long double XJ2 = 0.10826360229840e-02; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -0.25325160653E-05; // the third gravitational zonal harmonic of the Earth
    double E6A = 1.E-12;
#endif

	//double XJ4 = -1.65597E-6;
	//double XKMPER = 6378.135;
	//double XMNPDA= 1440.;
	long double AE =1.;

	int IFLAG;
    //double XMO,XNODEO,OMEGAO,EO,XINCL,XNO,XNDT2O,XNDD6O,BSTAR,
    ///*X,Y,Z,XDOT,YDOT,ZDOT,*/EPOCH,DS50;
    //double CK2,CK4,E6A,QOMS2T,S,TOTHRD,
    //XJ3,XKE,XKMPER,XMNPDA,AE;
    //double EPOCH, DS50;
	long double C1,C2,C3,C4;
	long double COSIO,SINIO;
	long double A1,D1,AO,PO,QO,XLO,D1O,D2O,D3O,D4O,PO2NO,OMGDT,XNODOT,C5,C6,E,A,P,XNODES,OMGAS,XLS,AXNSL,AYNSL,XL,U;
	int ITEM3;
	long double EO1,TEM5;
	long double SINEO1,COSEO1,TEM2,ECOSE,ESINE,EL2,PL,PL2,R,RDOT,RVDOT,TEMP,SINU,COSU,SU,SIN2U,COS2U,RK,UK,XNODEK,XINCK,SINUK,COSUK,SINNOK,COSNOK;
	long double SINIK,COSIK,XMX,XMY,UX,UY,UZ,VX,VY,VZ;
	//CK2=.5*XJ2*AE**2
	long double CK2=.5*XJ2*AE*AE;
    //if (IFLAG == 0) goto M_19;
    // * INITIALIZATION
    C1= CK2*1.5;
    C2= CK2/4.0;
    C3= CK2/2.0;
    C4= XJ3*(AE*AE*AE)/(4.0*CK2);
    COSIO=cos(XINCL);
    SINIO=sin(XINCL);
    //A1=(XKE/XNO)**TOTHRD;
	A1 = pow((XKE/XNO),(long double)2.0/(long double)3.0);
	//D1= C1/A1/A1*(3.*COSIO*COSIO-1.)/(1.-EO*EO)**1.5;
	D1= C1/A1/A1*(3.*COSIO*COSIO-1.)/pow((1.-EO*EO),(long double)1.5);
	AO=A1*(1.-1./3.*D1-D1*D1-134./81.*D1*D1*D1);
    PO=AO*(1.-EO*EO);
	QO=AO*(1.-EO);
	XLO=XMO+OMEGAO+XNODEO;
	D1O= C3 *SINIO*SINIO;
	D2O= C2 *(7.*COSIO*COSIO-1.);
	D3O=C1*COSIO;
	D4O=D3O*SINIO;
	PO2NO=XNO/(PO*PO);
	OMGDT=C1*PO2NO*(5.*COSIO*COSIO-1.);
	XNODOT=-2.*D3O*PO2NO;
	C5=.5*C4*SINIO*(3.+5.*COSIO)/(1.+COSIO);
	C6=C4*SINIO;
	IFLAG=0;
	//* UPDATE FOR SECULAR GRAVITY AND ATMOSPHERIC DRAG
M_19: 
	A = XNO+(2.*XNDT2O+3.*XNDD6O*TSINCE)*TSINCE;
	//A=AO*(XNO/A)**TOTHRD;
	A=pow(AO*(XNO/A),(long double)2.0/(long double)3.0);
	E=1.0E-6;
	//IF(A.GT.QO) E=1.-QO/A
	if(A>QO) 
		E=1.-QO/A;
	P=A*(1.-E*E);
	XNODES= XNODEO+XNODOT*TSINCE;
	OMGAS= OMEGAO+OMGDT*TSINCE;
	XLS=FMOD2P(XLO+(XNO+OMGDT+XNODOT+(XNDT2O+XNDD6O*TSINCE)*TSINCE)*TSINCE);
   // LONG PERIOD PERIODICS
M_7:
	AXNSL=E*cos(OMGAS);
	AYNSL=E*sin(OMGAS)-C6/P;
	XL=FMOD2P(XLS-C5/P*AXNSL);
	//* SOLVE KEPLERS EQUATION
	U=FMOD2P(XL-XNODES);
	ITEM3=0;
	EO1=U;
	TEM5=1.0;
M_20:
	SINEO1=sin(EO1);
	COSEO1=cos(EO1);
	//IF(ABS(TEM5).LT.E6A) GO TO 30
	if(abs(TEM5)<1E-6) 
		goto M_30;
	//IF(ITEM3.GE.10) GO TO 30
	if(ITEM3 > 30) 
		goto M_30;
	ITEM3=ITEM3+1;
	TEM5=1.-COSEO1*AXNSL-SINEO1*AYNSL;
	TEM5=(U-AYNSL*COSEO1+AXNSL*SINEO1-EO1)/TEM5;
	TEM2=abs(TEM5);
	//IF(TEM2.GT.1.) TEM5=TEM2/TEM5
	if(TEM2>1.0) 
		TEM5=TEM2/TEM5;
	EO1=EO1+TEM5;

	goto M_20;
	//* SHORT PERIOD PRELIMINARY QUANTITIES
M_30:
	ECOSE=AXNSL*COSEO1+AYNSL*SINEO1;
	ESINE=AXNSL*SINEO1-AYNSL*COSEO1;
	EL2=AXNSL*AXNSL+AYNSL*AYNSL;
	PL=A*(1.-EL2);
	PL2=PL*PL;
	R=A*(1.-ECOSE);
	RDOT=XKE*sqrt(A)/R*ESINE;
	RVDOT=XKE*sqrt(PL)/R;
	TEMP=ESINE/(1.+sqrt(1.-EL2));
	SINU=A/R*(SINEO1-AYNSL-AXNSL*TEMP);
	COSU=A/R*(COSEO1-AXNSL+AYNSL*TEMP);
	//SU=ACTAN(SINU,COSU);
	SU=ACTAN(SINU,COSU);
	//* UPDATE FOR SHORT PERIODICS
	SIN2U=(COSU+COSU)*SINU;
	COS2U=1.-2.*SINU*SINU;
	RK=R+D1O/PL*COS2U;
	UK=SU-D2O/PL2*SIN2U;
	XNODEK=XNODES+D3O*SIN2U/PL2;
	XINCK =XINCL+D4O/PL2*COS2U;
	//* ORIENTATION VECTORS
M_8:
	SINUK=sin(UK);
	COSUK=cos(UK);
	SINNOK=sin(XNODEK);
	COSNOK=cos(XNODEK);
	SINIK=sin(XINCK);
	COSIK=cos(XINCK);
	XMX=-SINNOK*COSIK;
	XMY=COSNOK*COSIK;
	UX=XMX*SINUK+COSNOK*COSUK;
	UY=XMY*SINUK+SINNOK*COSUK;
	UZ=SINIK*SINUK;
	VX=XMX*COSUK-COSNOK*SINUK;
	VY=XMY*COSUK-SINNOK*SINUK;
	VZ=SINIK*COSUK;
	//* POSITION AND VELOCITY
	X=RK*UX;
	Y=RK*UY;
	Z=RK*UZ;
	XDOT=RDOT*UX;
	YDOT=RDOT*UY;
	ZDOT=RDOT*UZ;
	XDOT=RVDOT*VX+XDOT;
	YDOT=RVDOT*VY+YDOT;
	ZDOT=RVDOT*VZ+ZDOT;
//RETURN
//END
}
// original, more acurate, takes account about drag == according Aksenov needs to use exact formulas from SGP4 to correctly process
// data. Backwards formulas should applied before everything 
// Read comments: (do) RECOVER ORIGINAL MEAN MOTION (XNODP) AND SEMIMAJOR AXIS (AODP) FROM INPUT ELEMENTS
void SGP4(long double TSINCE,/*double EPOCH,*/ 
          long double nuXNDT2O, 
          long double nuXNDD6O,/*IEXP,*/
          long double BSTAR,/*IBEXP,*/
	      long double XINCL,  // the mean inclination at epoch
          long double XNODEO, //the mean longitude of ascending node at epoch
          long double EO,     // the mean eccentricity at epoch
          long double OMEGAO, // the mean argument of perigee at epoch
          long double XMO,   // (M0) the mean mean anomaly at epoch
          long double XNO,   // (k0) the SGP type mean mean motion at epoch
		  long double &X,long double &Y,long double &Z,long double &XDOT,long double &YDOT,long double &ZDOT)
{
//COMMON/E1/XMO,XNODEO,OMEGAO,EO,XINCL,XNO,XNDT2O,
//1 XNDD6O,BSTAR,X,Y,Z,XDOT,YDOT,ZDOT,EPOCH,DS50
//COMMON/C1/CK2,CK4,E6A,QOMS2T,S,TOTHRD,
//1 XJ3,XKE,XKMPER,XMNPDA,AE
	//long double /*EPOCH,*/ DS50;
#if _USE_ORIGINAL
	long double XKE = BIG_XKE;//.743669161E-1;
	long double XKMPER = 6378.1350;
	long double XJ2 = 1.082616E-3; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -.253881E-5; // the third gravitational zonal harmonic of the Earth
	long double XJ4 = -1.65597E-6; // the fourth gravitational zonal harmonic of the Earth
    double E6A = 1.E-6;
#else
	long double XKE = 7.43669161331734132e-2;
	long double XKMPER = 6378.137;
	long double XJ2 = 0.10826360229840e-02; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -0.25325160653E-05; // the third gravitational zonal harmonic of the Earth
	long double XJ4 = -0.16185636000E-05; // the fourth gravitational zonal harmonic of the Earth
    double E6A = 1.E-12;
#endif
	//IF (IFLAG .EQ. 0) GO TO 100
	//* RECOVER ORIGINAL MEAN MOTION (XNODP) AND SEMIMAJOR AXIS (AODP)
	//* FROM INPUT ELEMENTS
	//A1=(XKE/XNO)**TOTHRD;
	long double AE = 1.0;          // the equatorial radius of the Earth - actualy it is not true it is one == everything measuared in that radiuses
	long double QO =120.0;         // parameter for the SGP4/SGP8 density function
	long double SO = 78.0;         // parameter for the SGP4/SGP8 density function

	long double CK2=.5*XJ2*AE*AE;
	//CK4=-.375*XJ4*AE**4
	long double CK4=-.375*XJ4*AE*AE*AE*AE;
	long double QOMS2T=pow(((QO-SO)*AE/XKMPER),(long double)4.0);
	long double S=AE*(1.+SO/XKMPER);

    //The original mean motion (n0") and semimajor axis (a0") are first recovered from the input elements by the equations:
    //
    // a1 = (k0 /n0) ** (2/3)
    //
    // b1 = 3/2 * k2/a1 * (3 * (cos(i0))**2 -1)/(1-e0**2)**(3/2)
    //
    // a0 = a1 * (1 - 1/3 b1 - b1**2  - 134/81 b1**3)
    //
    // b0 - 3/2 * k2/(a0**2) * (3 * (cos(i0))**2 - 1)/(1- e9**2)3/2
    //
    // n0" = n0/ (1+b0)
    // a0" = a0/(1-b0)
    //
	//A1=(XKE/XNO)**TOTHRD;
	long double A1=pow((XKE/XNO),(long double)2.0/(long double)3.0);
	long double COSIO=cos(XINCL);
	long double THETA2=COSIO*COSIO;
	long double X3THM1=3.*THETA2-1.;
	long double EOSQ=EO*EO;
	long double BETAO2=1.-EOSQ;
	long double BETAO=sqrt(BETAO2);
	long double DEL1=1.5*CK2*X3THM1/(A1*A1*BETAO*BETAO2);
	//AO=A1*(1.-DEL1*(.5*TOTHRD+DEL1*(1.+134./81.*DEL1)))
	long double AO=A1*(1.-DEL1*(.5*(2.0/3.0)+DEL1*(1.+134./81.*DEL1)));
	long double DELO=1.5*CK2*X3THM1/(AO*AO*BETAO*BETAO2);
    // ProbMeanMotion = XNO / (2*pi) * 1440.0
	long double XNODP=XNO/(1.+DELO);
    // and this is a semimajor axis
	long double AODP=AO/(1.-DELO);
	//* INITIALIZATION
	//* FOR PERIGEE LESS THAN 220 KILOMETERS, THE ISIMP FLAG IS SET AND
	//* THE EQUATIONS ARE TRUNCATED TO LINEAR VARIATION IN SQRT A AND
	//* QUADRATIC VARIATION IN MEAN ANOMALY. ALSO, THE C3 TERM, THE
	//* DELTA OMEGA TERM, AND THE DELTA M TERM ARE DROPPED.
	int ISIMP=0;
	//IF((AODP*(1.-EO)/AE) .LT. (220./XKMPER+AE)) ISIMP=1
	if((AODP*(1.-EO)/AE) < (220./XKMPER+AE)) 
		ISIMP=1;
	//* FOR PERIGEE BELOW 156 KM, THE VALUES OF
	//* S AND QOMS2T ARE ALTERED
	long double S4=S;
	long double QOMS24=QOMS2T;
	long double PERIGE=(AODP*(1.-EO)-AE)*XKMPER;
	//IF(PERIGE .GE. 156.) GO TO 10
	if (PERIGE >= 156.) 
		goto M_10;
	S4=PERIGE-78.;
	//IF(PERIGE .GT. 98.) GO TO 9
	if (PERIGE >=98.) 
		goto M_9;
	S4=20.;
M_9:
	//QOMS24=((120.-S4)*AE/XKMPER)**4;
	QOMS24=pow(((120.-S4)*AE/XKMPER),4);
	S4=S4/XKMPER+AE;
M_16:
M_10:
	long double PINVSQ=1./(AODP*AODP*BETAO2*BETAO2);
	long double TSI=1./(AODP-S4);
	long double ETA=AODP*EO*TSI;
	long double ETASQ=ETA*ETA;
	long double EETA=EO*ETA;
	long double PSISQ=abs(1.-ETASQ);
	//COEF=QOMS24*TSI**4
	long double COEF=QOMS24*TSI*TSI*TSI*TSI;
	//COEF1=COEF/PSISQ**3.5;
	long double COEF1=COEF/pow(PSISQ,(long double)3.5);

	long double C2=COEF1*XNODP*(AODP*(1.+1.5*ETASQ+EETA*(4.+ETASQ))+.75* CK2*TSI/PSISQ*X3THM1*(8.+3.*ETASQ*(8.+ETASQ)));
	long double C1=BSTAR*C2;
	long double SINIO=sin(XINCL);
	//A3OVK2=-XJ3/CK2*AE**3;
	long double A3OVK2=-XJ3/CK2*(AE*AE*AE);
	long double C3=COEF*TSI*A3OVK2*XNODP*AE*SINIO/EO;
	long double X1MTH2=1.-THETA2;
	long double C4=2.*XNODP*COEF1*AODP*BETAO2*(ETA*(2.+.5*ETASQ)+EO*(.5+2.*ETASQ)-2.*CK2*TSI/
			(AODP*PSISQ)*(-3.*X3THM1*(1.-2.*EETA+ETASQ* (1.5-.5*EETA))+.75*X1MTH2*(2.*ETASQ-EETA* (1.+ETASQ))*cos(2.*OMEGAO)));
	long double C5=2.*COEF1*AODP*BETAO2*(1.+2.75*(ETASQ+EETA)+EETA*ETASQ);
	long double THETA4=THETA2*THETA2;
	long double TEMP1=3.*CK2*PINVSQ*XNODP;
	long double TEMP2=TEMP1*CK2*PINVSQ;
	long double TEMP3=1.25*CK4*PINVSQ*PINVSQ*XNODP;
	long double XMDOT=XNODP+.5*TEMP1*BETAO*X3THM1+.0625*TEMP2*BETAO* (13.-78.*THETA2+137.*THETA4);
	long double X1M5TH=1.-5.*THETA2;
	long double OMGDOT=-.5*TEMP1*X1M5TH+.0625*TEMP2*(7.-114.*THETA2+ 395.*THETA4)+TEMP3*(3.-36.*THETA2+49.*THETA4);
	long double XHDOT1=-TEMP1*COSIO;
	long double XNODOT=XHDOT1+(.5*TEMP2*(4.-19.*THETA2)+2.*TEMP3*(3.-7.*THETA2))*COSIO;
	long double OMGCOF=BSTAR*C3*cos(OMEGAO);
	long double XMCOF=-(2.0/3.0)*COEF*BSTAR*AE/EETA;
	long double XNODCF=3.5*BETAO2*XHDOT1*C1;
	long double T2COF=1.5*C1;
	long double XLCOF=.125*A3OVK2*SINIO*(3.+5.*COSIO)/(1.+COSIO);
	long double AYCOF=.25*A3OVK2*SINIO;
	//DELMO=(1.+ETA*COS(XMO))**3
	long double DELMO=pow((1.+ETA*cos(XMO)),3);
	long double SINMO=sin(XMO);
	long double X7THM1=7.*THETA2-1.;
	// IF(ISIMP .EQ. 1) GO TO 90
	if (ISIMP == 1) 
		goto M_90;
	long double C1SQ=C1*C1;
	long double D2=4.*AODP*TSI*C1SQ;
	long double TEMP=D2*TSI*C1/3.;
	long double D3=(17.*AODP+S4)*TEMP;
	long double D4=.5*TEMP*AODP*TSI*(221.*AODP+31.*S4)*C1;
M_17:
	long double T3COF=D2+2.*C1SQ;
	long double T4COF=.25*(3.*D3+C1*(12.*D2+10.*C1SQ));
	long double T5COF=.2*(3.*D4+12.*C1*D3+6.*D2*D2+15.*C1SQ*(2.*D2+C1SQ));
M_90:
	//IFLAG=0;
	//* UPDATE FOR SECULAR GRAVITY AND ATMOSPHERIC DRAG
M_100:
	long double XMDF=XMO+XMDOT*TSINCE;
	long double OMGADF=OMEGAO+OMGDOT*TSINCE;
	long double XNODDF=XNODEO+XNODOT*TSINCE;
	long double OMEGA=OMGADF;
	long double XMP=XMDF;
	long double TSQ=TSINCE*TSINCE;
	long double XNODE=XNODDF+XNODCF*TSQ;
	long double TEMPA=1.-C1*TSINCE;
	long double TEMPE=BSTAR*C4*TSINCE;
	long double TEMPL=T2COF*TSQ;
	// IF(ISIMP .EQ. 1) GO TO 110
	if (ISIMP == 1) 
		goto M_110;
	long double DELOMG=OMGCOF*TSINCE;
	// DELM=XMCOF*((1.+ETA*COS(XMDF))**3-DELMO)
	long double DELM=XMCOF*(pow((1.+ETA*cos(XMDF)),3)-DELMO);
	TEMP=DELOMG+DELM;
	XMP=XMDF+TEMP;
	OMEGA=OMGADF-TEMP;
	long double TCUBE=TSQ*TSINCE;
	long double TFOUR=TSINCE*TCUBE;
	TEMPA=TEMPA-D2*TSQ-D3*TCUBE-D4*TFOUR;
	TEMPE=TEMPE+BSTAR*C5*(sin(XMP)-SINMO);
	TEMPL=TEMPL+T3COF*TCUBE+TFOUR*(T4COF+TSINCE*T5COF);
M_110:
	//A=AODP*TEMPA**2;
	long double A=AODP*TEMPA*TEMPA;
	long double E=EO-TEMPE;
	long double XL=XMP+OMEGA+XNODE+XNODP*TEMPL;
	long double BETA=sqrt(1.-E*E);
	//XN=XKE/A**1.5
	long double XN=XKE/pow(A,(long double)1.5);
	//* LONG PERIOD PERIODICS
	long double AXN=E*cos(OMEGA);
	TEMP=1./(A*BETA*BETA);
	long double XLL=TEMP*XLCOF*AXN;
	long double AYNL=TEMP*AYCOF;
	long double XLT=XL+XLL;
	long double AYN=E*sin(OMEGA)+AYNL;
	//* SOLVE KEPLERS EQUATION
	long double CAPU=FMOD2P(XLT-XNODE);
M_18:
	TEMP2=CAPU;
	// DO 130 I=1,10
	long double SINEPW;
	long double COSEPW;
	long double TEMP4;
	long double TEMP5;
	long double TEMP6;
	long double EPW;
	for (int i =1; i <=30; i++)
	{
		SINEPW=sin(TEMP2);
		COSEPW=cos(TEMP2);
		TEMP3=AXN*SINEPW;
		TEMP4=AYN*COSEPW;
		TEMP5=AXN*COSEPW;
		TEMP6=AYN*SINEPW;
		EPW=(CAPU-TEMP4+TEMP3-TEMP2)/(1.-TEMP5-TEMP6)+TEMP2;
		//IF(ABS(EPW-TEMP2) .LE. E6A) GO TO 140
		if(abs(EPW-TEMP2) <= 1.e-15) 
			goto M_140;
M_130:	TEMP2=EPW;
	}

	//* SHORT PERIOD PRELIMINARY QUANTITIES
M_140:
	long double ECOSE=TEMP5+TEMP6;
	long double ESINE=TEMP3-TEMP4;
	long double ELSQ=AXN*AXN+AYN*AYN;
	TEMP=1.-ELSQ;
	long double PL=A*TEMP;
	long double R=A*(1.-ECOSE);
	TEMP1=1./R;
	long double RDOT=XKE*sqrt(A)*ESINE*TEMP1;
	long double RFDOT=XKE*sqrt(PL)*TEMP1;
	TEMP2=A*TEMP1;
	long double BETAL=sqrt(TEMP);
	TEMP3=1./(1.+BETAL);
	long double COSU=TEMP2*(COSEPW-AXN+AYN*ESINE*TEMP3);
	long double SINU=TEMP2*(SINEPW-AYN-AXN*ESINE*TEMP3);
	long double U=ACTAN(SINU,COSU);
	long double SIN2U=2.*SINU*COSU;
	long double COS2U=2.*COSU*COSU-1.;
	TEMP=1./PL;
	TEMP1=CK2*TEMP;
	TEMP2=TEMP1*TEMP;
	// * UPDATE FOR SHORT PERIODICS
	long double RK=R*(1.-1.5*TEMP2*BETAL*X3THM1)+.5*TEMP1*X1MTH2*COS2U;
	long double UK=U-.25*TEMP2*X7THM1*SIN2U;
	long double XNODEK=XNODE+1.5*TEMP2*COSIO*SIN2U;
	long double XINCK=XINCL+1.5*TEMP2*COSIO*SINIO*COS2U;
	long double RDOTK=RDOT-XN*TEMP1*X1MTH2*SIN2U;
	long double RFDOTK=RFDOT+XN*TEMP1*(X1MTH2*COS2U+1.5*X3THM1);
	//* ORIENTATION VECTORS
	long double SINUK=sin(UK);
	long double COSUK=cos(UK);
M_19:
	long double SINIK=sin(XINCK);
	long double COSIK=cos(XINCK);
	long double SINNOK=sin(XNODEK);
	long double COSNOK=cos(XNODEK);
	long double XMX=-SINNOK*COSIK;
	long double XMY=COSNOK*COSIK;
	long double UX=XMX*SINUK+COSNOK*COSUK;
	long double UY=XMY*SINUK+SINNOK*COSUK;
	long double UZ=SINIK*SINUK;
	long double VX=XMX*COSUK-COSNOK*SINUK;
	long double VY=XMY*COSUK-SINNOK*SINUK;
	long double VZ=SINIK*COSUK;
	//* POSITION AND VELOCITY
	X=RK*UX;
	Y=RK*UY;
	Z=RK*UZ;
	XDOT=RDOTK*UX+RFDOTK*VX;
	YDOT=RDOTK*UY+RFDOTK*VY;
	ZDOT=RDOTK*UZ+RFDOTK*VZ;
//RETURN
//END
}
// 8 THE SGP8 MODEL
// The NORAD mean element sets can be used for prediction with SGP8. All symbols not defned
// below are defned in the list of symbols in Section Twelve. The original mean motion (n00) and o
// semimajor axis (a00) are frst recovered from the input elements by the equations
// * SGP8 14 NOV 80
//SUBROUTINE SGP8(IFLAG,TSINCE)
void SGP8(long double TSINCE,/*double EPOCH,*/ 
          long double nuXNDT2O, 
          long double nuXNDD6O,/*IEXP,*/
          long double BSTAR,/*IBEXP,*/
	      long double XINCL,  // the mean inclination at epoch
          long double XNODEO, //the mean longitude of ascending node at epoch
          long double EO,     // the mean eccentricity at epoch
          long double OMEGAO, // the mean argument of perigee at epoch
          long double XMO,   // (M0) the mean mean anomaly at epoch
          long double XNO,   // (k0) the SGP type mean mean motion at epoch
		  long double &X,long double &Y,long double &Z,long double &XDOT,long double &YDOT,long double &ZDOT)
{
//COMMON/E1/XMO,XNODEO,OMEGAO,EO,XINCL,XNO,XNDT2O,
//1 XNDD6O,BSTAR,X,Y,Z,XDOT,YDOT,ZDOT,EPOCH,DS50
//COMMON/C1/CK2,CK4,E6A,QOMS2T,S,TOTHRD,
//1 XJ3,XKE,XKMPER,XMNPDA,AE
//DOUBLE PRECISION EPOCH, DS50
//DATA RHO/.15696615/
    long double TOTHRD= .6666666666666666666;
    long double RHO =.15696615;
#if _USE_ORIGINAL
	long double XKE = BIG_XKE;//.743669161E-1;
	long double XKMPER = 6378.1350;
	long double XJ2 = 1.082616E-3; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -.253881E-5; // the third gravitational zonal harmonic of the Earth
	long double XJ4 = -1.65597E-6; // the fourth gravitational zonal harmonic of the Earth
    double E6A = 1.E-6;
#else
	long double XKE = 7.43669161331734132e-2;
	long double XKMPER = 6378.137;
	long double XJ2 = 0.10826360229840e-02; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -0.25325160653E-05; // the third gravitational zonal harmonic of the Earth
	long double XJ4 = -0.16185636000E-05; // the fourth gravitational zonal harmonic of the Earth
    double E6A = 1.E-12;
#endif
	long double AE = 1.0;          // the equatorial radius of the Earth - actualy it is not true it is one == everything measuared in that radiuses
	long double QO =120.0;         // parameter for the SGP4/SGP8 density function
	long double SO = 78.0;         // parameter for the SGP4/SGP8 density function

     long double CK2=.5*XJ2*AE*AE;
     long double CK4=-.375*XJ4*AE*AE*AE*AE;
	long double QOMS2T=pow(((QO-SO)*AE/XKMPER),(long double)4.0);
	long double S=AE*(1.+SO/XKMPER);
    long double XMNPDA = 24.0*60.0;//1440.0; // XMNPDA time units(minutes) /day 1440.0

//IF (IFLAG .EQ. 0) GO TO 100
//* RECOVER ORIGINAL MEAN MOTION (XNODP) AND SEMIMAJOR AXIS (AODP)
//* FROM INPUT ELEMENTS --------- CALCULATE BALLISTIC COEFFICIENT
//* (B TERM) FROM INPUT B* DRAG TERM
long double A1=pow((XKE/XNO),TOTHRD);
long double COSI=cos(XINCL);
long double THETA2=COSI*COSI;
long double TTHMUN=3.*THETA2-1.;
long double EOSQ=EO*EO;
long double BETAO2=1.-EOSQ;
long double BETAO=sqrt(BETAO2);
long double DEL1=1.5*CK2*TTHMUN/(A1*A1*BETAO*BETAO2);
long double AO=A1*(1.-DEL1*(.5*TOTHRD+DEL1*(1.+134./81.*DEL1)));
long double  DELO=1.5*CK2*TTHMUN/(AO*AO*BETAO*BETAO2);
long double AODP=AO/(1.-DELO);
long double XNODP=XNO/(1.+DELO);
long double B=2.*BSTAR/RHO;
//* INITIALIZATION
int ISIMP=0;
long double PO=AODP*BETAO2;
long double POM2=1./(PO*PO);
long double SINI=sin(XINCL);
long double __SING=sin(OMEGAO);
long double COSG=cos(OMEGAO);
long double TEMP=.5*XINCL;
long double SINIO2=sin(TEMP);
long double COSIO2=cos(TEMP);
long double THETA4=THETA2*THETA2;
long double UNM5TH=1.-5.*THETA2;
long double UNMTH2=1.-THETA2;
long double A3COF=-XJ3/CK2*AE*AE*AE;
long double PARDT1=3.*CK2*POM2*XNODP;
long double PARDT2=PARDT1*CK2*POM2;
long double PARDT4=1.25*CK4*POM2*POM2*XNODP;
long double XMDT1=.5*PARDT1*BETAO*TTHMUN;
// page 41
long double XGDT1=-.5*PARDT1*UNM5TH;
long double XHDT1=-PARDT1*COSI;
long double XLLDOT=XNODP+XMDT1+.0625*PARDT2*BETAO*(13.-78.*THETA2+137.*THETA4);
long double OMGDT=XGDT1+.0625*PARDT2*(7.-114.*THETA2+395.*THETA4)+PARDT4*(3.-36.*THETA2+49.*THETA4);
long double XNODOT=XHDT1+(.5*PARDT2*(4.-19.*THETA2)+2.*PARDT4*(3.-7.*THETA2))*COSI;
long double TSI=1./(PO-S);
long double ETA=EO*S*TSI;
long double ETA2=ETA*ETA;
long double PSIM2=fabs(1./(1.-ETA2));
long double ALPHA2=1.+EOSQ;
long double EETA=EO*ETA;
long double COS2G=2.*COSG*COSG-1.0;
long double D5=TSI*PSIM2;
long double D1=D5/PO;
long double D2=12.+ETA2*(36.+4.5*ETA2);
long double D3=ETA2*(15.+2.5*ETA2);
long double D4=ETA*(5.+3.75*ETA2);
long double B1=CK2*TTHMUN;
long double B2=-CK2*UNMTH2;
long double B3=A3COF*SINI;
long double C0=.5*B*RHO*QOMS2T*XNODP*AODP*pow((long double)TSI,(long double)4.0)*pow((long double)PSIM2,(long double)3.5)/sqrt(ALPHA2);
long double C1=1.5*XNODP*ALPHA2*ALPHA2*C0;
long double C4=D1*D3*B2;
long double C5=D5*D4*B3;
long double XNDT=C1*((2.+ETA2*(3.+34.*EOSQ)+5.*EETA*(4.+ETA2)+8.5*EOSQ)+D1*D2*B1+ C4*COS2G+C5*__SING);
long double XNDTN=XNDT/XNODP;
//* IF DRAG IS VERY SMALL, THE ISIMP FLAG IS SET AND THE
//* EQUATIONS ARE TRUNCATED TO LINEAR VARIATION IN MEAN
//* MOTION AND QUADRATIC VARIATION IN MEAN ANOMALY
//IF(ABS(XNDTN*XMNPDA) .LT. 2.16E-3) GO TO 50
if (fabs(XNDTN*XMNPDA) < 2.16E-3) goto M_50;
long double D6=ETA*(30.+22.5*ETA2);
long double D7=ETA*(5.+12.5*ETA2);
long double D8=1.+ETA2*(6.75+ETA2);
long double C8=D1*D7*B2;
long double C9=D5*D8*B3;
long double EDOT=-C0*(ETA*(4.+ETA2+EOSQ*(15.5+7.*ETA2))+EO*(5.+15.*ETA2)+ D1*D6*B1 + C8*COS2G+C9*__SING);
long double D20=.5*TOTHRD*XNDTN;
// page 42
long double ALDTAL=EO*EDOT/ALPHA2;
long double TSDTTS=2.*AODP*TSI*(D20*BETAO2+EO*EDOT);
long double ETDT=(EDOT+EO*TSDTTS)*TSI*S;
long double PSDTPS=-ETA*ETDT*PSIM2;
long double SIN2G=2.*__SING*COSG;
long double C0DTC0=D20+4.*TSDTTS-ALDTAL-7.*PSDTPS;
long double C1DTC1=XNDTN+4.*ALDTAL+C0DTC0;
long double D9=ETA*(6.+68.*EOSQ)+EO*(20.+15.*ETA2);
long double D10=5.*ETA*(4.+ETA2)+EO*(17.+68.*ETA2);
long double D11=ETA*(72.+18.*ETA2);
long double D12=ETA*(30.+10.*ETA2);
long double D13=5.+11.25*ETA2;
long double D14=TSDTTS-2.*PSDTPS;
long double D15=2.*(D20+EO*EDOT/BETAO2);
long double D1DT=D1*(D14+D15);
long double D2DT=ETDT*D11;
long double D3DT=ETDT*D12;
long double D4DT=ETDT*D13;
long double D5DT=D5*D14;
long double C4DT=B2*(D1DT*D3+D1*D3DT);
long double C5DT=B3*(D5DT*D4+D5*D4DT);
long double D16= D9*ETDT+D10*EDOT + B1*(D1DT*D2+D1*D2DT) + C4DT*COS2G+C5DT*__SING+XGDT1*(C5*COSG-2.*C4*SIN2G);
long double XNDDT=C1DTC1*XNDT+C1*D16;
long double EDDOT=C0DTC0*EDOT-C0*( (4.+3.*ETA2+30.*EETA+EOSQ*(15.5+21.*ETA2))*ETDT+(5.+15.*ETA2 +EETA*(31.+14.*ETA2))*EDOT + B1*(D1DT*D6+D1*ETDT*(30.+67.5*ETA2)) + B2*(D1DT*D7+D1*ETDT*(5.+37.5*ETA2))*COS2G+ B3*(D5DT*D8+D5*ETDT*ETA*(13.5+4.*ETA2))*__SING+XGDT1*(C9* COSG-2.*C8*SIN2G));
long double D25=EDOT*EDOT;
long double D17=XNDDT/XNODP-XNDTN*XNDTN;
long double TSDDTS=2.*TSDTTS*(TSDTTS-D20)+AODP*TSI*(TOTHRD*BETAO2*D17-4.*D20* EO*EDOT+2.*(D25+EO*EDDOT));
long double ETDDT =(EDDOT+2.*EDOT*TSDTTS)*TSI*S+TSDDTS*ETA;
long double D18=TSDDTS-TSDTTS*TSDTTS;
long double D19=-PSDTPS*PSDTPS/ETA2-ETA*ETDDT*PSIM2-PSDTPS*PSDTPS;
long double D23=ETDT*ETDT;
long double D1DDT=D1DT*(D14+D15)+D1*(D18-2.*D19+TOTHRD*D17+2.*(ALPHA2*D25 /BETAO2+EO*EDDOT)/BETAO2);
long double XNTRDT=XNDT*(2.*TOTHRD*D17+3.* (D25+EO*EDDOT)/ALPHA2-6.*ALDTAL*ALDTAL + 4.*D18-7.*D19 ) + C1DTC1*XNDDT+C1*(C1DTC1*D16+ D9*ETDDT+D10*EDDOT+D23*(6.+30.*EETA+68.*EOSQ)+ ETDT*EDOT*(40.+30.* ETA2+272.*EETA)+D25*(17.+68.*ETA2) + B1*(D1DDT*D2+2.*D1DT*D2DT+D1*(ETDDT*D11+D23*(72.+54.*ETA2))) + B2*(D1DDT*D3+2.*D1DT*D3DT+D1*(ETDDT*D12+D23*(30.+30.*ETA2))) * COS2G+ B3*((D5DT*D14+D5*(D18-2.*D19)) * D4+2.*D4DT*D5DT+D5*(ETDDT*D13+22.5*ETA*D23)) *__SING+XGDT1* ((7.*D20+4.*EO*EDOT/BETAO2)* (C5*COSG-2.*C4*SIN2G) +((2.*C5DT*COSG-4.*C4DT*SIN2G)-XGDT1*(C5*SING+4.* C4*COS2G))));
long double TMNDDT=XNDDT*1.E9;
TEMP=TMNDDT*TMNDDT-XNDT*1.E18*XNTRDT;
long double PP=(TEMP+TMNDDT*TMNDDT)/TEMP;
long double GAMMA=-XNTRDT/(XNDDT*(PP-2.));
long double XND=XNDT/(PP*GAMMA);
long double QQ=1.-EDDOT/(EDOT*GAMMA);
long double ED=EDOT/(QQ*GAMMA);
long double OVGPP=1./(GAMMA*(PP+1.));
    goto M_70;
M_50:
    ISIMP=1;
EDOT=-TOTHRD*XNDTN*(1.-EO);
M_70:
//IFLAG=0;
//* UPDATE FOR SECULAR GRAVITY AND ATMOSPHERIC DRAG
M_100:
long double XMAM=FMOD2P(XMO+XLLDOT*TSINCE);
long double OMGASM=OMEGAO+OMGDT*TSINCE;
long double XNODES=XNODEO+XNODOT*TSINCE;
//IF(ISIMP .EQ. 1) GO TO 105
if(ISIMP == 1) goto M_105;
TEMP=1.-GAMMA*TSINCE;
//TEMP1=TEMP**PP
long double TEMP1=pow(TEMP,PP);
long double XN=XNODP+XND*(1.-TEMP1);
//EM=EO+ED*(1.-TEMP**QQ)
long double EM=EO+ED*(1.-pow(TEMP,QQ));
long double Z1=XND*(TSINCE+OVGPP*(TEMP*TEMP1-1.));
goto M_108;
M_105:
XN=XNODP+XNDT*TSINCE;
EM=EO+EDOT*TSINCE;
Z1=.5*XNDT*TSINCE*TSINCE;
M_108:
long double Z7=3.5*TOTHRD*Z1/XNODP;
XMAM=FMOD2P(XMAM+Z1+Z7*XMDT1);
OMGASM=OMGASM+Z7*XGDT1;
XNODES=XNODES+Z7*XHDT1;
//* SOLVE KEPLERS EQUATION
long double ZC2=XMAM+EM*sin(XMAM)*(1.+EM*cos(XMAM));
long double SINE;
long double COSE;
long double ZC5;
long double CAPE;

//DO 130 I=1,10
for (int i = 0; i< 10; i++)
{

    SINE=sin(ZC2);
    COSE=cos(ZC2);
    ZC5=1./(1.-EM*COSE);
    CAPE=(XMAM+EM*SINE-ZC2)* ZC5+ZC2;
    //IF(ABS(CAPE-ZC2) .LE. E6A) GO TO 140
    if (fabs(CAPE-ZC2) < E6A) break;//GO TO 140
M_130:
ZC2=CAPE;
}
//* SHORT PERIOD PRELIMINARY QUANTITIES
M_140:
long double AM=pow((XKE/XN),TOTHRD);
long double BETA2M=1.-EM*EM;
long double SINOS=sin(OMGASM);
long double COSOS=cos(OMGASM);
long double AXNM=EM*COSOS;
long double AYNM=EM*SINOS;
long double PM=AM*BETA2M;
long double G1=1./PM;
long double G2=.5*CK2*G1;
long double G3=G2*G1;
long double BETA=sqrt(BETA2M);
long double G4=.25*A3COF*SINI;
long double G5=.25*A3COF*G1;
long double SNF=BETA*SINE*ZC5;
long double CSF=(COSE-EM)*ZC5;
//FM=ACTAN(SNF,CSF)
long double FM=ACTAN(SNF,CSF);
long double SNFG=SNF*COSOS+CSF*SINOS;
long double CSFG=CSF*COSOS-SNF*SINOS;
long double SN2F2G=2.*SNFG*CSFG;
long double CS2F2G=2.*CSFG*CSFG-1.0;
long double ECOSF=EM*CSF;
long double G10=FM-XMAM+EM*SNF;
long double RM=PM/(1.+ECOSF);
long double AOVR=AM/RM;
long double G13=XN*AOVR;
long double G14=-G13*AOVR;
long double DR=G2*(UNMTH2*CS2F2G-3.*TTHMUN)-G4*SNFG;
long double DIWC=3.*G3*SINI*CS2F2G-G5*AYNM;
long double DI=DIWC*COSI;
//* UPDATE FOR SHORT PERIOD PERIODICS
long double SNI2DU=SINIO2*( G3*(.5*(1.-7.*THETA2)*SN2F2G-3.*UNM5TH*G10)-G5*SINI*CSFG*(2.+ ECOSF))-.5*G5*THETA2*AXNM/COSIO2;
long double XLAMB=FM+OMGASM+XNODES+G3*(.5*(1.+6.*COSI-7.*THETA2)*SN2F2G-3.* (UNM5TH+2.*COSI)*G10)+G5*SINI*(COSI*AXNM/(1.+COSI)-(2. +ECOSF)*CSFG);

long double Y4=SINIO2*SNFG+CSFG*SNI2DU+.5*SNFG*COSIO2*DI;
long double Y5=SINIO2*CSFG-SNFG*SNI2DU+.5*CSFG*COSIO2*DI;
long double R=RM+DR;
long double RDOT=XN*AM*EM*SNF/BETA+G14*(2.*G2*UNMTH2*SN2F2G+G4*CSFG);
long double RVDOT=XN*AM*AM*BETA/RM+ G14*DR+AM*G13*SINI*DIWC;
//* ORIENTATION VECTORS
long double SNLAMB=sin(XLAMB);
long double CSLAMB=cos(XLAMB);
TEMP=2.*(Y5*SNLAMB-Y4*CSLAMB);
long double UX=Y4*TEMP+CSLAMB;
long double VX=Y5*TEMP-SNLAMB;
TEMP=2.*(Y5*CSLAMB+Y4*SNLAMB);
long double UY=-Y4*TEMP+SNLAMB;
long double VY=-Y5*TEMP+CSLAMB;
TEMP=2.*sqrt(1.-Y4*Y4-Y5*Y5);
long double UZ=Y4*TEMP;
long double VZ=Y5*TEMP;
//* POSITION AND VELOCITY
X=R*UX;
Y=R*UY;
Z=R*UZ;
XDOT=RDOT*UX+RVDOT*VX;
YDOT=RDOT*UY+RVDOT*VY;
ZDOT=RDOT*UZ+RVDOT*VZ;
//RETURN
//END
}

int iGr = 0;

///////////////////////////////////////////////////////////////////////////
// quick XML parser
///
char szSection[1024] =  {0};
char szGroup[1024] =  {0};
#define XML_READ(XML_PARAM) if (CallXMLPars(szString, #XML_PARAM)) XML_PARAM = atof(pszQuo);
#define IF_XML_READ(XML_PARAM) if (CallXMLPars(szString, #XML_PARAM))
#define XML_BEGIN char *pszQuo;
#define XML_END ;
#define XML_SECTION(XML_SEC_NAME) if (strcmp(szSection, #XML_SEC_NAME)==0){pszQuo = strstr(szString, "value=\"");if (pszQuo != NULL){pszQuo += sizeof("value=\"") -1;
#define XML_SECTION_END }}
#define XML_SECTION_GROUP_SEPARATOR } else {

#define XML_GROUP(XML_ELEMENT) if (pszQuo=CallGroupPars(szString,#XML_ELEMENT)) strcpy(szGroup, pszQuo); if (strcmp(szGroup, #XML_ELEMENT) ==0) {
#define XML_GROUP_END }

#define IF_XML_ELEMENT(XML_ELEMENT) if (pszQuo=CallElementPars(szString,#XML_ELEMENT))

int CallXMLPars(char *szString, char *XML_Params)
{
    char szFullComapre[1024] = {"name=\""};
    strcat(szFullComapre, XML_Params);
    strcat(szFullComapre, "\"");
    if (strstr(szString, szFullComapre) != NULL)   
        return 1;
    else
        return 0;
}

char *CallElementPars(char *szString, char *XML_Params)
{
    char szFullComapre[1024] = {"<"};
    char szFullComapre2[1024] = {"</"};
    strcat(szFullComapre, XML_Params);
    strcat(szFullComapre2, XML_Params);
    strcat(szFullComapre, ">");
    strcat(szFullComapre2, ">");
    if (strstr(szString, szFullComapre) != NULL)   
    {
        if (strstr(szString, szFullComapre2) != NULL)
        {
            char *szPrt = strstr(szString, szFullComapre);
            szPrt += strlen(szFullComapre);
            return szPrt;
        }
        return NULL;
    }
    else
        return NULL;
}

char *CallGroupPars(char *szString, char *XML_Params)
{
    char szFullComapre[1024] = {"<"};
    strcat(szFullComapre, XML_Params);
    strcat(szFullComapre, ">");
    if (strstr(szString, szFullComapre) != NULL)   
    {
        char *szPrt = strstr(szString, szFullComapre);
        return XML_Params;
    }
    else
        return NULL;
}

void ParamCommon(char *szString)
{
    XML_BEGIN;
    XML_SECTION(TraInfo);
    
        IF_XML_READ(dMinFromNow) 
        {
            dMinFromNow = atof(pszQuo);
        }
        IF_XML_READ(GRSTNLat) 
        {
            GrLat[iGr] = atof(pszQuo);
        }
        IF_XML_READ(GRSTNLong) 
        {
            GrLong[iGr++] = atof(pszQuo);
        }
        IF_XML_READ(JustFlySimulation)
        {
            JustFlySimulation = atoi(pszQuo); // if 0 then do enegine firing ; if 1 no engines at all
        }
        IF_XML_READ(dStartJD) 
        {
            ConvertDateFromXML(pszQuo, TotalDays, dStartJD, dStartTLEEpoch);
        }
        XML_READ(TimeSl);
        XML_READ(Gbig);
        //XML_READ(IterPerSec);
        IF_XML_READ(IterPerSec)
        {
             IterPerSec = atol(pszQuo);
             iItearationsPerSec = (int)(IterPerSec);
             TimeSl = 1.0 / IterPerSec;
             TimeSl_2 = 1.0 / ((long double)IterPerSec*(long double)IterPerSec);
             StepsValInDay = (1.0/((long double)IterPerSec))/24.0/60.0/60.0;
             printf("\n IterPerSec =%d ", (int)IterPerSec);
        }
        XML_READ(StartLandingIteraPerSec);
        IF_XML_READ(TotalDays) 
        {
			if (TotalDays<0)
				TotalDays = -TotalDays;
			else
				TotalDays = atof(pszQuo);
			iTotalSec = (int)(TotalDays * 24.0 * 60.0 * 60.0);

		}
        IF_XML_READ(EarthCurTime)  
        {
            EarthCurTime  = atof(pszQuo);
            // TBD
            EarthCurTimeS = EarthCurTime;
        }
        //IF_XML_READ(EarthSmAxAU)
        //{
        //    EarthSmAxAU = atof(pszQuo);
        //    AUcalc = EarthSmAx / EarthSmAxAU;
        //}
        IF_XML_READ(TRAVisual)
        {
            strcpy(szTraVisualFileName,pszQuo);
            char * iQuot = strstr(szTraVisualFileName,"\"");
            if (iQuot)
                *iQuot=0;
            VisualFileSet = TRUE;
            if (ParsURL(szURLTraVisualServer, &UrlTraVisualPort, szURLTraVisualFileName,  szTraVisualFileName))
            {
                strcpy(szTraVisualFileName, "@travisual.xml");
            }
        }
#ifdef _DO_VISUALIZATION
        IF_XML_READ(RGBImageW)
        {
            bRGBImageW = atoi(pszQuo);
        }
        IF_XML_READ(RGBImageH)
        {
            bRGBImageH = atoi(pszQuo);
        }
        IF_XML_READ(RGBView)
        {
            iProfile = atoi(pszQuo);
        }
        IF_XML_READ(RGBMaxPictures)
        {
            iMaxSeq = atoi(pszQuo);
        }
        IF_XML_READ(RGBSecPerPictures)
        {
            iMaxCounter = atoi(pszQuo);
        }
        IF_XML_READ(RGBScale)
        {
            dRGBScale = atof(pszQuo);
        }

        IF_XML_READ(RGBReferenceBody)
        {
            RGBReferenceBody = atoi(pszQuo);
        }
#endif
        IF_XML_READ(EngineToOptimize)
        {
            EngineToOptimize = atoi(pszQuo);
        }
    
        IF_XML_READ(TrajectoryOptimizationType)
        {
            TrajectoryOptimizationType = atoi(pszQuo);
        }
        IF_XML_READ(LastEngine)
        {
            LastEngine = atoi(pszQuo);
        }
        IF_XML_READ(MaxOptim)
        {
            MaxOptim = atoi(pszQuo);
        }
        IF_XML_READ(StartOptim)
        {
            StartOptim = atoi(pszQuo);
            iOptimizationStep = StartOptim;
        }

            
    XML_SECTION_END;
    // processing pulsar coordinates and parameters
    XML_SECTION(pulsars);
        IF_XML_READ(N)
        {
            Pulsars[nPulsars].N = atoi(pszQuo);
        }
        IF_XML_READ(Name)
        {
            strcpy(Pulsars[nPulsars].Name,pszQuo);
        }
        IF_XML_READ(ELONG)
        {
            Pulsars[nPulsars].ELONG = atoi(pszQuo);
        }
        IF_XML_READ(ELAT)
        {
            Pulsars[nPulsars].ELAT = atoi(pszQuo);
        }
        IF_XML_READ(P0)
        {
            Pulsars[nPulsars].P0 = atoi(pszQuo);
        }
        IF_XML_READ(S400mJy)
        {
            Pulsars[nPulsars].S400mJy = atoi(pszQuo);
            if (++nPulsars >= NPULSARS)
                nPulsars = NPULSARS-1;
        }
    XML_SECTION_END;
    XML_END;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//   TRA.XML processing => all data about the MOON
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ParamMoon(char *szString)
{
    XML_BEGIN;
    XML_SECTION(TraInfo);
        XML_READ(MoonX);
        XML_READ(MoonY);
        XML_READ(MoonZ);
        XML_READ(MoonVX);
        XML_READ(MoonVY);
        XML_READ(MoonVZ);

        XML_READ(MoonR);
        //XML_READ(MoonRP);
        //XML_READ(MoonRE);
        //XML_READ(MoonM);
        //XML_READ(GMMoon);
        //XML_READ(GMEarthMoon);


        //IF_XML_READ(MassRatioEarthToMoon)
        //{
        //    MassRatioEarthToMoon = atof(pszQuo);
        //    //if (MassRatioSunToEarthPlusMoon)
        //    {
        //        double Temp = SunM / MassRatioSunToEarthPlusMoon;
        //        if (GMEarth != 0.0 && GMMoon != 0.0 && GMSun != 0.0)
        //        {
        //            printf("\n calculation mass based on GMSun GMMoon and GMEarth");
        //            printf("\n Was  GMSun = %f", GMSun);
        //            printf("\n Was  GMEarth = %f", GMEarth);
        //            printf("\n Was  GMMoon = %f", GMMoon);
        //            printf("\n Was  SunM = %f", SunM);
        //            SunM = GMSun /Gbig;
        //            printf("\n Calc SunM = %f", SunM);                    
        //            printf("\n Was  EarthM = %f", EarthM);
        //            EarthM = GMEarth / Gbig;
        //            printf("\n Calc EarthM = %f", EarthM);
        //            printf("\n Was  MoonM = %f", MoonM);
        //            MoonM = GMMoon / Gbig;
        //            printf("\n Calc MoonM = %f", MoonM);
        //        }
        //        else
        //        {
        //            printf("\n calculation mass based on mass ratio earth to moon");
        //            printf("\n Was  MoonM = %f", MoonM);
        //            MoonM = Temp / (1.0 + MassRatioEarthToMoon);
        //            printf("\n Calc MoonM = %f", MoonM);
        //            printf("\n Was  EarthM = %f", EarthM);
        //            EarthM = MoonM * MassRatioEarthToMoon;
        //            printf("\n Calc EarthM = %f", EarthM);
        //        }
        //    }
        //}
    XML_SECTION_END;
    XML_END;
}

void MoonXYZCalc(double &flX, double &flY, double &flZ, double tsec)
{
    flX = (383.0*sin( 8399.685*tsec + 5.381)+
            31.5*sin(   70.990*tsec + 6.169)+
            10.6*sin(16728.377*tsec + 1.453)+
             6.2*sin( 1185.622*tsec + 0.481)+
             3.2*sin( 7143.070*tsec + 5.017)+
             2.3*sin(15613.745*tsec + 0.857)+
             0.8*sin( 8467.263*tsec + 1.010))*1.0E6;
    
    flY = (351.0*sin( 8399.687*tsec + 3.811)+
            28.9*sin(   70.997*tsec + 4.596)+
            13.7*sin( 8433.466*tsec + 4.766)+
             9.7*sin(16728.380*tsec + 6.165)+
             5.7*sin( 1185.667*tsec + 5.164)+
             2.9*sin( 7143.058*tsec + 0.300)+
             2.1*sin(15613.755*tsec + 5.565))*1.0E6;

    flZ = (153.2*sin( 8399.672*tsec + 3.807)+
            31.5*sin( 8433.464*tsec + 1.629)+
            12.5*sin(   70.996*tsec + 4.595)+
             4.2*sin(16728.364*tsec + 6.162)+
             2.5*sin( 1185.645*tsec + 5.167)+
             3.0*sin(  104.881*tsec + 2.555)+
             1.8*sin( 8399.116*tsec + 6.248))*1.0E6;
}

void ParamSun(char *szString)
{
    XML_BEGIN;
    XML_SECTION(TraInfo);
        
        XML_READ(SunX);
        XML_READ(SunY);
        XML_READ(SunZ);
		XML_READ(SunR);
        //XML_READ(SunM);
        //IF_XML_READ(GMSun) 
        //{
        //    GMSun = atof(pszQuo);
        //    printf("\n Was  SunM= %f", SunM);
        //    SunM = GMSun / Gbig;
        //    printf("\n Calc SunM= %f", SunM);
        //}
    XML_SECTION_END;
    XML_END;
}

void ParamEarth(char *szString)
{
    XML_BEGIN;
    XML_SECTION(TraInfo);
        XML_READ(EarthX);
        XML_READ(EarthY);
        XML_READ(EarthZ);
        XML_READ(EarthVX);
        XML_READ(EarthVY);
        XML_READ(EarthVZ);
        XML_READ(EarthR);
        //XML_READ(EarthRP);
        //XML_READ(EarthRE);
        //XML_READ(EarthM);
        XML_READ(AU);
        //XML_READ(EarthTSolSec);
        //XML_READ(EarthSmAx);
        //double Temp = 0.0;
        //IF_XML_READ(EarthTDays)  
        //{
        //    
        //    EarthTDays  = atof(pszQuo);
        //    printf("\n calc EarthTDays=%f ", EarthTDays);
        //    EarthTSec = EarthTDays * 24.0*60.0*60.0;
        //    printf("\n calc EarthTSec =%f ", EarthTSec);
        //    Temp = EarthTSec / EarthTSolSec;

        //}

        //XML_READ(GMEarth);
        //XML_READ(MassRatioSunToEarthPlusMoon);
        IF_XML_READ(EarthCalcKepler)  
        {
            // not used - left for verification in debug mode only            
            EarthCalcKepler  = atof(pszQuo);
            if (EarthCalcKepler == 1.0)
            {
                double tempCenterEarthMoonX;
                double tempCenterEarthMoonY;
                double tempCenterEarthMoonZ;
                double tempMoonX;
                double tempMoonY;
                double tempMoonZ;
                double tempMoonVX;
                double tempMoonVY;
                double tempMoonVZ;
                double tempCenterEarthMoonVX;
                double tempCenterEarthMoonVY;
                double tempCenterEarthMoonVZ;


                printf("\n GMSun = %f", GMSun);
                printf("\n GMEarth = %f", GMEarth);
                GMEarth = Gbig * EarthM; 
                printf("\n GMEarth = %f", GMEarth);
                printf("\n GMMoon = %f", GMMoon);
                GMMoon = Gbig * MoonM;
                printf("\n GMMoon = %f", GMMoon);

                printf("\n Was  A Earth= %f", EarthSmAx);
                printf("\n Was AU      = %f", AU);

                // adjust Moon + earth position at a point of a centre of gravity
                tempCenterEarthMoonX = EarthX;
                tempCenterEarthMoonY = EarthY;
                tempCenterEarthMoonZ = EarthZ;
                EarthX = tempCenterEarthMoonX + tempMoonX * (MoonM/(EarthM+MoonM));
                EarthY = tempCenterEarthMoonY + tempMoonY * (MoonM/(EarthM+MoonM));
                EarthZ = tempCenterEarthMoonZ + tempMoonZ * (MoonM/(EarthM+MoonM));
                MoonX =  EarthX - tempMoonX;
                MoonY =  EarthY - tempMoonY;
                MoonZ =  EarthZ - tempMoonZ;

                // adjust Moon + earth speed at a point of a centre of gravity
                //VM = sqrt( tempMoonVX* tempMoonVX +  tempMoonVY* tempMoonVY +  tempMoonVZ* tempMoonVZ);
                tempCenterEarthMoonVX = EarthVX;
                tempCenterEarthMoonVY = EarthVY;
                tempCenterEarthMoonVZ = EarthVZ;
                EarthVX = tempCenterEarthMoonVX - tempMoonVX * (MoonM/(EarthM+MoonM));
                EarthVY = tempCenterEarthMoonVY - tempMoonVY * (MoonM/(EarthM+MoonM));
                EarthVZ = tempCenterEarthMoonVZ - tempMoonVZ * (MoonM/(EarthM+MoonM));
                MoonVX = tempCenterEarthMoonVX + tempMoonVX * (EarthM/(EarthM+MoonM));
                MoonVY = tempCenterEarthMoonVY + tempMoonVY * (EarthM/(EarthM+MoonM));
                MoonVZ = tempCenterEarthMoonVZ + tempMoonVZ * (EarthM/(EarthM+MoonM));
            }
        }
    XML_SECTION_END;
    XML_END;
}


void ParamProb(char *szString)
{
    
    char szTemp[128] = {"0."};;
    char valX, valY, valZ, valT;
    XML_BEGIN;
    ///////////////////////////////////////////////////////////////////////////////////////Calcinfo
    XML_SECTION(CalcInfo)
    IF_XML_READ(CalculationOutputFile)
    {
        strcpy(CalulationOutputFile, pszQuo);
        if (strchr(CalulationOutputFile, '\"'))
            *strchr(CalulationOutputFile, '\"')=0;
        if (ParsURL(CalulationOutputFile, &UrlTraCalcPort, szURLTraCalcFileName,  szTraCalcFileName))
        {
        }
        else
            UrlTraCalcPort = 0;
    }
    XML_SECTION_GROUP_SEPARATOR
    //===============================================================gCRSmeasure Geocent Cel ref Sys
    XML_GROUP(gTRSmeasure)
        IF_XML_ELEMENT(T)
        {
            if (++iMAxMesaures>MAX_MEASURES)
                iMAxMesaures--;
            long double ld1=0,ld2=0;
            ConvertDateFromXML(pszQuo, ld1, measures[iMAxMesaures-1].T, ld2);
            measures[iMAxMesaures-1].X =0;
            measures[iMAxMesaures-1].Y =0;
            measures[iMAxMesaures-1].Z =0;
        }
        IF_XML_ELEMENT(M)
            measures[iMAxMesaures-1].NearBody =atoi(pszQuo);
        IF_XML_ELEMENT(X)
            measures[iMAxMesaures-1].X =atof(pszQuo);
        IF_XML_ELEMENT(Y)
            measures[iMAxMesaures-1].Y =atof(pszQuo);
        IF_XML_ELEMENT(Z)
            measures[iMAxMesaures-1].Z =atof(pszQuo);
        IF_XML_ELEMENT(H)
            measures[iMAxMesaures-1].H =atof(pszQuo);
        IF_XML_ELEMENT(LAT)
            measures[iMAxMesaures-1].LAT =atof(pszQuo);
        IF_XML_ELEMENT(LON)
            measures[iMAxMesaures-1].LON =atof(pszQuo);
        IF_XML_ELEMENT(E)
            measures[iMAxMesaures-1].Err =atof(pszQuo);
        IF_XML_ELEMENT(D1)
            measures[iMAxMesaures-1].D1 =atof(pszQuo);
        IF_XML_ELEMENT(E1)
            measures[iMAxMesaures-1].Err1 =atof(pszQuo);
        IF_XML_ELEMENT(T2)
            measures[iMAxMesaures-1].T2 =atof(pszQuo);
        IF_XML_ELEMENT(E2)
            measures[iMAxMesaures-1].ErrT2 =atof(pszQuo);
        IF_XML_ELEMENT(D3)
            measures[iMAxMesaures-1].D3 =atof(pszQuo);
        IF_XML_ELEMENT(E3)
            measures[iMAxMesaures-1].ErrD3 =atof(pszQuo);
    XML_GROUP_END

    XML_GROUP(gCRSmeasure)
        IF_XML_ELEMENT(T)
        {
            if (++iMAxMesaures>MAX_MEASURES)
                iMAxMesaures--;
            long double ld1=0,ld2=0;
            ConvertDateFromXML(pszQuo, ld1, measures[iMAxMesaures-1].T, ld2);
        }
        IF_XML_ELEMENT(M)
            measures[iMAxMesaures-1].NearBody =atoi(pszQuo);
        IF_XML_ELEMENT(X)
            measures[iMAxMesaures-1].X =atof(pszQuo);
        IF_XML_ELEMENT(Y)
            measures[iMAxMesaures-1].Y =atof(pszQuo);
        IF_XML_ELEMENT(Z)
        {
            measures[iMAxMesaures-1].Z =atof(pszQuo);
            measures[iMAxMesaures-1].H =0;
            measures[iMAxMesaures-1].LAT =0;
            measures[iMAxMesaures-1].LON =0;
        }
        IF_XML_ELEMENT(E)
            measures[iMAxMesaures-1].Err =atof(pszQuo);
        IF_XML_ELEMENT(D1)
            measures[iMAxMesaures-1].D1 =atof(pszQuo);
        IF_XML_ELEMENT(E1)
            measures[iMAxMesaures-1].Err1 =atof(pszQuo);
        IF_XML_ELEMENT(T2)
            measures[iMAxMesaures-1].T2 =atof(pszQuo);
        IF_XML_ELEMENT(E2)
            measures[iMAxMesaures-1].ErrT2 =atof(pszQuo);
        IF_XML_ELEMENT(D3)
            measures[iMAxMesaures-1].D3 =atof(pszQuo);
        IF_XML_ELEMENT(E3)
            measures[iMAxMesaures-1].ErrD3 =atof(pszQuo);
    XML_GROUP_END

    XML_GROUP(hCRSmeasure)
        IF_XML_ELEMENT(T)
        {
            if (++iMAxMesaures>MAX_MEASURES)
                iMAxMesaures--;
            long double ld1=0,ld2=0;
            ConvertDateFromXML(pszQuo, ld1, measures[iMAxMesaures-1].T, ld2);
            measures[iMAxMesaures-1].X =0;
            measures[iMAxMesaures-1].Y =0;
            measures[iMAxMesaures-1].Z =0;
            measures[iMAxMesaures-1].H =0;
            measures[iMAxMesaures-1].LAT =0;
            measures[iMAxMesaures-1].LON =0;
            measures[iMAxMesaures-1].Err =0;
            measures[iMAxMesaures-1].D1 =0;
            measures[iMAxMesaures-1].Err1 =0;
            measures[iMAxMesaures-1].T2 =0;
            measures[iMAxMesaures-1].ErrT2 =0;
            measures[iMAxMesaures-1].D3 =0;
            measures[iMAxMesaures-1].ErrD3 =0;
        }
        IF_XML_ELEMENT(M)
            measures[iMAxMesaures-1].NearBody =atoi(pszQuo);
        IF_XML_ELEMENT(X)
            measures[iMAxMesaures-1].X =atof(pszQuo);
        IF_XML_ELEMENT(Y)
            measures[iMAxMesaures-1].Y =atof(pszQuo);
        IF_XML_ELEMENT(Z)
            measures[iMAxMesaures-1].Z =atof(pszQuo);
        IF_XML_ELEMENT(H)
            measures[iMAxMesaures-1].H =atof(pszQuo);
        IF_XML_ELEMENT(LAT)
            measures[iMAxMesaures-1].LAT =atof(pszQuo);
        IF_XML_ELEMENT(LON)
            measures[iMAxMesaures-1].LON =atof(pszQuo);
        IF_XML_ELEMENT(E)
            measures[iMAxMesaures-1].Err =atof(pszQuo);
        IF_XML_ELEMENT(D1)
            measures[iMAxMesaures-1].D1 =atof(pszQuo);
        IF_XML_ELEMENT(E1)
            measures[iMAxMesaures-1].Err1 =atof(pszQuo);
        IF_XML_ELEMENT(T2)
            measures[iMAxMesaures-1].T2 =atof(pszQuo);
        IF_XML_ELEMENT(E2)
            measures[iMAxMesaures-1].ErrT2 =atof(pszQuo);
        IF_XML_ELEMENT(D3)
            measures[iMAxMesaures-1].D3 =atof(pszQuo);
        IF_XML_ELEMENT(E3)
            measures[iMAxMesaures-1].ErrD3 =atof(pszQuo);
    XML_GROUP_END

    XML_SECTION_END

    ///////////////////////////////////////////////////////////////////////////////////////SimInfo
    XML_SECTION(SimInfo)
    IF_XML_READ(SimulationType)
    {
        strcpy(SimulationType, pszQuo);
        if (strchr(SimulationType, '\"'))
            *strchr(SimulationType, '\"')=0;
    }
    IF_XML_READ(SimulationOutputFile)
    {
        strcpy(SimulationOutputFile, pszQuo);
        if (strchr(SimulationOutputFile, '\"'))
            *strchr(SimulationOutputFile, '\"')=0;

        if (ParsURL(SimulationOutputFile, &UrlTraSimPort, szURLTraSimFileName,  szTraSimFileName))
        {
        }
        else
            UrlTraSimPort = 0;

    }


    IF_XML_READ(SimulationOutputTime)
    {
        if (++SimulationOutputCount <= MAX_OUTPUT_TIMES)
        {
            long double ld1=0,ld2=0;
            ConvertDateFromXML(pszQuo, ld1, SimulationOutputTime[SimulationOutputCount-1], ld2);
        }
        else
        {
            SimulationOutputCount--;
            printf("\n Max output times for simulation limit reached - .XML file is incorrect");
        }
    }

    XML_SECTION_END

	///////////////////////////////////////////////////////////////////////////////////////MassInfo
    XML_SECTION(MassInfo)
    IF_XML_READ(ModelOutput)
    {
        strcpy(szMassPointsModelFile, pszQuo);
        if (strchr(szMassPointsModelFile, '\"'))
            *strchr(szMassPointsModelFile, '\"')=0;
    }
    IF_XML_READ(MidRandPointsFile)
    {
        strcpy(MidRandPointsFile, pszQuo);
        if (strchr(MidRandPointsFile, '\"'))
            *strchr(MidRandPointsFile, '\"')=0;
    }
    IF_XML_READ(MinH)
    {
        MinH = atof(pszQuo);
    }

    IF_XML_READ(MaxH)
    {
        MaxH = atof(pszQuo);
    }
    XML_SECTION_END

    ///////////////////////////////////////////////////////////////////////////////////////ModeInfo
    XML_SECTION(ModeInfo)
    IF_XML_READ(Mode)
    {
        strcpy(Mode, pszQuo);
        if (strchr(Mode, '\"'))
            *strchr(Mode, '\"')=0;
    }

    XML_SECTION_END
    ////////////////////////////////////////////////////////////////////////////////////////probs
    XML_SECTION(probs)
    // pisition of the prob (active by firing engines) can be set by X,Y,Z   VX,VY,VZ
        IF_XML_READ(ProbDX)
        {
            Sat.DX[Sat.Elem] = atof(pszQuo);
        }
        IF_XML_READ(ProbDY)
        {
            Sat.DY[Sat.Elem] = atof(pszQuo);
        }
        IF_XML_READ(ProbDZ)
        {
            Sat.DZ[Sat.Elem] = atof(pszQuo);
        }
        IF_XML_READ(ProbDVX)
        {
            Sat.DVX[Sat.Elem] = atof(pszQuo);
        }
        IF_XML_READ(ProbDVY)
        {
            Sat.DVY[Sat.Elem] = atof(pszQuo);
        }
        IF_XML_READ(ProbDVZ)
        {
            Sat.DVZ[Sat.Elem] = atof(pszQuo);
        }
        IF_XML_READ(ProbM)
        {
            // has to be first!!!!
            Sat.M[Sat.Elem] = atof(pszQuo);
        }
        // or by 3 punch card
        IF_XML_READ(ProbKeplerLine1)
        {
            strcpy(Sat.Kepler1[Sat.Elem], pszQuo);
            Sat.DX[Sat.Elem] = 0;Sat.DY[Sat.Elem] = 0;Sat.DZ[Sat.Elem] = 0;Sat.DVX[Sat.Elem] = 0;Sat.DVY[Sat.Elem] = 0;Sat.DVZ[Sat.Elem] = 0;
        }
        IF_XML_READ(ProbKeplerLine2)
        {
            strcpy(Sat.Kepler2[Sat.Elem], pszQuo);
        }
        IF_XML_READ(ProbSquare)
        {
            Sat.ProbSquare[Sat.Elem] = atof(pszQuo);
        }
        IF_XML_READ(ProbKeplerLine3)
        {
            char szTempo[1024];
            //int iYear;
            //int iDays;
            //double dflTemp;

            strcpy(Sat.Kepler3[Sat.Elem], pszQuo);
            //strcpy(Sat.Kepler1[0], szProbKeplerLine1);
            //strcpy(Sat.Kepler2[0], szProbKeplerLine2);
            //strcpy(Sat.Kepler3[0], szProbKeplerLine3);
			//0         1         2         3         4         5         6         7
			//01234567890123456789012345678901234567890123456789012345678901234567890
			//1 25544U 98067A   04236.56031392  .00020137  00000-0  16538-3 0  5135\
			//2 25544  51.6335 341.7760 0007976 126.2523 325.9359 15.70406856328903"
			// format readings from FORTRAN:
			// 702 FORMAT(18X,D14.8,1X,F10.8,2(1X,F6.5,I2),/,7X,2(1X,F8.4),1X,F7.7,2(1X,F8.4),1X,F11.8)
			//
		    // "04236.56031392" Element Set Epoch (UTC) D14.8
			//  04                   - year
			//    236.56031392       - day
            Sat.ProbTLEEpoch[Sat.Elem] = atof(&Sat.Kepler2[Sat.Elem][18]);
            Sat.ProbJDSec[Sat.Elem] = Sat.ProbJD[Sat.Elem] = ConverTLEEpochDate2JulianDay(Sat.ProbTLEEpoch[Sat.Elem]);
			Sat.ProbJDSec[Sat.Elem] *=  60*60*24;
            SYSTEMTIME ThatTime;
            // now for initial step asign emulation starting time:
			// if nothing is set then starting point is a last satellite epoch
            if (dStartJD == 0.0)
            {
                dStartJD = ConverTLEEpochDate2JulianDay(Sat.ProbTLEEpoch[Sat.Elem]);
                dStartTLEEpoch = ConvertJulianDayToDateAndTime(dStartJD, &ThatTime);
            }
			//  "_.00020137"      1st Derivative of the Mean Motion with respect to Time F10.8
			//double ProbFirstDervMeanMotion; XNDT2O
			COPYKEPLER(Sat.ProbFirstDervMeanMotion[Sat.Elem],&Sat.Kepler2[Sat.Elem][33],10);
			// "_00000-0"        2nd Derivative of the Mean Motion with respect to Time (decimal point assumed) 1X,F6.5,I2
			//double ProbSecondDervmeanMotion;,XNDD6O,IEXP
			memset(szTempo, 0, sizeof(szTempo)); 
            szTempo[0] = Sat.Kepler2[Sat.Elem][44]; if (szTempo[0]==' ') szTempo[0] = '0';
			szTempo[1] = '.'; 
            memcpy(&szTempo[2], &Sat.Kepler2[Sat.Elem][45], 5);
            Sat.ProbSecondDervmeanMotion[Sat.Elem] = atof(szTempo);
			if (Sat.Kepler2[Sat.Elem][50] == '-')
				Sat.ProbSecondDervmeanMotion[Sat.Elem] *= pow(10., - (Sat.Kepler2[Sat.Elem][51] - '0'));
			else //if (Sat.Kepler2[Sat.Elem][50] == '+') //is it corect ??
				Sat.ProbSecondDervmeanMotion[Sat.Elem] *= pow(10., (Sat.Kepler2[Sat.Elem][51] - '0'));
			//// "_16538-3"        B* Drag Term 1X,F6.5,I2
			//double ProbDragterm; ,BSTAR,IBEXP
			memset(szTempo, 0, sizeof(szTempo)); 
            szTempo[0] = Sat.Kepler2[Sat.Elem][53]; if (szTempo[0]==' ') szTempo[0] = '0';
			szTempo[1] = '.'; 
            memcpy(&szTempo[2], &Sat.Kepler2[Sat.Elem][54], 5);
            Sat.ProbDragterm[Sat.Elem] = atof(szTempo);
			if (Sat.Kepler2[Sat.Elem][59] == '-')
				Sat.ProbDragterm[Sat.Elem] *= pow(10., - (Sat.Kepler2[Sat.Elem][60] - '0'));
            else
                Sat.ProbDragterm[Sat.Elem] *= pow(10., (Sat.Kepler2[Sat.Elem][60] - '0'));
            if (Sat.ProbSquare[Sat.Elem] <0) // if munus value then needs to calculate square area:
            {
                Sat.ProbSquare[Sat.Elem] = Sat.ProbDragterm[Sat.Elem] / 0.15696615 *1000000;
                printf("\n Sat %d square area was calculated as =%f",Sat.Elem,Sat.ProbSquare[Sat.Elem]);
            }
			// "0"              Element Set Type
			Sat.ProbElementSetType[Sat.Elem] = Sat.Kepler2[Sat.Elem][62];
			// "_513"            Element Number
			// "5"              Checksum
			//                        The checksum is the sum of all of the character in the data line, modulo 10. 
			//                        In this formula, the following non-numeric characters are assigned the indicated values: 
			//                        Blanks, periods, letters, '+' signs -> 0
			//                        '-' signs -> 1
			// "2"             Line Number
			// "25544"         Object Identification Number
			// "_51.6335"       Orbit Inclination (degrees) 1X,F8.4
			COPYKEPLER(Sat.ProbIncl[Sat.Elem],&Sat.Kepler3[Sat.Elem][8],8);
            Sat.ProbIncl[Sat.Elem] = M_PI * Sat.ProbIncl[Sat.Elem]/180.0;
			// "341.7760"      Right Ascension of Ascending Node (degrees) 1X,F8.4
			COPYKEPLER(Sat.ProbAscNode[Sat.Elem],&Sat.Kepler3[Sat.Elem][17],8);
			Sat.ProbAscNode[Sat.Elem] = M_PI * Sat.ProbAscNode[Sat.Elem]/180.0;
			// "0007976"       Eccentricity (decimal point assumed) F7.7
			memset(szTempo, 0, sizeof(szTempo)); 
            szTempo[0] = '.'; 
            memcpy(&szTempo[1], &Sat.Kepler3[Sat.Elem][26], 7);
            Sat.ProbEcc[Sat.Elem] = atof(szTempo);
			// "126.2523"      Argument of Perigee (degrees) 1X,F8.4
			COPYKEPLER(Sat.ProbArgPer[Sat.Elem],&Sat.Kepler3[Sat.Elem][34],8);
			Sat.ProbArgPer[Sat.Elem] = M_PI * Sat.ProbArgPer[Sat.Elem]/180.0;
			// "325.9359"      Mean Anomaly (degrees) 1X,F8.4
			COPYKEPLER(Sat.ProbMeanAnom[Sat.Elem],&Sat.Kepler3[Sat.Elem][43],8);
			Sat.ProbMeanAnom[Sat.Elem] = M_PI * Sat.ProbMeanAnom[Sat.Elem]/180.0;
			// "15.70406856"    Mean Motion (revolutions/day)F11.8
			COPYKEPLER(Sat.ProbTPeriod[Sat.Elem],&Sat.Kepler3[Sat.Elem][52],11);
			Sat.ProbMeanMotion[Sat.Elem] = Sat.ProbTPeriod[Sat.Elem];
			
            printf("\n calc ProbTPeriod=%f ", Sat.ProbTPeriod[Sat.Elem]);
            Sat.ProbTDays[Sat.Elem] = 1.0/Sat.ProbTPeriod[Sat.Elem];
            printf("\n calc ProbTDays=%f ", Sat.ProbTDays[Sat.Elem]);
            Sat.ProbTSec[Sat.Elem] = Sat.ProbTDays[Sat.Elem] * 24. * 60. * 60.;
            printf("\n calc ProbTSec=%f ", Sat.ProbTSec[Sat.Elem]);
			// "328903"        Revolution Number at Epoch
			COPYKEPLER(Sat.ProbRevAtEpoch[Sat.Elem],&Sat.Kepler3[Sat.Elem][63],6);
            Sat.Elem++;  // next satellite
        }
    XML_SECTION_END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////TraInfo
    XML_SECTION(TraInfo)
        IF_XML_READ(EarthModelFile)
        {
            strcpy(EarthModelFile, pszQuo);
            if (strchr(EarthModelFile, '\"'))
            {
                *strchr(EarthModelFile, '\"')=0;
            }
        }
        IF_XML_READ(EarthModelCoefs)
        {
            EarthModelCoefs = atoi(pszQuo);
        }
        IF_XML_READ(CpuCore)
        {
            CpuCore = atoi(pszQuo);
        }
        IF_XML_READ(GM_MODEL)
        {
            GM_MODEL = atof(pszQuo);
        }
        IF_XML_READ(R0_MODEL)
        {
            R0_MODEL = atof(pszQuo);
        }
        // finding the tag "UseJPLxyz" will force to retrive all solar sistem parameters from the JPL data
        IF_XML_READ(UseJPLxyz)
        {
            long double tempProbX;
            long double tempProbY;
            long double tempProbZ;
            long double tempProbVX;
            long double tempProbVY;
            long double tempProbVZ;

			long double tProbX=0.;
            long double tProbY=0.;
            long double tProbZ=0.;
            long double tProbVX=0.;
            long double tProbVY=0.;
            long double tProbVZ=0.;
            // V of the earth calulated = sqrt(GM * (2/R - 1/a)))
            // where GM - graviattional constant of a EarthMoon baricenter
            //       R - distance from baricenter to center of earth
            //       a - half of big axe of a orbit of a Earth around baricenter
            // first assumption a==R in this case V = sqrt(GMEarthMoon * 1/R)
            // 
            //VMoonOrbit = sqrt(GMEarthMoon / RBarisMoon);
            //VMoonOrbit = sqrt(GMEarthMoon * (2.0/ RBarisMoon - 1.0/(405696000.0*(EarthM/(EarthM+MoonM))) ));
            //VMoonOrbit = sqrt(GMEarthMoon * (2.0/ RBarisMoon - 1.0/(405696000.0*(EarthM/(EarthM+MoonM))) ));
            //aproxim = 155.23657531046074952275554885572/aproxim;
            //aproxim = -2.4009724978895439513029247826218;//1.0496393116944882060883002708885;//2.4;//aproxim*aproxim;
            //aproxim = -1.0496393116944882060883002708885;
            //aproxim = - 0.5728;
            
            AssignFromNASAData(&SolarSystem, dStartJD);
       
            printf("\n uses JPL coordinates and velocities");
            
            //AjustKeplerPosition(Sat.ProbTSec[Sat.Elem],ProbAph,ProbPer,ProbSmAx,Sat.ProbEcc[Sat.Elem], 
            //       Sat.ProbIncl[Sat.Elem], Sat.ProbAscNode[Sat.Elem], Sat.ProbArgPer[Sat.Elem], Sat.ProbEpochS[Sat.Elem], ProbCurTimeS);
            //printf("\n Was  A Prob = %f", ProbSmAx);
			//0         1         2         3         4         5         6         7
			//01234567890123456789012345678901234567890123456789012345678901234567890
			//1 25544U 98067A   04236.56031392  .00020137  00000-0  16538-3 0  5135\
			//2 25544  51.6335 341.7760 0007976 126.2523 325.9359 15.70406856328903"
			// format readings from FORTRAN:
			// 702 FORMAT(18X,D14.8,1X,F10.8,2(1X,F6.5,I2),/,7X,2(1X,F8.4),1X,F7.7,2(1X,F8.4),1X,F11.8)
			//
		    // "04236.56031392" Element Set Epoch (UTC) D14.8
			//  04                   - year
			//    236.56031392       - day
			// double ProbEpochS;
			//  "_.00020137"      1st Derivative of the Mean Motion with respect to Time F10.8
			//double ProbFirstDervMeanMotion; XNDT2O
			// "_00000-0"        2nd Derivative of the Mean Motion with respect to Time (decimal point assumed) 1X,F6.5,I2
			//double ProbSecondDervmeanMotion;,XNDD6O,IEXP
			//// "_16538-3"        B* Drag Term 1X,F6.5,I2
			//double ProbDragterm; ,BSTAR,IBEXP
			// "0"              Element Set Type
			//unsigned char ProbElementSetType;
		    // "2"             Line Number
			// "25544"         Object Identification Number
			// "_51.6335"       Orbit Inclination (degrees) 1X,F8.4
			//double ProbIncl;
			// "341.7760"      Right Ascension of Ascending Node (degrees) 1X,F8.4
			//double ProbAscNode;
			// "0007976"       Eccentricity (decimal point assumed) F7.7
			//double ProbEcc;
			// "126.2523"      Argument of Perigee (degrees) 1X,F8.4
			//double ProbArgPer;
			//double ProbPer;
			// "325.9359"      Mean Anomaly (degrees) 1X,F8.4
			//double ProbMeanAnom;
			// "15.70406856"    Mean Motion (revolutions/day)F11.8
			//double ProbMeanMotion; XNO
			// "328903"        Revolution Number at Epoch
			//double ProbRevAtEpoch;
			
			// just cheking GST must be eq GreenwichA
			SUN_08 (1950,1,0,0,0,GST,SLONG,SRASN,SDEC);
			dStartGreenwichA = GreenwichAscensionFromTLEEpoch(50000.0,Sat.precEps,Sat.precTet,Sat.precZ,Sat.nutEpsilon,Sat.nutDFeta); // 50 000.0 == 1950, day 1( first of january), 00:00:00 
            // error is:
            //   GST =  1.7466460286076149
            // dStartGreenwichA = -0.0000017029127985
            // error in seconds== -0.01561115459725791718482933112546
            SYSTEMTIME ThatTime;
            int YY_Days = ConvertJulianDayToDateAndTime(dStartJD, &ThatTime);
            int Days_in_Year = YY_Days % 1000;
            // now for <TRA:setting name="dStartJD" value="07/05/14 08:28:00:000" />
            // dStartJD = 2456784.8527777777
            // dStartEpoch = 14127.352777777705
            SUN_08 (ThatTime.wYear,Days_in_Year,ThatTime.wHour,ThatTime.wMinute,ThatTime.wSecond,GST,SLONG,SRASN,SDEC);
            dStartGreenwichA = GreenwichAscensionFromTLEEpoch(dStartTLEEpoch,Sat.precEps,Sat.precTet,Sat.precZ,Sat.nutEpsilon,Sat.nutDFeta);
            // error is:
            // GST = 6.1453506996084499
            // dStartGreenwichA 6.1454312968999147
            // error in sec 0.7388615425790099904549342040562

            // all sat positions will be in absolut coordinates 
            // for first sat TLE (at Epoch time) earth was in one position
            // at dStartEpoch it will be on another
            // to account in graviational potential the shape of the earth 
            // needs to know this position
            //dStartGreenwichA = GreenwichAscensionFromTLEEpoch(Sat.ProbEpoch[0],Sat->precEps,Sat->precTet,Sat->precZ,Sat->nutEpsilon,Sat->nutDFeta);
            for (int nSat = 0; nSat <Sat.Elem; nSat++)
            {
                long double AE = 1.0;
                long double BSTAR=Sat.ProbDragterm[nSat]/AE;
                
			    if ( memcmp(UseSatData, "SGP",3)==0)
                {

                    //Sat.ProbEpochOnStart[nSat] =fmod(dStartJD - Sat.ProbJD[nSat],1.0/Sat.ProbMeanMotion[nSat]);

#if _USE_ORIGINAL
	                long double XKMPER = 6378.1350;//XKMPER kilometers/Earth radii 6378.135
#else
	                long double XKMPER = 6378.137;
#endif
			        //long double XKE = BIG_XKE;//.743669161E-1;
                    //XKE = sqrt(Gbig * SolarSystem.M[EARTH])*pow(AE/*(long double)6378.1350*//(long double)1440.0, (long double)3.0/(long double)2.0);;
			        //long double XJ2 = 1.082616E-3;
			        //long double CK2=.5*XJ2*AE*AE;
			        //double XMNPDA = 1440.0;
			        //double TEMP=2.0*M_PI/XMNPDA/XMNPDA;
			        //double XNO=ProbMeanMotion*TEMP*XMNPDA;

    			    long double XMNPDA = 1440.0; // XMNPDA time units(minutes) in day is 1440.0 minutes
	    		    long double TEMP=2*M_PI/XMNPDA/XMNPDA; // 2*pi / (1440 **2)
		    	    long double XNO=Sat.ProbMeanMotion[nSat]*TEMP*XMNPDA; // rotation per day * 2*pi /1440 == rotation per day on 1 unit (1 min)
			        long double XNDT2O=Sat.ProbFirstDervMeanMotion[nSat]*TEMP;
			        long double XNDD6O=Sat.ProbSecondDervmeanMotion[nSat]*TEMP/XMNPDA;

    			    /*
	    		    long double A1=pow((XKE/XNO),(long double)2.0/(long double)3.0);
		    	    TEMP=1.5*CK2*(3.*cos(Sat.ProbIncl[nSat])*cos(ProbIncl)-1.)/pow((1.-Sat.ProbEcc[nSat]*Sat.ProbEcc[nSat]),(long double)1.5);
			        long double DEL1=TEMP/(A1*A1);
			        long double AO=A1*(1.-DEL1*(.5*(2.0/3.0)+DEL1*(1.+134./81.*DEL1)));
			        long double DELO=TEMP/(AO*AO);
			        long double XNODP=XNO/(1.+DELO);
			        //IF((TWOPI/XNODP/XMNPDA) .GE. .15625) IDEEP=1
                    */
			        
			        //TSINCE=TS
			        //IFLAG=1
			        // first one does not use BSTAR
			        //SGP((Sat.ProbEpochOnStart[nSat])*XMNPDA, XNDT2O,XNDD6O,BSTAR,Sat.ProbIncl[nSat], Sat.ProbAscNode[nSat],Sat.ProbEcc[nSat], 
                    //               Sat.ProbArgPer[nSat], Sat.ProbMeanAnom[nSat],XNO, 
			        //	tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
			        //tProbX=tProbX*XKMPER/AE*1000.0;
			        //tProbY=tProbY*XKMPER/AE*1000.0;
			        //tProbZ=tProbZ*XKMPER/AE*1000.0;
			        //tProbVX=tProbVX*XKMPER/AE*XMNPDA/86400.*1000.0;
			        //tProbVY=tProbVY*XKMPER/AE*XMNPDA/86400.*1000.0;
			        //tProbVZ=tProbVZ*XKMPER/AE*XMNPDA/86400.*1000.0;
			        // second one does not use XNDT2O,XNDD6O
                    // in next call XN0 and ProbMeanMotion connected by a formula:
                    // Sat.ProbMeanMotion[nSat] = XNO / (2*pi) * 1440.0
                    if (memcmp(UseSatData, "SGP4",4)==0)
			            SGP4((dStartJD - Sat.ProbJD[nSat])*XMNPDA, XNDT2O,XNDD6O,BSTAR,Sat.ProbIncl[nSat], Sat.ProbAscNode[nSat],Sat.ProbEcc[nSat], 
                            Sat.ProbArgPer[nSat], Sat.ProbMeanAnom[nSat],XNO, 
	    			        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                    else if (memcmp(UseSatData, "SGP8",4)==0)
                        SGP8((dStartJD - Sat.ProbJD[nSat])*XMNPDA, XNDT2O,XNDD6O,BSTAR,Sat.ProbIncl[nSat], Sat.ProbAscNode[nSat],Sat.ProbEcc[nSat], 
                            Sat.ProbArgPer[nSat], Sat.ProbMeanAnom[nSat],XNO, 
	    			        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                    else if (memcmp(UseSatData, "SGP",3)==0)
                        SGP((dStartJD - Sat.ProbJD[nSat])*XMNPDA, XNDT2O,XNDD6O,BSTAR,Sat.ProbIncl[nSat], Sat.ProbAscNode[nSat],Sat.ProbEcc[nSat], 
                            Sat.ProbArgPer[nSat], Sat.ProbMeanAnom[nSat],XNO, 
	    			        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                    else
                    {
                        printf("\n error in UseSatData == unknown value");
                        exit(99);
                    }

		    	    tProbX=tProbX*XKMPER/AE*1000.0;
			        tProbY=tProbY*XKMPER/AE*1000.0;
			        tProbZ=tProbZ*XKMPER/AE*1000.0;
			        tProbVX=tProbVX*XKMPER/AE*XMNPDA/86400.*1000.0;
			        tProbVY=tProbVY*XKMPER/AE*XMNPDA/86400.*1000.0;
			        tProbVZ=tProbVZ*XKMPER/AE*XMNPDA/86400.*1000.0;
                    // SGP4
                    Sat.X[nSat] = tProbX + SolarSystem.X[EARTH];
                    Sat.Y[nSat] = tProbY + SolarSystem.Y[EARTH];
                    Sat.Z[nSat] = tProbZ + SolarSystem.Z[EARTH];
                    Sat.VX[nSat] = tProbVX + SolarSystem.VX[EARTH];
                    Sat.VY[nSat] = tProbVY + SolarSystem.VY[EARTH];
                    Sat.VZ[nSat] = tProbVZ + SolarSystem.VZ[EARTH];
                }
                else // Kepler
                {
                    KeplerPosition(Sat.ProbJD[nSat],dStartJD,      // prob epoch, and curent time
	    			    Sat.ProbTSec[nSat], // - orbit period in sec
		    		    Sat.ProbEcc[nSat],             // - Eccentricity
                        Sat.ProbIncl[nSat],            // - Inclination
                        Sat.ProbAscNode[nSat],         // - Longitude of ascending node
                        Sat.ProbArgPer[nSat],          // - Argument of perihelion
                        Sat.ProbMeanAnom[nSat],        // - Mean Anomaly (degrees)
                        BSTAR,
                        Gbig *SolarSystem.M[EARTH],1,
                        tempProbX,tempProbY,tempProbZ,tempProbVX,tempProbVY,tempProbVZ, Sat.ProbMeanMotion[nSat]);

                    //Sat.Lambda = dStartGreenwichA;
                    //Sat.Lambda  = M_PI * 15.0 / 8.0; //3.0 / 8.0; 11.0 / 8.0;
                    //Sat.M[0] = ProbM;
                    Sat.X[nSat] = tempProbX + SolarSystem.X[EARTH];
                    Sat.Y[nSat] = tempProbY + SolarSystem.Y[EARTH];
                    Sat.Z[nSat] = tempProbZ + SolarSystem.Z[EARTH];
                    Sat.VX[nSat] = tempProbVX + SolarSystem.VX[EARTH];
                    Sat.VY[nSat] = tempProbVY + SolarSystem.VY[EARTH];
                    Sat.VZ[nSat] = tempProbVZ + SolarSystem.VZ[EARTH];

			        long double tProbTSec = 0;
			        long double tProbEcc = 0;
                    long double tProbIncl = 0;
                    long double tProbAscNode = 0;
                    long double tProbArgPer = 0;
                    long double tProbMeanAnom = 0;
            
    			    /*
	    		    //long double e_ecc = Sat.ProbEcc[nSat];
		    	    //long double e_incl = Sat.ProbIncl[nSat];
			        //long double e_asc_node = Sat.ProbAscNode[nSat];
			        //long double e_arg_per = Sat.ProbArgPer[nSat];
			        //long double e_mean_anomaly = Sat.ProbMeanAnom[nSat];
			        long double e_q=0.0;
			        long double e_major_axis=0.0;
			        long double e_t0=0.0;
			        long double e_w0=0.0;
			        long double e_angular_momentum=0.0;
			        long double e_perih_time=0.0;
			        long double e_minor_to_major=0.0;
			        long double e_lon_per=0.0;
			        long double e_sideways_x=0.0;
			        long double e_sideways_y=0.0;
			        long double e_sideways_z=0.0;
			        long double vec_x=0.0;
			        long double vec_y=0.0;
			        long double vec_z=0.0;
			        long double e_perih_vec_x=0.0,e_perih_vec_y=0.0,e_perih_vec_z=0.0;
			        long double loc_x=0.0, loc_y=0.0, loc_z=0.0, loc_r=0.0,vel_x=0.0,vel_y=0.0,vel_z=0.0,t=0.0;
    
    	    		// first (mass) from NASA and second is just convinient constant
	    	    	long double gm = SolarSystem.M[EARTH] * Gbig;

    	    		long double e_epoch = Sat.ProbEpoch[Sat.Elem]*24.0*60.0*60.0;
                    
			        do_element_setup( e_epoch, Sat.ProbEcc[nSat], Sat.ProbIncl[nSat], Sat.ProbAscNode[nSat], Sat.ProbArgPer[nSat],Sat.ProbMeanAnom[nSat],
								e_q, e_major_axis,e_t0,e_w0,e_angular_momentum,e_perih_time,
								e_minor_to_major, e_lon_per,
								e_sideways_x, e_sideways_y, e_sideways_z,
								vec_x, vec_y,vec_z, gm, Sat.ProbTSec[Sat.Elem]);
			        // this will reset mean anomaly to time == dStartJD*24.0*60.0*60.0
			        posn_and_vel( e_epoch, Sat.ProbEcc[nSat], Sat.ProbIncl[nSat], Sat.ProbAscNode[nSat], Sat.ProbArgPer[nSat],Sat.ProbMeanAnom[nSat],
						e_q, e_major_axis,e_t0,e_w0,e_angular_momentum,e_perih_time,
						e_minor_to_major, e_lon_per,
						e_sideways_x, e_sideways_y, e_sideways_z,
						vec_x,vec_y,vec_z,
						loc_x, loc_y, loc_z, loc_r,vel_x,vel_y,vel_z,dStartJD*24.0*60.0*60.0, gm);
						*/
			        long double tVX = tempProbVX;
			        long double tVY = tempProbVY;
			        long double tVZ = tempProbVZ;
// that is for debugging GPS sattelites only
#if 0

                    //01234567890123456789012345678901234567890123456789012345678901234567890
                    //1 25544U 98067A   04236.56031392  .00020137  00000-0  16538-3 0  5135\
                    //2 25544  51.6335 341.7760 0007976 126.2523 325.9359 15.70406856328903"
                    //    };
                    // "ISS (ZARYA)"    The common name for the object based on information from the SatCat.
                    // "1"              Line Number
                    // "25544"          Object Identification Number
                    // "U"              Elset Classification
                    // "98067A"         International Designator
                    //  98                   - designate the launch year of the object
                    //    067                - launch number, starting from the beginning of the year
                    //       A               - indicates the piece of the launch: "A" is a payload 
                    // "04236.56031392" Element Set Epoch (UTC)
                    //  04                   - year
                    //    236.56031392       - day
                    // "_.00020137"      1st Derivative of the Mean Motion with respect to Time
                    // "_00000-0"        2nd Derivative of the Mean Motion with respect to Time (decimal point assumed)
                    // "_16538-3"        B* Drag Term
                    // "0"              Element Set Type
                    // "_513"            Element Number
                    // "5"              Checksum
                    //                        The checksum is the sum of all of the character in the data line, modulo 10. 
                    //                        In this formula, the following non-numeric characters are assigned the indicated values: 
                    //                        Blanks, periods, letters, '+' signs -> 0
                    //                        '-' signs -> 1
                    // "2"             Line Number
                    // "25544"         Object Identification Number
                    // "_51.6335"       Orbit Inclination (degrees)
                    // "341.7760"      Right Ascension of Ascending Node (degrees)
                    // "0007976"       Eccentricity (decimal point assumed)
                    // "126.2523"      Argument of Perigee (degrees)
                    // "325.9359"      Mean Anomaly (degrees)
                    // "15.70406856"    Mean Motion (revolutions/day)
                    // "328903"        Revolution Number at Epoch

                    // NAVSTAR 54 (USA 177)
                    // 1 28190U 04009A   12103.48551084  .00000032  00000-0  10000-3 0  3101
                    // 2 28190 055.0111 121.3785 0080561 006.7787 353.3670 02.00552748 59113
                    //
                    //         orbit inclanation
                    //                  Right Ascension of Ascending Node



                    // testing GPS sattelite #0x13=19 on UTC= 492765.99999995105 week: 1683 time 16:52:46
                    long double m1ProbTSec, m1ProbEcc, m1ProbIncl, m1ProbAscNode, m1ProbArgPer, m1ProbMeanAnom;
                    long double m2ProbTSec, m2ProbEcc, m2ProbIncl, m2ProbAscNode, m2ProbArgPer, m2ProbMeanAnom;
                    tProbX = -24891582.164414;
                    tProbY = -6179787.716544;
                    tProbZ = 7602393.375224;
                    tProbVX = -760.24581128329362;
                    tProbVY = -633.026865;
                    tProbVZ = -2950.637702;
                    DumpKeplers(m1ProbTSec, // - orbit period in sec
		    		    m1ProbEcc,             // - Eccentricity
                        m1ProbIncl,            // - Inclination
                        m1ProbAscNode,         // - Longitude of ascending node
                        m1ProbArgPer,          // - Argument of perihelion
                        m1ProbMeanAnom,        // - Mean Anomaly (degrees)
                        SolarSystem.M[EARTH],0.0,
                        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
				    m1ProbIncl = m1ProbIncl / M_PI * 180;
				    m1ProbAscNode = m1ProbAscNode / M_PI * 180;
				    m1ProbArgPer = m1ProbArgPer / M_PI * 180;
				    m1ProbMeanAnom = m1ProbMeanAnom / M_PI * 180;
                    // tProbArgPer	6.0013685480087604	double 343.85308910345697
		            // tProbAscNode	0.28308821186056238	double 16.219759769515520
		            // tProbEcc	0.35006709180942119	double
		            // tProbIncl	1.4375592933975376	double 82.366080311487735
		            // tProbMeanAnom	3.1240698993743474	double 178.99602013800990
		            // tProbTSec	27757.763563012952	double
		        
                    // testing GPS sattelite #13 on UTC= 492841.99999994022 (75.99999998917 sec later)
                    tProbX = -24948509.734849;
                    tProbY = -6227303.238357;
                    tProbZ = 7377692.112397;
                    tProbVX = -737.80818258029888;
                    tProbVY = -617.413576;
                    tProbVZ = -2962.493300;
                    DumpKeplers(m2ProbTSec, // - orbit period in sec
				        m2ProbEcc,             // - Eccentricity
                        m2ProbIncl,            // - Inclination
                        m2ProbAscNode,         // - Longitude of ascending node
                        m2ProbArgPer,          // - Argument of perihelion
                        m2ProbMeanAnom,        // - Mean Anomaly (degrees)
                        SolarSystem.M[EARTH],0.0,
                        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
				    m2ProbIncl = m2ProbIncl / M_PI * 180;
				    m2ProbAscNode = m2ProbAscNode / M_PI * 180;
				    m2ProbArgPer = m2ProbArgPer / M_PI * 180;
				    m2ProbMeanAnom = m2ProbMeanAnom / M_PI * 180;
                    // tProbArgPer	6.0101929578191724	double 344.35869054228738
		            // tProbAscNode	0.28215312764826711	double 16.166183390661683
		            // tProbEcc	0.34889965261994360	double
		            // tProbIncl	1.4407074570581755	double 82.546456802458735
		            // tProbMeanAnom	3.1243871650157362	double 179.01419812024599
		            // tProbTSec	27795.543500545853	double
                    // position and Keplers does not match == something wrong - also wrong inclanation that sattelite must be 55 degree
#endif
#if 0
    				// mean amomaly on curent time
	    			DumpKeplers(tProbTSec, // - orbit period in sec
		    		    tProbEcc,             // - Eccentricity
                        tProbIncl,            // - Inclination
                        tProbAscNode,         // - Longitude of ascending node
                        tProbArgPer,          // - Argument of perihelion
                        tProbMeanAnom,        // - Mean Anomaly (degrees)
                        SolarSystem.M[EARTH],0.0,
                        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
			    	tProbIncl = tProbIncl / M_PI * 180;
				    tProbAscNode = tProbAscNode / M_PI * 180;
    				tProbArgPer = tProbArgPer / M_PI * 180;
	    			tProbMeanAnom = tProbMeanAnom / M_PI * 180;
                    // mean amomaly on curent time
			    	DumpKeplers(tProbTSec, // - orbit period in sec
				        tProbEcc,             // - Eccentricity
                        tProbIncl,            // - Inclination
                        tProbAscNode,         // - Longitude of ascending node
                        tProbArgPer,          // - Argument of perihelion
                        tProbMeanAnom,        // - Mean Anomaly (degrees)
                        SolarSystem.M[EARTH],0.0,
                        tempProbX,tempProbY,tempProbZ,tempProbVX,tempProbVY,tempProbVZ);
	    			tProbIncl = tProbIncl / M_PI * 180;
		    		tProbAscNode = tProbAscNode / M_PI * 180;
			    	tProbArgPer = tProbArgPer / M_PI * 180;
				    tProbMeanAnom = tProbMeanAnom / M_PI * 180;
                    // mean amomaly on curent time
	    			/*DumpKeplers(tProbTSec, // - orbit period in sec
		    		    tProbEcc,             // - Eccentricity
                        tProbIncl,            // - Inclination
                        tProbAscNode,         // - Longitude of ascending node
                        tProbArgPer,          // - Argument of perihelion
                        tProbMeanAnom,        // - Mean Anomaly (degrees)
                        SolarSystem.M[EARTH],0.0,
                        tempProbX,tempProbY,tempProbZ,vel_x,vel_y,vel_z);
				    tProbIncl = tProbIncl / M_PI * 180;
				    tProbAscNode = tProbAscNode / M_PI * 180;
				    tProbArgPer = tProbArgPer / M_PI * 180;
				    tProbMeanAnom = tProbMeanAnom / M_PI * 180;

    				long double VecAngle = AngleBtw(tempProbVX,tempProbVY,tempProbVZ,vel_x,vel_y,vel_z);
	    			printf("\n angle =%f",VecAngle);
		    		*/
			    	//printf(" 
#endif
			    }

                //printf("\n Was ProbPer = %f", ProbPer);
                //printf("\n Was ProbAph = %f", ProbAph);

                // adjust Prob + earth position and speed based on a point of a centre of gravity
                // for today only one sattelite
                //Sat.Elem = 1;
                Sat.flInUse[nSat] = 1;
                Sat.X[nSat] += Sat.DX[nSat]; Sat.Y[nSat] += Sat.DY[nSat]; Sat.Z[nSat] += Sat.DZ[nSat];
                Sat.VX[nSat] += Sat.DVX[nSat]; Sat.VY[nSat] += Sat.DVY[nSat]; Sat.VZ[nSat] += Sat.DVZ[nSat];

            }    
            // this is done to reduce errors and avoid unnessary 5 mul/div operations
            // temporary X_, VX_ will just added (in paralel calculations can be done actualy faster) 
            SolarSystem.TimeSl = TimeSl;
            SolarSystem.TimeSl_2= SolarSystem.TimeSl*SolarSystem.TimeSl;
            for (int i = 0; i <Sat.Elem; i++)
            {
                Sat.VX_[i] = 0 ;
                Sat.VY_[i] = 0;
                Sat.VZ_[i] = 0;

                Sat.X_[i] = 0 ;
                Sat.Y_[i] = 0 ;
                Sat.Z_[i] = 0 ;

                Sat.X0divDt2[i]=Sat.X[i] /SolarSystem.TimeSl_2;
                Sat.Y0divDt2[i]=Sat.Y[i] /SolarSystem.TimeSl_2;
                Sat.Z0divDt2[i]=Sat.Z[i] /SolarSystem.TimeSl_2;
                Sat.VX0divDt[i]=Sat.VX[i] /SolarSystem.TimeSl;
                Sat.VY0divDt[i]=Sat.VY[i] /SolarSystem.TimeSl;
                Sat.VZ0divDt[i]=Sat.VZ[i] /SolarSystem.TimeSl;
                Sat.iAtm[i] = 1;
            }
            Sat.CountNx = 0; Sat.CountNy = 0; Sat.CountNz = 0;
            Sat.RunOne = TRUE;
            // the amoun of yhe core can be grabed from kernel - but it will be nice to have a control


#ifndef _NO_GM_CORRECTION
            ModelCoef = SolarSystem.GM[EARTH]/ GM_MODEL;
#else
            ModelCoef = 1;
#endif
            
#ifdef USE_MODEL_LOAD
            Sat.iLeg = EarthModelCoefs;
            iCounter_nk_lm_Numbers =0;
            FILE *FileC_S = fopen(EarthModelFile,"r");
            //FILE *FileC_S = fopen("JGM3.txt","r");
            if (FileC_S == NULL)
            {
                printf("\n file with C and S dose not exsists");
                exit(555);
            }
            char szTemp[512];
            Sat._SQRT3= sqrt((long double)3.0);
            Sat._p_n_k[1]= Sat._SQRT3;
            long double _P_N_K = 3.0;

            for (int n = 2 ; n <= Sat.iLeg; n++)
            {
                //l	m	            C                                S
	            //2	0	  -0.10826360229840D-02	                       0.0
                long double CNK;
                long double SNK;
                long double Factor1;
                long double Factor2;
                long double Factor3;
                long double Betta;
                for (int k = 0; k <= n; k++)
                {
                    memset(szTemp, 0, sizeof(szTemp));
                    fgets(szTemp, sizeof(szTemp), FileC_S);
                    char *ptrD = szTemp;
                    int iDataCount = 0;
                    for (int ic= 0; ic <sizeof(szTemp); ic++,ptrD++)
                    {
                        if (*ptrD != ' ')
                        {
                            switch(iDataCount)
                            {
                            case 0:iDataCount++; nk_lm_Numbers[iCounter_nk_lm_Numbers][0] = atoi(ptrD);  if (nk_lm_Numbers[iCounter_nk_lm_Numbers][0] != n) { printf("\n worng C S file"); exit(777); }
                                break;
                            case 2:iDataCount++; nk_lm_Numbers[iCounter_nk_lm_Numbers][1] = atoi(ptrD);  if (nk_lm_Numbers[iCounter_nk_lm_Numbers][1] != k) { printf("\n worng C S file"); exit(777); }
                                break;
                            case 4:iDataCount++; C_S_nk[iCounter_nk_lm_Numbers][0] = atof(ptrD);  
                                break;
                            case 6:iDataCount++; C_S_nk[iCounter_nk_lm_Numbers][1] = atof(ptrD);  
                                goto DONE_WITH_LINE;
                                break;
                            }
                        }
                        else
                        {
                            switch(iDataCount)
                            {
                            case 1: iDataCount++;break;
                            case 3: iDataCount++;break;
                            case 5: iDataCount++;break;
                            case 7: iDataCount++;break;
                            }
                        }
                    }
DONE_WITH_LINE:
                    Factor1 =1.0;
                    Factor2 =1.0;
                    Factor3 =1.0;
                    int m,m1;
                    for (m= n-k; m >=1; m--)
                    {
                        Factor1 *= (long double)m;
                    }
                    for (m= n+k; m >=1; m--)
                    {
                        Factor2 *= (long double)m;
                    }

                    
                    for (m = n-k, m1= n+k; (m >=1) || (m1 >=1); m--,m1--)
                    {
                        if ((m >= 1) && (m1 >=1))
                        {
                            Factor3 *= (long double)m/(long double)m1;
                        }
                        else if (m >= 1)
                        {
                            Factor3 *= (long double)m;
                        }
                        else // (m1 >=1)
                        {
                            Factor3 /= (long double)m1;
                        }

                    }

                    // CNK = sqrt(2*(2*n+1)) * sqrt(((n-k)!/(n+k)!) * Clm
                    // SNK = sqrt(2*(2*n+1) * sqrt((n-k)!/(n+k)!)) * Slm
                    if (k == 0)
                        Betta = 1.0;
                    else
                        Betta = 2.0;
                    
                     if (n==2 && k ==2)
                     {
                         //C_S_nk[iCounter_nk_lm_Numbers][0]+=1.3*1.39e-8;
                         //Sat.CNK[n][k]+=1.3*1.39e-8;
                     }
#ifndef _NORMALIZED_COEF
                    CNK = sqrt(Betta*(2*(long double)n+1) * Factor1/Factor2) * C_S_nk[iCounter_nk_lm_Numbers][0];

                     CNK = sqrt(Betta*(2*(long double)n+1) * Factor3) * C_S_nk[iCounter_nk_lm_Numbers][0];
                     
                    SNK = sqrt(Betta*(2*(long double)n+1) * Factor1/Factor2) * C_S_nk[iCounter_nk_lm_Numbers][1];

                     SNK = sqrt(Betta*(2*(long double)n+1) * Factor3) * C_S_nk[iCounter_nk_lm_Numbers][1];
#endif
                     if (k==0)
                        Sat._pt_nk[n][k] = sqrt((long double)n*(n + 1)/2.0); // z
                     else
                     {
                         if ((n-k)*(n+k+1) == 0)
                            Sat._pt_nk[n][k] = 0.0;
                         else
                            Sat._pt_nk[n][k] = sqrt((long double)(n-k)*(n+k+1));
                     }
                     if (k!=n)
                     {
                        Sat._tp_nm1_k[n][k] = sqrt((long double)((2*n-1)*(2*n+1))/((long double)((n+k)*(n-k))));  // xin
                        if (k==0)
                             Sat._tp_nm2_k[n][k]= 0;  //eta
                        else
                             Sat._tp_nm2_k[n][k]= sqrt((long double)((2*n+1)*(n+k-1)*(n-k-1))/(long double)((n+k)*(n-k)*(2*n-3)));
                     }
                     
                     if (iCounter_nk_lm_Numbers == 0 && n < 2)
                         continue;
                     nk_lm_Numbers[iCounter_nk_lm_Numbers][0] = n;
                     nk_lm_Numbers[iCounter_nk_lm_Numbers][1] = k;
#ifndef _NORMALIZED_COEF
                     C_S_nk[iCounter_nk_lm_Numbers][0] =CNK;
                     C_S_nk[iCounter_nk_lm_Numbers][1] =SNK;
#endif
                     /* some starange corrections
                     if (n==2 && k == 0)
                        C_S_nk[iCounter_nk_lm_Numbers][0] =0.108262982131e-2;
                     if (n==4 && k == 0)
                        C_S_nk[iCounter_nk_lm_Numbers][0] =-.237091120053e-05;
                     if (n==6 && k == 0)
                        C_S_nk[iCounter_nk_lm_Numbers][0] =0.608346498882e-8;
                     if (n==8 && k == 0)
                        C_S_nk[iCounter_nk_lm_Numbers][0] =-0.142681087920e-10;
                     if (n==10 && k == 0)
                        C_S_nk[iCounter_nk_lm_Numbers][0] =0.121439275882e-13;
                    */
                     if (iCounter_nk_lm_Numbers++ >= TOTAL_COEF*TOTAL_COEF)
                     {
                         printf("\n something wrong with coef");
                         exit(555);
                     }
                }
                Sat._p_n_m_1[n] = sqrt((long double)(2*n +1)*(2*n -1))/long double(n);  // alfa
                Sat._p_n_m_2[n] = sqrt((long double)(2*n +1)/(long double)(2*n -3)) * (long double)(n -1)/long double(n); // betta
                Sat.diagonal[n] = _P_N_K;
                _P_N_K *= (long double)(2*n+1);
                Sat._tpk_n_k[n] = sqrt((long double)(2*n+1))*Sat._p_n_k[n-1];
                Sat._p_n_k[n] = sqrt((long double)(2*n+1)/(long double)(2*n)) * Sat._p_n_k[n-1];
            }

#else
            // amount of J coeff used in calcualtion
#ifdef USE_MODEL_0
            Sat.iLeg = 6;
#endif
#ifdef USE_MODEL_1
            Sat.iLeg = 8;
#endif
#ifdef USE_MODEL_2
            Sat.iLeg = 16;
#endif
#ifdef USE_MODEL_3
            Sat.iLeg = 16;
#endif

            iCounter_nk_lm_Numbers =0;
            for (int n = 0 ; n <= Sat.iLeg; n++)
            {
                
                //l	m	            C                                S
	            //2	0	  -0.10826360229840D-02	                       0.0
                Sat.J[n] = //sqrt(2*(long double)n+1)* // coeff already normalized
                    (Clm[0][n]);
                long double CNK;
                long double SNK;
                long double Factor1;
                long double Factor2;
                long double Factor3;
                long double Betta;
                for (int k = 0; k <= n; k++)
                {
                    Sat.CNK[n][k] = Clm[k][n];
                    Sat.SNK[n][k] = Slm[k][n];
                    int m,m1;
                    Factor3 =1;
                    for (m = n-k, m1= n+k; (m >=1) || (m1 >=1); m--,m1--)
                    {
                        if ((m >= 1) && (m1 >=1))
                        {
                            Factor3 *= (long double)m/(long double)m1;
                        }
                        else if (m >= 1)
                        {
                            Factor3 *= (long double)m;
                        }
                        else // (m1 >=1)
                        {
                            Factor3 /= (long double)m1;
                        }
                    }

                    // CNK = sqrt(2*(2*n+1)) * sqrt(((n-k)!/(n+k)!) * Clm
                    // SNK = sqrt(2*(2*n+1) * sqrt((n-k)!/(n+k)!)) * Slm
                    if (k == 0)
                        Betta = 1.0;
                    else
                        Betta = 2.0;
                     CNK = sqrt(Betta*(2*(long double)n+1) * Factor3) * ClmNN[k][n];
                     
                     SNK = sqrt(2*(Betta*(long double)n+1) * Factor3) * SlmNN[k][n];
#ifdef USE_MODEL_2
                     Sat.CNK[n][k] = CNK;
                     Sat.SNK[n][k] = SNK;
#endif
#ifdef USE_MODEL_3
                     Sat.CNK[n][k] = CNK;
                     Sat.SNK[n][k] = SNK;
#endif
                     if (iCounter_nk_lm_Numbers == 0 && n < 2)
                         continue;
                     nk_lm_Numbers[iCounter_nk_lm_Numbers][0] = n;
                     nk_lm_Numbers[iCounter_nk_lm_Numbers][1] = k;
                     C_S_nk[iCounter_nk_lm_Numbers][0] =Sat.CNK[n][k];
                     C_S_nk[iCounter_nk_lm_Numbers][1] =Sat.SNK[n][k];
                     //if (n==2 && k ==2)
                     //{
                     //    C_S_nk[iCounter_nk_lm_Numbers][0]+=1.3*1.39e-8;
                     //    Sat.CNK[n][k]+=1.3*1.39e-8;
                     //}
                     if (iCounter_nk_lm_Numbers++ >= TOTAL_COEF*TOTAL_COEF/2)
                     {
                         printf("\n something wrong with coef");
                         exit(555);
                     }
                }
                Sat.J[n] = (Clm[0][n]);
            }
#endif

            Sat.iLeg_longit = 0; // no longitude in calculation
            Sat.Lambda = -2;
            Sat.LegBody = EARTH;

            memcpy(Sat.MainCpu.diagonal, Sat.diagonal, sizeof(Sat.MainCpu.diagonal));
            memcpy(Sat.MainCpu._pt_nk, Sat._pt_nk, sizeof(Sat.MainCpu._pt_nk));
            memcpy(Sat.MainCpu._p_n_m_1, Sat._p_n_m_1, sizeof(Sat.MainCpu._p_n_m_1));
            memcpy(Sat.MainCpu._p_n_m_2, Sat._p_n_m_2, sizeof(Sat.MainCpu._p_n_m_2));
            memcpy(Sat.MainCpu._tpk_n_k, Sat._tpk_n_k, sizeof(Sat.MainCpu._tpk_n_k));
            memcpy(Sat.MainCpu._tp_nm1_k, Sat._tp_nm1_k, sizeof(Sat.MainCpu._tp_nm1_k));
            memcpy(Sat.MainCpu._tp_nm2_k, Sat._tp_nm2_k, sizeof(Sat.MainCpu._tp_nm2_k));
            memcpy(Sat.MainCpu.C_S_nk, C_S_nk, sizeof(Sat.MainCpu.C_S_nk));
            memcpy(Sat.MainCpu._p_n_k, Sat._p_n_k, sizeof(Sat.MainCpu._p_n_k));
            Sat.MainCpu._SQRT3 = Sat._SQRT3;
            if (CpuCore)
            {
                Sat.CalcSplit(EarthModelCoefs,CpuCore);
                Sat.StartThreads();
            }
            else
                Sat.i_proc = 0;

        }
        IF_XML_READ(UseSatData)
        {
            strcpy(UseSatData, pszQuo);
            if (strchr(UseSatData, '\"'))
                *strchr(UseSatData, '\"')=0;
        }
        IF_XML_READ(Targetlongitude) // dolgota
        {
            Targetlongitude = atof(pszQuo);
        }

        IF_XML_READ(Targetlatitude) // shirota
        {
            Targetlatitude = atof(pszQuo);
        }

    XML_SECTION_END
    ///////////////////////////////////////////////////////////////////////////////////////////////Engine
    XML_SECTION(Engine)
        // this will switch on engine 0,1,2,3 and etc.
        IF_XML_READ(EngineNumber)
        {
            if (++EnginesCount <= MAX_ENGINES)
            {
            }
            else
            {
                EnginesCount--;
                printf("\n Max engines limit reached - .XML file is incorrect");
            }
            Engine[EnginesCount-1].iLine = 0;
            Engine[EnginesCount-1].TotalImpulse = 0.0;
            Engine[EnginesCount-1].EngineOn = 0;
            Engine[EnginesCount-1].EngineDone = 0;
            Engine[EnginesCount-1].iCalculate = 1;
            Engine[EnginesCount-1].XVec = 0;
            Engine[EnginesCount-1].YVec = 0;
            Engine[EnginesCount-1].ZVec = 0;
            Engine[EnginesCount-1].OptimizationFirstDirectionSwitch = 0;
            //Engine[EnginesCount-1].iNextStepNow = 0;
            //Engine[EnginesCount-1].iNextSteps = 0;
            //for (int ii=0; ii< sizeof(Engine[EnginesCount-1].NextEngineToOptimize)/sizeof(int); ii++)
            //{
            //    Engine[EnginesCount-1].NextEngineToOptimize[ii] = -1;
            //    Engine[EnginesCount-1].NextEngineToOptimizationType[ii] = -1;
            //    Engine[EnginesCount-1].NextEngineToOptimizationNearBody[ii] = -1;
            //    Engine[EnginesCount-1].WhatWillBeLastEngine[ii] = -1;
            //    Engine[EnginesCount-1].NextEngineToOptimizeCalculate[ii] = -1;
            //}
            //Engine[EnginesCount-1].iNumberOfTryValues = 0;
            Engine[EnginesCount-1].SeartchForPeriod = 0.0;
            //Engine[EnginesCount-1].Period = 0.0;
            Engine[EnginesCount-1].iCountApogPerig = 0;
            printf("\n getting Engine %d parameters", EnginesCount-1);
        }
        // just for convinience for orbit trajectory calculation
        IF_XML_READ(PropCoeff)
        {
            EngCoeff = atof(pszQuo);
        }
        IF_XML_READ(Calculate)
        {
            Engine[EnginesCount-1].iCalculate = atoi(pszQuo);
        }
        // total weight of propellant
        IF_XML_READ(Weight)
        {
            Engine[EnginesCount-1].Weight = EngCoeff*atof(pszQuo);
            printf("\n Engine %d parameters propelant mass= %f", EnginesCount-1,Engine[EnginesCount-1].Weight);
        }
        IF_XML_READ(TotalWeight)
        {
            Engine[EnginesCount-1].TotalWeight = EngCoeff*atof(pszQuo);
            printf("\n Engine %d parameters total mass= %f", EnginesCount-1,Engine[EnginesCount-1].TotalWeight);
        }
        
        // parameters of an engine telta time from a plot
        IF_XML_READ(DeltaT)
        {
            Engine[EnginesCount-1].IteraPerSec = atoi(pszQuo);
            Engine[EnginesCount-1].DeltaTime = 1.0/((double)(Engine[EnginesCount-1].IteraPerSec));
        }
        // time when engine will fire from begining of a mission
        IF_XML_READ(FireTime)
        {
            Engine[EnginesCount-1].FireTime = atof(pszQuo);
        }
        // starting angle for a firing engine - in plane: centre of a Earth/Moon/ Planet (Y) and vector of velocity (X)
        // angle btw direction to center clockwise
        IF_XML_READ(FireAng1)
        {
            Engine[EnginesCount-1].Ang1 = atof(pszQuo);
        }
        // second starting angle for a firing: in plane prependicular to center of earth/moon/planet
        // angle btw velocity vector (Y) clockwise
        IF_XML_READ(FireAng2)
        {
            Engine[EnginesCount-1].Ang2 = atof(pszQuo);
        }
        // number of satellite in satellite array (based 0)
        IF_XML_READ(EngineOnSatellite)
        {
            Engine[EnginesCount-1].iEngineOnSatellite = atoi(pszQuo);
        }
        // all values from a plot
        IF_XML_READ(ImplVal)
        {
            if (Engine[EnginesCount-1].iLine >= MAX_IMPULSE_LINES)
            {
                printf("\n Error = impulse for the engine %d is out of range.\n Results of trajectory calcualtions will be wrong", EnginesCount-1);
            }
            else
            {
                Engine[EnginesCount-1].TotalImpulse += EngCoeff*atof(pszQuo)*Engine[EnginesCount-1].DeltaTime;
                Engine[EnginesCount-1].ValImpl[Engine[EnginesCount-1].iLine++] = EngCoeff*atof(pszQuo);
            }
        }
		IF_XML_READ(XVector)
        {
			Engine[EnginesCount-1].XVec = atof(pszQuo);
        }
		IF_XML_READ(YVector)
        {
			Engine[EnginesCount-1].YVec = atof(pszQuo);
        }
		IF_XML_READ(ZVector)
        {
			Engine[EnginesCount-1].ZVec = atof(pszQuo);
        }
        IF_XML_READ(NearBody)
        {
            Engine[EnginesCount-1].NearBody = atoi(pszQuo);
        }
        IF_XML_READ(OptimizationInitialStep)
        {
            Engine[EnginesCount-1].OptimizationInitialStep = atof(pszQuo);
            Engine[EnginesCount-1].OptimizationInitialStepCopy = atof(pszQuo);
        }
        IF_XML_READ(OptimizationDecCoef)
        {
            Engine[EnginesCount-1].OptimizationDecCoef = atof(pszQuo);
            Engine[EnginesCount-1].OptimizationDecCoefCopy = atof(pszQuo);
        }
        IF_XML_READ(OptimizationStop)
        {
            Engine[EnginesCount-1].OptimizationStop = atof(pszQuo);
        }
        IF_XML_READ(AngleOnBody)
        {
            Engine[EnginesCount-1].AngleOnBody = atoi(pszQuo);
        }
		IF_XML_READ(AngleType)
        {
            Engine[EnginesCount-1].AngleType = atoi(pszQuo);
        }
        //IF_XML_READ(NextEngineToOptimize)
        //{
        //    Engine[EnginesCount-1].NextEngineToOptimize[Engine[EnginesCount-1].iNextSteps] = atoi(pszQuo);
        //}
        //IF_XML_READ(NextEngineToOptimizationType)
        //{
        //    Engine[EnginesCount-1].NextEngineToOptimizationType[Engine[EnginesCount-1].iNextSteps] = atoi(pszQuo);
        //}
        //IF_XML_READ(NextEngineToOptimizationNearBody)
        //{
        //    Engine[EnginesCount-1].NextEngineToOptimizationNearBody[Engine[EnginesCount-1].iNextSteps] = atoi(pszQuo);
        //}
        //IF_XML_READ(NextEngineToOptimizeCalculate)
        //{
        //    Engine[EnginesCount-1].NextEngineToOptimizeCalculate[Engine[EnginesCount-1].iNextSteps] = atoi(pszQuo);
        //}
        //IF_XML_READ(WhatWillBeLastEngine)
        //{
        //    if (Engine[EnginesCount-1].NextEngineToOptimizationNearBody[Engine[EnginesCount-1].iNextSteps] == -1)
        //        Engine[EnginesCount-1].NextEngineToOptimizationNearBody[Engine[EnginesCount-1].iNextSteps] = Engine[EnginesCount-1].NearBody;
        //
        //    Engine[EnginesCount-1].WhatWillBeLastEngine[Engine[EnginesCount-1].iNextSteps++] = atoi(pszQuo);
        //}
        
        
        //IF_XML_READ(ValTry)
        //{
        //    Engine[EnginesCount-1].dValTryMaxMin[Engine[EnginesCount-1].iNumberOfTryValues] =0.0;
        //    Engine[EnginesCount-1].dValTry[Engine[EnginesCount-1].iNumberOfTryValues++] = atof(pszQuo);
        //}
    
    XML_SECTION_END

            
    ///////////////////////////////////////////////////////////////////////////////////////////////////Optim
    XML_SECTION(Optim)
        IF_XML_READ(EngineToOptimize)
        {
            if (++iOptPtr < MAX_OPTIM)
            {
                //iOptPtr++;
                Opt[iOptPtr-1].EngineToOptimize = atoi(pszQuo);
                Opt[iOptPtr-1].OptimizationInitialStep = 0.0;
                Opt[iOptPtr-1].OptimizationDecCoef = 0.0;
                Opt[iOptPtr-1].OptimizationStop = 0.0;
            }


        }
        IF_XML_READ(TrajectoryOptimizationType)
        {
            if (iOptPtr < MAX_OPTIM)
                Opt[iOptPtr-1].TrajectoryOptimizationType = atoi(pszQuo);
        }
        IF_XML_READ(NearBody)
        {
            if (iOptPtr < MAX_OPTIM)
                Opt[iOptPtr-1].NearBody = atoi(pszQuo);
        }
        IF_XML_READ(Calculate)
        {
            if (iOptPtr < MAX_OPTIM)
                Opt[iOptPtr-1].Calculate = atoi(pszQuo);
        }
        IF_XML_READ(OptimizationInitialStep)
        {
            if (iOptPtr < MAX_OPTIM)
                Opt[iOptPtr-1].OptimizationInitialStep = atof(pszQuo);
        }
        IF_XML_READ(OptimizationDecCoef)
        {
            if (iOptPtr < MAX_OPTIM)
                Opt[iOptPtr-1].OptimizationDecCoef = atof(pszQuo);
        }
        IF_XML_READ(OptimizationStop)
        {
            if (iOptPtr < MAX_OPTIM)
                Opt[iOptPtr-1].OptimizationStop = atof(pszQuo);
        }
        IF_XML_READ(LastEngine)
        {
            if (iOptPtr < MAX_OPTIM)
            {
                Opt[iOptPtr-1].LastEngine = atoi(pszQuo);
                if ((iOptPtr-1) == StartOptim)
                {
                    LastEngine = atoi(pszQuo);
                    TrajectoryOptimizationType = Opt[iOptPtr-1].TrajectoryOptimizationType;
                    EngineToOptimize = Opt[iOptPtr-1].EngineToOptimize;
                    Engine[EngineToOptimize].iCalculate = Opt[iOptPtr-1].Calculate;
                    Engine[EngineToOptimize].NearBody = Opt[iOptPtr-1].NearBody;
                }
            }
        }

        IF_XML_READ(Period)
        {
            if (iOptPtr < MAX_OPTIM)
            {
                Opt[iOptPtr-1].Period = atof(pszQuo);
            }
        }
    XML_SECTION_END
    XML_END;
}
// TRA.XML processing
void ParamDoAll(FILE *fInput)
{
    char szString[1024];
    char *pszQuo;
    char *pszQuo2;
    while(fgets(szString, sizeof(szString) -1, fInput))
    {
        if (strstr(szString, "TRA:section") != NULL)
        {
            if ((pszQuo = strstr(szString, "name=\"")) != NULL)
            {
                strcpy(szSection, pszQuo + sizeof("name=\"") - 1);
                if ((pszQuo2 = strchr(szSection, '\"')) != 0)
                    *pszQuo2 = 0;
            }
        }
        ParamCommon(szString);
        ParamSun(szString);
        ParamEarth(szString);
        ParamMoon(szString);
        ParamProb(szString);
    }
}
void makeExplanationText(char*szText, int iCalc, int iTraj, int iBody)
{
    switch(iCalc)
    {
    case CALC_PERIGEE: strcpy(szText,"\n<!-- calculates perigee to the ");break;
    case CALC_APOGEE: strcpy(szText,"\n <!-- calculates apogee to the ");break;
    case CALC_TARGET_PRACTICE: strcpy(szText,"\n<!-- calculates error in target practice to the moon");iBody=-1;break;
    case CALC_TARGET_POINT: strcpy(szText,"\n<!-- calculates error in traget prective to the point on the moon");iBody=-1;break;
    case CALC_PERIOD: strcpy(szText,"\n<!-- calculates orbit`s period after engine firing");iTraj=-1;iBody=-1;break;
    case CALC_INIT_PERIOD: strcpy(szText,"\n<!-- calculates orbit`s period ");iTraj=-1;iBody=-1;break;
    case CALC_FIRE_FIRST_ENGINE_TIME: strcpy(szText,"\n<!-- calculates first engine firing time");iTraj=-1;iBody=-1;break;
    case CALC_FIRE_SECOND_ENGINE_TIME:strcpy(szText,"\n<!-- calculates second engine firing time");iTraj=-1;iBody=-1;break;
    case CALC_FIRE_THIRD_ENGINE_TIME_TRY_ONE:strcpy(szText,"\n<!-- calculates third engine firing time(first try)");iTraj=-1;iBody=-1;break;
    case CALC_AT_APOGEE_DIFF_TO_3_4_DIST:strcpy(szText,"\n<!-- calculates difference from 3/4 earth-moon distance and apogee");iBody=-1;break;
    }
    switch(iBody)
    {
    case EARTH:strcat(szText,"Earth");break;
    case MOON:strcat(szText,"Moon");break;
    default:break;
    }
    switch(iTraj)
    {
    case MINIMUM_BY_TIME:strcat(szText,", search for minimum by adjusting time -->");break;
    case MAXIMUM_BY_TIME:strcat(szText,", search for maximum by adjusting time -->");break;
    case MINIMUM_BY_ANGLE:strcat(szText,", search for minimum by adjusting angle -->");break;
    case MINIMUM_BY_WEIGHT:strcat(szText,", search for minimum by adjusting engines weight -->");break;
    default:strcat(szText,".-->");break;

    }

}

void PostXMLToServer(char* URLServer, int urlport, char* URLFileName, char* FileToTransfer)
{
    char szWebServerResp[8096];
    FILE *FileTransfer = fopen(FileToTransfer,"rb");
    if (FileTransfer)
    {
        fseek(FileTransfer, 0L, SEEK_END);
        long iSize = ftell( FileTransfer);
        fseek(FileTransfer, 0L, SEEK_SET);
        char * szFileContent = (char*)malloc((size_t)iSize);
        if (szFileContent)
        {
            fread(szFileContent,iSize,1,FileTransfer);
            fclose(FileTransfer);
            CHttpConnection* m_MainHttpServer = NULL;
            CInternetSession  *m_MainInternetConnection = NULL;

            if (m_MainHttpServer == NULL)
            {
                m_MainInternetConnection = new CInternetSession("SessionToControlServer",12,INTERNET_OPEN_TYPE_DIRECT,NULL, // proxi name
                            NULL, // proxi bypass
				            INTERNET_FLAG_DONT_CACHE|INTERNET_FLAG_TRANSFER_BINARY);
		        try
		        {
		            m_MainHttpServer = 	m_MainInternetConnection->GetHttpConnection( URLServer, 0, urlport, NULL, NULL );
                }
	            catch(CInternetException *e)
		        {
		            m_MainHttpServer = NULL;
		        }
            }
            if (m_MainHttpServer)
            {
                CHttpFile* myCHttpFile = NULL;
                try
                {
                    myCHttpFile = m_MainHttpServer->OpenRequest( CHttpConnection::HTTP_VERB_POST,URLFileName, NULL,NULL, NULL, NULL, INTERNET_FLAG_EXISTING_CONNECT|	INTERNET_FLAG_DONT_CACHE|INTERNET_FLAG_RELOAD );
			    }
			    catch(CInternetException *e)
			    {
				    myCHttpFile = NULL;
			    }

			    if (myCHttpFile !=NULL)
			    {
				    try
				    {
                        CString strHeader = "Accept: text/*\r\n";
                        strHeader += "User-Agent: HttpCall\r\n";
                        strHeader += "Accept-Language: en-us\r\n";

                        //    strHeader += "Content-type: application/x-www-form-urlencoded\r\n";
                        //    strHeader += "REMOTE_USER: "+strUser+"\r\n";
                        //    strHeader += "Accept-Language: en-us\r\n";

                        myCHttpFile->AddRequestHeaders((LPCSTR)strHeader);
                        myCHttpFile->SendRequestEx(iSize,HSR_INITIATE,1);
                        myCHttpFile->WriteString((LPCTSTR)szFileContent);
                        myCHttpFile->EndRequest();

					    memset(szWebServerResp, 0, sizeof(szWebServerResp));
						DWORD dwSize;
						CString strSize;
						myCHttpFile->QueryInfo(HTTP_QUERY_CONTENT_LENGTH,strSize);
						dwSize = atoi(strSize.GetString());
    				    if (dwSize > (sizeof(szWebServerResp)-1))
					    {
						    for (DWORD dwread=0; dwread < dwSize; dwread+= (sizeof(szWebServerResp)-1))
						    {
							    if ((dwSize - dwread) > (sizeof(szWebServerResp)-1))
                                {
	                                if (myCHttpFile->Read(&szWebServerResp,(sizeof(szWebServerResp)-1)))
                                    {
                                    }
                                }
								else
                                {
								    if (myCHttpFile->Read(&szWebServerResp,(dwSize - dwread)))
                                    {
                                    }
                                }
                            }
                        }
						else
                        {
                            if (myCHttpFile->Read(&szWebServerResp,dwSize))
                            {
                            }
                        }
                    }
    				catch(CInternetException *e)
	    			{
		    			//ptrApp->m_MainHttpServer = NULL;
			    	}
    				myCHttpFile->Close();
	    			delete myCHttpFile;
		    	}
                m_MainHttpServer->Close();
                m_MainInternetConnection->Close();
		    }
            free(szFileContent);
        }
    }
}

FILE *VisualFile = NULL;

void dumpTRAvisual(long i)
{
    if (VisualFileSet == FALSE)
        return;
    if (VisualFile == NULL)
    {
		VisualFile = fopen(szTraVisualFileName, "w");
        if (VisualFile)
        {
		    fprintf(VisualFile,"<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n");
		    fprintf(VisualFile,"<Universe>\n");
        }
    }
	if (VisualFile)
    {

        for (int iSat = 0; iSat < Sat.Elem; iSat++)
        {
            fprintf(VisualFile,"	<Sat%d>\n",iSat);
            //fprintf(VisualFile,"		<ID>SatTra</ID>\n");
		    //fprintf(VisualFile,"		<time>%.18g</time>\n", dStartJD + ((double)i)/(24.0*60.0*60.0));
			fprintf(VisualFile,"		<X>%.18g</X>\n",Sat.X[iSat]-SolarSystem.X[EARTH]);
			fprintf(VisualFile,"		<Y>%.18g</Y>\n",Sat.Y[iSat]-SolarSystem.Y[EARTH]);
			fprintf(VisualFile,"		<Z>%.18g</Z>\n",Sat.Z[iSat]-SolarSystem.Z[EARTH]);
            if (iSat == 0) // only for a first satellite - check visibility from ground stations
            {
                // check is it from now time till end of the simulation
                if ((iTotalSec - i) <= dMinFromNow* 60)
                {
                    SYSTEMTIME ThatTime; 
                    TIME_ZONE_INFORMATION tmzone;
                    ConvertJulianDayToDateAndTime(dStartJD + ((double)(i))/(24.0*60.0*60.0), &ThatTime);
                    int Iret = GetTimeZoneInformation(&tmzone); 
                    double dTLEEpoch = ConvertDateTimeToTLEEpoch(ThatTime.wDay, ThatTime.wMonth, ThatTime.wYear, ThatTime.wHour, ThatTime.wMinute, ThatTime.wSecond, ThatTime.wMilliseconds);
                    double dGreenwichA = GreenwichAscensionFromTLEEpoch(dTLEEpoch,Sat.precEps,Sat.precTet,Sat.precZ,Sat.nutEpsilon,Sat.nutDFeta);
                    SUN_08 (ThatTime.wYear,
                                iDayOfTheYearZeroBase(ThatTime.wDay, ThatTime.wMonth, ThatTime.wYear)+1 ,// in that function specified that 1 day is january 1
                                ThatTime.wHour,ThatTime.wMinute,ThatTime.wSecond,
                                GST,SLONG,SRASN,SDEC);
                    // only for red line do the check
                    for (int jGr = 0; jGr < iGr; jGr++)
                    {
                        double PosX;double PosY;double PosZ;
                        GetXYZfromLatLong(GrLong[jGr]+GST*180.0/M_PI-90.0, GrLat[jGr],PosX,PosY,PosZ, EarthR);
                        // check: does Cubesat in proximity of a ground station : angle btw vactor-radius and vector cubesat-ground station > 90 degree
                        if (AngleBtw(-PosX,-PosY,-PosZ,
                            (Sat.X[iSat]-SolarSystem.X[EARTH])-PosX,(Sat.Y[iSat]-SolarSystem.Y[EARTH])-PosY,(Sat.Z[iSat]-SolarSystem.Z[EARTH])-PosZ) > 90.0)
                        {
                            fprintf(VisualFile,"		        <X%d>%.18g</X%d>\n",jGr,PosX,jGr);
                            fprintf(VisualFile,"		        <Y%d>%.18g</Y%d>\n",jGr,PosY,jGr);
                            fprintf(VisualFile,"		        <Z%d>%.18g</Z%d>\n",jGr,PosZ,jGr);
                        }
                    }
                }
            }
            fprintf(VisualFile,"	</Sat%d>\n",iSat);
        }
	    if (OutLast == TRUE)
	    {
            SYSTEMTIME ThatTime; 
            ConvertJulianDayToDateAndTime(dStartJD + ((double)i)/(24.0*60.0*60.0), &ThatTime);
            double dEpoch = ConvertDateTimeToTLEEpoch(ThatTime.wDay, ThatTime.wMonth, ThatTime.wYear, ThatTime.wHour, ThatTime.wMinute, ThatTime.wSecond, ThatTime.wMilliseconds);
            double long dGreenwichA = GreenwichAscensionFromTLEEpoch(dEpoch,Sat.precEps,Sat.precTet,Sat.precZ,Sat.nutEpsilon,Sat.nutDFeta);
            SUN_08 (ThatTime.wYear,
                iDayOfTheYearZeroBase(ThatTime.wDay, ThatTime.wMonth, ThatTime.wYear) + 1 , // in fucntion spec that 1 Jan == 1 
                ThatTime.wHour,ThatTime.wMinute,ThatTime.wSecond,
                GST,SLONG,SRASN,SDEC);
            // GST is a position Greenwich in rad 

            //for moon rotation - moon looks at earth each time
            // that is a angle btw vector (0,-1,0) and moon position vector in geocentrical coordinates
            double MoonRot = AngleBtw(0,-1,0,SolarSystem.X[MOON] - SolarSystem.X[EARTH],SolarSystem.Y[MOON] - SolarSystem.Y[EARTH],SolarSystem.Z[MOON] - SolarSystem.Z[EARTH]);

            fprintf(VisualFile,"	<Object>\n");
            fprintf(VisualFile,"		<type>Earth</type>\n");
			fprintf(VisualFile,"		<X>%.18g</X>\n",SolarSystem.X[EARTH]);
			fprintf(VisualFile,"		<Y>%.18g</Y>\n",SolarSystem.Y[EARTH]);
			fprintf(VisualFile,"		<Z>%.18g</Z>\n",SolarSystem.Z[EARTH]);
			fprintf(VisualFile,"		<R>%.18g</R>\n",EarthR);
            fprintf(VisualFile,"		<Rot>%.18g</Rot>\n",GST*180.0/M_PI - 90.0); // convert to degree
			fprintf(VisualFile,"	</Object>\n");
			fprintf(VisualFile,"	<Object>\n");
			fprintf(VisualFile,"		<type>Sun</type>\n");
			fprintf(VisualFile,"		<X>%.18g</X>\n",SolarSystem.X[SUN]);
			fprintf(VisualFile,"		<Y>%.18g</Y>\n",SolarSystem.Y[SUN]);
			fprintf(VisualFile,"		<Z>%.18g</Z>\n",SolarSystem.Z[SUN]);
			fprintf(VisualFile,"		<R>%.18g</R>\n",SunR);
            fprintf(VisualFile,"		<Rot>%.18g</Rot>\n",0);
			fprintf(VisualFile,"	</Object>\n");
			fprintf(VisualFile,"	<Object>\n");
			fprintf(VisualFile,"		<type>Moon</type>\n");
			fprintf(VisualFile,"		<X>%.18g</X>\n",SolarSystem.X[MOON]);
			fprintf(VisualFile,"		<Y>%.18g</Y>\n",SolarSystem.Y[MOON]);
			fprintf(VisualFile,"		<Z>%.18g</Z>\n",SolarSystem.Z[MOON]);
			fprintf(VisualFile,"		<R>%.18g</R>\n",MoonR);
            fprintf(VisualFile,"		<Rot>%.18g</Rot>\n",MoonRot);
			fprintf(VisualFile,"	</Object>\n");
            fprintf(VisualFile,"	<ObjectTime>\n");
		    fprintf(VisualFile,"		<timeJD>%.18g</timeJD>\n", dStartJD + ((double)i)/(24.0*60.0*60.0));
            
            fprintf(VisualFile,"		<timeYYDDMMHHMMSS>%02d/%02d/%02d %02d:%02d:%02d</timeYYDDMMHHMMSS>\n", ThatTime.wYear-2000,ThatTime.wMonth,ThatTime.wDay,ThatTime.wHour,ThatTime.wMinute,ThatTime.wSecond);
            fprintf(VisualFile,"		<ReloadInSec>00001</ReloadInSec>\n"); // for the best case it is 1 sec refresh == that value has to be  
            fprintf(VisualFile,"		<dMinFromNow>%d</dMinFromNow>\n",(int)dMinFromNow); // how many minutes from now to aproximate
            fprintf(VisualFile,"	</ObjectTime>\n");
            for (int i= 0; i <iGr; i++)
            {
                fprintf(VisualFile,"	<GrSt>\n");
                // now need to calculate coordinates based on latitude and longitude
                double PosX;double PosY;double PosZ;
                GetXYZfromLatLong(GrLong[i], GrLat[i],PosX,PosY,PosZ, EarthR);
                //fprintf(VisualFile,"		<type>GrStn</type>\n");
                fprintf(VisualFile,"		<X>%.18g</X>\n",PosX);
                fprintf(VisualFile,"		<Y>%.18g</Y>\n",PosY);
                fprintf(VisualFile,"		<Z>%.18g</Z>\n",PosZ);
                fprintf(VisualFile,"	</GrSt>\n");
            }
            fprintf(VisualFile,"</Universe>\n");
			fclose(VisualFile);
            VisualFile = NULL;
            if (szTraVisualFileName[0] == '@') // yes! it is agly - that is a case when visualization output must to be submit to some server
            {
                PostXMLToServer(szURLTraVisualServer, UrlTraVisualPort, szURLTraVisualFileName, szTraVisualFileName);
            }
		}
	}
}
// output the same copy of the TRA.XML file
void dumpXMLParam(TRAOBJ *Sat, TRAIMPLOBJ *MyEngine, int iNumbOfEng)
{
    char szText[1024];
    FILE *EnginesFile = fopen("tra_out.xml", "w");
    int i,j;
    if (EnginesFile)
    {
#define XML_DUMPF(XML_PARAM) fprintf(EnginesFile,"\n    <TRA:setting name=\"%s\" value=\"%.18g\" />",#XML_PARAM,XML_PARAM);
#define XML_DUMPI(XML_PARAM) fprintf(EnginesFile,"\n    <TRA:setting name=\"%s\" value=\"%d\" />",#XML_PARAM,XML_PARAM);
        fprintf(EnginesFile,"<?xml version=\"1.0\" encoding=\"UTF-8\" ?>");
        fprintf(EnginesFile,"\n<TRA:data version=\"1.00\" xmlns:CT=\"http://www.adobri.com/tra\">");
        fprintf(EnginesFile,"\n<TRA:section name=\"TraInfo\">\n");
        fprintf(EnginesFile,"\n<!-- starting date (1 jan 2000) = 2451544.5JD ");
        fprintf(EnginesFile,"\n     if this is not set then use keplers elements from a satelite 0 -->");
        XML_DUMPF(dStartJD);
#ifdef _DO_VISUALIZATION
        fprintf(EnginesFile,"\n\n    <TRA:setting name=\"RGBImageW\" value=\"%d\" />",bRGBImageW);
        fprintf(EnginesFile,"\n    <TRA:setting name=\"RGBImageH\" value=\"%d\" />",bRGBImageH);
#endif
        fprintf(EnginesFile,"\n<!-- int iProfile = 0; ");
        fprintf(EnginesFile,"\n              // 0 == XY , 1 == YZ, 2 == XZ 3 == -YZ 4 == -XZ 5==-XY");
        fprintf(EnginesFile,"\n              // 0 or XY is a view from North to south, 5 (- XY) is a view from south to north");
        fprintf(EnginesFile,"\n              // 1 or YZ is a view to easter -->");
#ifdef _DO_VISUALIZATION
        fprintf(EnginesFile,"\n    <TRA:setting name=\"RGBView\" value=\"%d\" />", iProfile);
#endif

        fprintf(EnginesFile,"\n<!--  EARTH 2 MOON  9 -->\n");
#ifdef _DO_VISUALIZATION
        XML_DUMPI(RGBReferenceBody);
#endif
        fprintf(EnginesFile,"\n<!-- max amount of pictures -->");
#ifdef _DO_VISUALIZATION
        fprintf(EnginesFile,"\n    <TRA:setting name=\"RGBMaxPictures\" value=\"%d\" />",iMaxSeq);
        fprintf(EnginesFile,"\n<!-- one picture per sec -->");
        fprintf(EnginesFile,"\n    <TRA:setting name=\"RGBSecPerPictures\" value=\"%d\" />", iMaxCounter);
        fprintf(EnginesFile,"\n<!-- scale in m -->");
        fprintf(EnginesFile,"\n    <TRA:setting name=\"RGBScale\" value=\"%.18g\" />\n",dRGBScale);
#endif
        XML_DUMPF(IterPerSec);
        XML_DUMPF(StartLandingIteraPerSec);

        fprintf(EnginesFile,"\n<!-- next vaue actualy just a reference it will be used in-->");
        fprintf(EnginesFile,"\n<!-- GMMoon = MoonM * GBig and GMEarth = EarthM*GBig      -->");
        fprintf(EnginesFile,"\n<!-- know GMMoon and GMEarth will give proper value for M -->");
        XML_DUMPF(Gbig);
        XML_DUMPF(TotalDays);
        XML_DUMPF(EarthCurTime);
        XML_DUMPF(AU); 
        for (i = 0; i < Sat->Elem; i++)
        {
            //XML_DUMPF(ProbM);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"ProbM\" value=\"%.18g\" />",Sat->M[i]);

            fprintf(EnginesFile,"\n    <TRA:setting name=\"ProbKeplerLine1\" value=\"%s",Sat->Kepler1);
            fprintf(EnginesFile,"    <TRA:setting name=\"ProbKeplerLine2\" value=\"%s",Sat->Kepler2);
            fprintf(EnginesFile,"    <TRA:setting name=\"ProbKeplerLine3\" value=\"%s",Sat->Kepler3);
        }
        fprintf(EnginesFile,"\n<!-- target point on the Moon -->");
        XML_DUMPF(Targetlongitude);
        XML_DUMPF(Targetlatitude);
        //XML_DUMPF(SunM);
        XML_DUMPF(EarthR);
        //XML_DUMPF(EarthRP);
        //XML_DUMPF(EarthRE);
        //XML_DUMPF(EarthM);
        //XML_DUMPF(MassRatioSunToEarthPlusMoon);
        XML_DUMPF(EarthTSolSec);
        XML_DUMPF(EarthSmAx);
        //XML_DUMPF(EarthSmAxAU);
        //XML_DUMPF(EarthTDays);

        XML_DUMPF(MoonR);
        //XML_DUMPF(MoonRP);
        //XML_DUMPF(MoonRE);
        //XML_DUMPF(MoonM);
        fprintf(EnginesFile,"\n\n<!--next line will force recalculation of SunM based on G constant -->");
        //XML_DUMPF(GMSun);
        //XML_DUMPF(GMEarthMoon);
        //XML_DUMPF(GMEarth);
        //XML_DUMPF(GMMoon);
        fprintf(EnginesFile,"\n\n<!-- next line will force calculation of a Earth and Moon mass -->");
        fprintf(EnginesFile,"\n<!-- it is not in use - value just for reference and fo trigger -->");
        //XML_DUMPF(MassRatioEarthToMoon);
        fprintf(EnginesFile,"\n    <TRA:setting name=\"MoonKeplerLine1\" value=\"%s",szMoonKeplerLine1);
        fprintf(EnginesFile,"    <TRA:setting name=\"MoonKeplerLine2\" value=\"%s",szMoonKeplerLine2);
        fprintf(EnginesFile,"    <TRA:setting name=\"MoonKeplerLine3\" value=\"%s",szMoonKeplerLine3);
        fprintf(EnginesFile,"\n\n<!-- next line (value == \"1.0\") will force calculation"); 
        fprintf(EnginesFile,"\n                         of a Earth kepler position -->");
        fprintf(EnginesFile,"\n    <TRA:setting name=\"EarthCalcKepler\" value=\"0.0\" />");
        fprintf(EnginesFile,"\n\n<!-- next line will force assigning velocities and positions ");
        fprintf(EnginesFile,"\n     based on JPL data -->\n");
        fprintf(EnginesFile,"\n    <TRA:setting name=\"UseJPLxyz\" value=\"1.0\" />");
        XML_DUMPI(StartOptim);
        XML_DUMPI(MaxOptim);

        //fprintf(EnginesFile,"\n    <TRA:setting name=\"UseJPLxyz\" value=\"1.0\" />");
        fprintf(EnginesFile,"\n\n<!-- last used engine (0,1,2,3..) in trajectory optimization or calculations ");
        fprintf(EnginesFile,"\n     setting lastengine == -1 disable optimization -->\n");
        XML_DUMPI(LastEngine);
        fprintf(EnginesFile,"\n\n<!-- do optimization of an engine N... (0,1,2,3...)");
        fprintf(EnginesFile,"\n     it is posible to use 4 engines but optimize engine 3-->\n");
        XML_DUMPI(EngineToOptimize);


        fprintf(EnginesFile,"\n\n<!-- Type of optimization");
        fprintf(EnginesFile,"\n      1 - search for a minimum by adjusting time of firing");
        fprintf(EnginesFile,"\n      2 - search for a maximum by adjusting time of firing");       
        fprintf(EnginesFile,"\n      4 - search fo maximum by adjusting angle of firing");
        fprintf(EnginesFile,"\n      6 - search fo minimum by adjusting weight of fuel");

        fprintf(EnginesFile,"\n  initial step and decrease steps for each search specified");
        fprintf(EnginesFile,"\n  individualy for each engine -->\n");

        XML_DUMPI(TrajectoryOptimizationType);

        fprintf(EnginesFile,"\n</TRA:section>\n\n            <!--     now all engines    -->");

        for (i = 0; i < iNumbOfEng; i++)
        {
            fprintf(EnginesFile,"\n<TRA:section name=\"Engine\" value=\"%d\" />", i);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"EngineNumber\" value=\"%d\" />", i);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"EngineOnSatellite\" value=\"%d\" />",MyEngine[i].iEngineOnSatellite);
            fprintf(EnginesFile,"\n    <!-- convinent coeff - instead of entry real values just assume scaled version-->");
            fprintf(EnginesFile,"\n    <TRA:setting name=\"PropCoeff\" value=\"1.0\" />");
            fprintf(EnginesFile,"\n\n    <TRA:setting name=\"Weight\" value=\"%.18g\" />",MyEngine[i].Weight);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"TotalWeight\" value=\"%.18g\" />",MyEngine[i].TotalWeight);
            fprintf(EnginesFile,"\n\n    <!-- iteration per sec from engine's plot -->");
            fprintf(EnginesFile,"\n    <TRA:setting name=\"DeltaT\" value=\"%.18g\" />",1.0/MyEngine[i].DeltaTime);

            fprintf(EnginesFile,"\n\n     <!-- 2- EARTH 9-MOON for calculation distanses-->");
            fprintf(EnginesFile,"\n           <TRA:setting name=\"NearBody\" value=\"%d\" />",MyEngine[i].NearBody);

            fprintf(EnginesFile,"\n\n     <!-- AngleType 0 - tangent line to orbit (elipse) oposit velocity");
            fprintf(EnginesFile,"\n                    1 - two angles set with reference to NearBody centre direction");
            fprintf(EnginesFile,"\n                    2 - 3 angles set vector fire (constant all fire) ");
            fprintf(EnginesFile,"\n                    3 - oposit vector of velocity");
            fprintf(EnginesFile,"\n                    4 - same direction as vector of velocity -->");
            fprintf(EnginesFile,"\n     <TRA:setting name=\"AngleType\" value=\"%d\" />",MyEngine[i].AngleType);
            fprintf(EnginesFile,"\n\n     <!-- 2- EARTH 9-MOON for firing angle -->");
            fprintf(EnginesFile,"\n     <TRA:setting name=\"AngleOnBody\" value=\"%d\" />",MyEngine[i].AngleOnBody);
            fprintf(EnginesFile,"\n\n    <!-- first angle: in a plane over vector from the center of NearBody and Sat"); 
            fprintf(EnginesFile,"\n         and vector of velocity. Angle: Centre,Sat,Direction ");
            fprintf(EnginesFile,"\n         (aggle == 90 degr is a Tangent line to elipse) -->");
            fprintf(EnginesFile,"\n         <TRA:setting name=\"FireAng1\" value=\"%.18g\" />",MyEngine[i].Ang1);
            fprintf(EnginesFile,"\n\n     <!-- second angle from projection of a velocity vector to a  ");
            fprintf(EnginesFile,"\n         plane perpendicular to direction to centre of nearbody -->");
            fprintf(EnginesFile,"\n    <TRA:setting name=\"FireAng2\" value=\"%.18g\" />",MyEngine[i].Ang2);
            fprintf(EnginesFile,"\n\n    <TRA:setting name=\"XVector\" value=\"%.18g\" />",MyEngine[i].XVec);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"YVector\" value=\"%.18g\" />",MyEngine[i].YVec);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"ZVector\" value=\"%.18g\" />\n",MyEngine[i].ZVec);
            fprintf(EnginesFile,"\n\n     <TRA:setting name=\"OptimizationInitialStep\" value=\"%.18g\" />",MyEngine[i].OptimizationInitialStepCopy);
            fprintf(EnginesFile,"\n     <TRA:setting name=\"OptimizationDecCoef\" value=\"%.18g\" />" ,MyEngine[i].OptimizationDecCoefCopy);
            fprintf(EnginesFile,"\n     <TRA:setting name=\"OptimizationStop\" value=\"%.18g\" />\n",MyEngine[i].OptimizationStop);
            //fprintf(EnginesFile,"\n        <TRA:setting name=\"Period\" value=\"%f\" />",MyEngine[i].Period);
            
            //if (MyEngine[i].iNumberOfTryValues)
            //{
            //    for (j = 0; j < MyEngine[i].iNumberOfTryValues; j++)
            //    {
            //        fprintf(EnginesFile,"\n        <TRA:setting name=\"TryVal\" value=\"%.24g\" /> <!-- %f -->",MyEngine[i].dValTry[j],MyEngine[i].dValTryMaxMin);
            //    }
            //}

            fprintf(EnginesFile,"\n\n    <!-- set impulses in a time -->");
            fprintf(EnginesFile,"\n        <TRA:setting name=\"FireTime\" value=\"%.18g\" />",MyEngine[i].FireTime);

            for (j = 0; j < MyEngine[i].iLine; j++)
            {
                fprintf(EnginesFile,"\n        <TRA:setting name=\"ImplVal\" value=\"%.24g\" /> <!-- %f -->",MyEngine[i].ValImpl[j], j*MyEngine[i].DeltaTime );
            }
            fprintf(EnginesFile,"\n</TRA:section>");
            fprintf(EnginesFile,"\n\n");
        }
        for (j=0; j < iOptPtr; j++)
        {
            fprintf(EnginesFile,"\n<TRA:section name=\"Optim\" value=\"%d\" />", j);
            makeExplanationText(szText, Opt[j].Calculate,
                    Opt[j].TrajectoryOptimizationType, 
                    Opt[j].NearBody);
            fprintf(EnginesFile,szText);
            fprintf(EnginesFile,"\n         <TRA:setting name=\"EngineToOptimize\" value=\"%d\" />",Opt[j].EngineToOptimize);
            if (j == 0)
            {
                fprintf(EnginesFile,"\n\n<!-- Type of optimization");
                fprintf(EnginesFile,"\n      1 - search for a minimum by adjusting time of firing");
                fprintf(EnginesFile,"\n      2 - search for a maximum by adjusting time of firing");       
                fprintf(EnginesFile,"\n      4 - search fo maximum by adjusting angle of firing");
                fprintf(EnginesFile,"\n      6 - search fo minimum by adjusting weight of fuel");

                fprintf(EnginesFile,"\n  initial step and decrease steps for each search specified");
                fprintf(EnginesFile,"\n  individualy for each engine -->\n");
            }

            fprintf(EnginesFile,"\n           <TRA:setting name=\"TrajectoryOptimizationType\" value=\"%d\" />",Opt[j].TrajectoryOptimizationType);
            if (j == 0)
                fprintf(EnginesFile,"\n\n     <!-- 2- EARTH 9-MOON for calculation distanses-->");
            fprintf(EnginesFile,"\n           <TRA:setting name=\"NearBody\" value=\"%d\" />",Opt[j].NearBody);
            if (j == 0)
            {
                fprintf(EnginesFile,"\n\n     <!-- calculates ");
                fprintf(EnginesFile,"\n          (0) Perigee to a center of NearBody");
                fprintf(EnginesFile,"\n          (1) Apogee to a center of NearBody");
                fprintf(EnginesFile,"\n          (3) taget practice not far than distance earth-moon");
                fprintf(EnginesFile,"\n          (5) target practice to apoint on a moon's surface");
                fprintf(EnginesFile,"\n          (6) orbit period around near body");
                fprintf(EnginesFile,"\n          (8) orbit period before engine firing");
                fprintf(EnginesFile,"\n          (9) first engine firing time");
                fprintf(EnginesFile,"\n          (10) second engine firing time");
                fprintf(EnginesFile,"\n          (11) third engine firing time (first try)");
                fprintf(EnginesFile,"\n          (12) at apogee difference from 3/4 of a earth-moon distance");
                fprintf(EnginesFile,"\n               --> ");
            }
            fprintf(EnginesFile,"\n           <TRA:setting name=\"Calculate\" value=\"%d\" />",Opt[j].Calculate);
            fprintf(EnginesFile,"\n           <TRA:setting name=\"OptimizationInitialStep\" value=\"%.18g\" />",Opt[j].OptimizationInitialStep);
            fprintf(EnginesFile,"\n           <TRA:setting name=\"OptimizationDecCoef\" value=\"%.18g\" />",Opt[j].OptimizationDecCoef);
            fprintf(EnginesFile,"\n           <TRA:setting name=\"OptimizationStop\" value=\"%.18g\" />",Opt[j].OptimizationStop);
            fprintf(EnginesFile,"\n           <TRA:setting name=\"LastEngine\" value=\"%d\" />\n",Opt[j].LastEngine);
            fprintf(EnginesFile,"\n        <TRA:setting name=\"Period\" value=\"%f\" />",Opt[j].Period);
            fprintf(EnginesFile,"\n</TRA:section>");
            fprintf(EnginesFile,"\n\n");
        }

        fprintf(EnginesFile,"\n</TRA:section>\n\n");

        fprintf(EnginesFile,"\n</TRA:data>");
        fclose(EnginesFile);
    }
}

// this will be a check doe it need to optimize next engine base on a results of a prev one
int CheckWhatnext(TRAOPTIMOBJ* Opt, TRAOBJ *Sat, TRAIMPLOBJ *Eng, TRAIMPLOBJ *EngStore, 
                  int &CurentEngine, int &CurentEngineOptimizationType,int &WhatWillBeLastEngine, 
                  int iNumbOfEngines, double dCurTime)
{
    int iret = 0;
    int i;
    int iOld;
    int iNewCalculate;
    int iNewNearBody;
    char szText[1024];
    
    //if (Eng[CurentEngine].NextEngineToOptimize[Eng[CurentEngine].iNextStepNow] != -1)
    if (++iOptimizationStep <= MaxOptim)
    {
        //iOptimizationStep++;
        //CurentEngineOptimizationType = Eng[CurentEngine].NextEngineToOptimizationType[Eng[CurentEngine].iNextStepNow];
        CurentEngineOptimizationType = Opt[iOptimizationStep].TrajectoryOptimizationType;
        //WhatWillBeLastEngine = Eng[CurentEngine].WhatWillBeLastEngine[Eng[CurentEngine].iNextStepNow];
        WhatWillBeLastEngine = Opt[iOptimizationStep].LastEngine;
        //iNewCalculate = Eng[CurentEngine].NextEngineToOptimizeCalculate[Eng[CurentEngine].iNextStepNow];
        iNewCalculate = Opt[iOptimizationStep].Calculate;
        //iNewNearBody = Eng[CurentEngine].NextEngineToOptimizationNearBody[Eng[CurentEngine].iNextStepNow];
        iNewNearBody = Opt[iOptimizationStep].NearBody;
        iOld = CurentEngine;
        //CurentEngine = Eng[CurentEngine].NextEngineToOptimize[Eng[CurentEngine].iNextStepNow];
        CurentEngine = Opt[iOptimizationStep].EngineToOptimize;
        Eng[CurentEngine].iCalculate = iNewCalculate;
        Eng[CurentEngine].NearBody = iNewNearBody;
        if (Opt[iOptimizationStep].OptimizationInitialStep != 0.0)
        {
            Eng[CurentEngine].OptimizationInitialStep = Opt[iOptimizationStep].OptimizationInitialStep;
            Eng[CurentEngine].OptimizationStop = Opt[iOptimizationStep].OptimizationStop;
            Eng[CurentEngine].OptimizationDecCoef = Opt[iOptimizationStep].OptimizationDecCoef;
        }
        // for the same engine adjust next step counter
        //if (iOld == CurentEngine)
        //{
        //    Eng[CurentEngine].iNextStepNow++;
        //}
        makeExplanationText(szText, iNewCalculate, CurentEngineOptimizationType,iNewNearBody);
        printf("\n next: %s", szText);

        // chek is it posible to do next step now?
        if (iNewCalculate == CALC_FIRE_FIRST_ENGINE_TIME || iNewCalculate == CALC_FIRE_SECOND_ENGINE_TIME ||
            iNewCalculate == CALC_FIRE_THIRD_ENGINE_TIME_TRY_ONE)
        {
            //Eng[CurentEngine].FireTime = dCurTime + Eng[CurentEngine].Period;
            Eng[CurentEngine].FireTime = dCurTime + Opt[iOptimizationStep-1].Period;
            printf("\n firing time set=%f ",Eng[CurentEngine].FireTime);
            iret = CheckWhatnext(Opt, Sat, Eng, EngStore, CurentEngine, CurentEngineOptimizationType, WhatWillBeLastEngine, iNumbOfEngines, dCurTime);

        }
        else
            iret = 1;
        // may be need to update value in storage for optimization?
        if (EngStore)
        {
            
            for (i = 0; i < MAX_ENGINES; i++)
            {
                EngStore[i].iCalculate = Eng[i].iCalculate;
                EngStore[i].FireTime = Eng[i].FireTime;
                //EngStore[i].iNextStepNow = Eng[i].iNextStepNow;
                EngStore[i].NearBody = Eng[i].NearBody;
                //EngStore[i].Period = Eng[i].Period;
                EngStore[i].OptimizationInitialStep = Eng[i].OptimizationInitialStep;
                EngStore[i].OptimizationStop = Eng[i].OptimizationStop;
                EngStore[i].OptimizationDecCoef = Eng[i].OptimizationDecCoef;

            }
        }
    }
    else
    {
        // that mean it will be exit - just dump curent satelite and engines status
        dumpXMLParam(Sat, Eng, iNumbOfEngines);
    }
    return iret;
}

#define TEST_RUN_CALC_YEAR 1
#define TEST_RUN_ERROR 1
#define TEST_RUN_EARTH_ERROR 1
void FindImpulses(void)
{
#ifdef FIND_IMPULSE_TIME
        for (int itry = 0 ; itry < 10000; itry++)
        {
        MyTry = SolarSystem;
        MyTrySat = Sat;
		MyEngine[0]= Engine[0];MyEngine[1]= Engine[1];MyEngine[2]= Engine[2];MyEngine[3]= Engine[3];MyEngine[4]= Engine[4];MyEngine[5]= Engine[5];
        SCH_Per = 10000000000000.0;
        SCH_Apg = 0.0;
        iSCH_Apg = 0;
        iSCH_Per = 0;
        SCH_ApgPerTime = 0;


        iApog = 0;
        Apog = 0.0;
        iPerig = 0;
        Perig = 0.0;
        ApogPergTime = 0;
        PerigMoon = 100000000000.0;
        iStartLandingIteraPerSec = 0;
        idRMDelta = 0;
#endif

#ifdef FIND_IMPULSE_TIME
                    // apogee and prerigee search each time
                    if (Apog < (dRE - EarthR))
                    {
                        Apog = (dRE - EarthR);
                        iApog = 1;
                    }
                    else
                    {
                        if (iApog)
                        {
                            if (i + j*SlS->TimeSl - ApogPergTime >100)
                            {
                                printf("\n Apog = %f km DT = %f at=%d sec", Apog/1000.0, i + j*SlS->TimeSl - ApogPergTime, i);
                                if ((EngineToOptimize == 0) || 
                                    (EngineToOptimize > 0 && EngineToOptimize < MAX_ENGINES && (Engine[EngineToOptimize].EngineDone==0) && (Engine[EngineToOptimize-1].EngineDone!=0))
                                   )
                                //if (EngineToOptimize >=0 && EngineToOptimize < MAX_ENGINES)
                                {
                                    if (Engine[EngineToOptimize].iCountApogPerig ==0) // frist apogee skip
                                        Engine[EngineToOptimize].iCountApogPerig = 1;
                                    else
                                    {
                                        // on second apogee store value
                                        Engine[EngineToOptimize].SeartchForPeriod = i + j*SlS->TimeSl - ApogPergTime;
                                        Engine[EngineToOptimize].iCountApogPerig = 2;
                                    }
                                }
                                iApog = 0;
                                Perig = (dRE - EarthR);
                                ApogPergTime = i + j*SlS->TimeSl;
                                printf(", Disatnce from a Moon %f km",dRM/1000.0);
                            }
                        }
                    }
                    if (Perig > (dRE - EarthR))
                    {
                        Perig = (dRE - EarthR);
                        iPerig = 1;

                    }
                    else
                    {
                        if (iPerig)
                        {
                            if (i + j*SlS->TimeSl - ApogPergTime >100)
                            {
                                printf("\n Perig = %f km DT = %f", Perig/1000.0, i + j*SlS->TimeSl - ApogPergTime);
                                if ((EngineToOptimize == 0) || 
                                    (EngineToOptimize > 0 && EngineToOptimize < MAX_ENGINES && (Engine[EngineToOptimize].EngineDone==0) && (Engine[EngineToOptimize-1].EngineDone!=0))
                                   )
                                //if (EngineToOptimize >=0 && EngineToOptimize < MAX_ENGINES)
                                {

                                    if (Engine[EngineToOptimize].iCountApogPerig == 2) // this will be second perigee
                                    {
                                        Engine[EngineToOptimize].SeartchForPeriod += i + j*SlS->TimeSl - ApogPergTime;
                                        //Engine[EngineToOptimize].Period = Engine[EngineToOptimize].SeartchForPeriod;
                                        Opt[iOptimizationStep].Period = Engine[EngineToOptimize].SeartchForPeriod;
                                        Engine[EngineToOptimize].iCountApogPerig = 3;
                                        if (Engine[EngineToOptimize].iCalculate == CALC_INIT_PERIOD)
                                        {
                                            if (CheckWhatnext(&Opt[0],&Sat, &Engine[0], &MyEngine[0], EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*SlS->TimeSl) == 0)
                                            {
                                                exit(0);
                                            }
                                        }
                                    }
                                }
                                iPerig = 0;
                                Apog = (dRE - EarthR);
                                ApogPergTime = i + j*SlS->TimeSl;
                            }
                        }
                    }
                    if ((LastEngine >= 0) && (LastEngine <= MAX_ENGINES) && (Engine[LastEngine].EngineDone))
                    {
                        SCH_Dist = sqrt(
                            (ProbX - SolarSystem.X[Engine[LastEngine].NearBody])*(ProbX - SolarSystem.X[Engine[LastEngine].NearBody])+
                            (ProbY - SolarSystem.Y[Engine[LastEngine].NearBody])*(ProbY - SolarSystem.Y[Engine[LastEngine].NearBody])+
                            (ProbZ - SolarSystem.Z[Engine[LastEngine].NearBody])*(ProbZ - SolarSystem.Z[Engine[LastEngine].NearBody])
                            );
                        dREMV = sqrt((SolarSystem.VX[Engine[LastEngine].NearBody]-Sat.VX[0])*(SolarSystem.VX[Engine[LastEngine].NearBody]-Sat.VX[0])+
                                     (SolarSystem.VY[Engine[LastEngine].NearBody]-Sat.VY[0])*(SolarSystem.VY[Engine[LastEngine].NearBody]-Sat.VY[0])+
                                     (SolarSystem.VZ[Engine[LastEngine].NearBody]-Sat.VZ[0])*(SolarSystem.VZ[Engine[LastEngine].NearBody]-Sat.VZ[0]));
                        if (Engine[LastEngine].iCalculate == CALC_APOGEE) // value 1
                        {
                            if (SCH_Apg < SCH_Dist)
                            {
                                SCH_Apg = SCH_Dist;
                                iSCH_Apg = 1;
                            }
                            else
                            {
                                if (iSCH_Apg)
                                {
                                    printf("\n SCHApogee = %f km (%f) DT = %f at=%d sec", SCH_Apg/1000.0,
                                        (SCH_Apg - GetRadius(&SolarSystem, Engine[LastEngine].NearBody, &Sat, 0))/1000.0,
                                        i + j*SlS->TimeSl - SCH_ApgPerTime, i);
                                    iSCH_Apg = 0;
                                    SCH_Per = SCH_Apg;
                                    SCH_ApgPerTime = (int)(i + j*SlS->TimeSl);
                                    printf("====engine==i=%d====<fire at=%f=>===",i,Engine[EngineToOptimize].FireTime);
                                    // SCH_Per is a parameter for that "call"
                                    goto NextTry;
                                }
                            }
                        }
                        else if (Engine[LastEngine].iCalculate == CALC_PERIGEE) // value 0
                        {
                            if (SCH_Per > SCH_Dist)
                            {
                                SCH_Per = SCH_Dist;
                                iSCH_Per = 1;
                            }
                            else
                            {
                                if (iSCH_Per)
                                {
                                    if (SCH_Per < 300000000.0)
                                    {
                                        printf("\n SCHPerigee = %f km (%f)DT = %f at=%d sec", SCH_Per/1000.0, 
                                        (SCH_Per-GetRadius(&SolarSystem, Engine[LastEngine].NearBody, &Sat, 0))/1000.0, 
                                        i + j*SlS->TimeSl - SCH_ApgPerTime, i);
                                        iSCH_Apg = 0;
                                        SCH_Apg = SCH_Per;
                                        SCH_ApgPerTime = (int)(i + j*SlS->TimeSl);
                                        printf("====engine==i=%d====<fire at=%f=>===",i,Engine[EngineToOptimize].FireTime);
                                        // SCH_Per is a parameter for that "call"
                                        goto NextTry;
                                    }
                                }
                            }
                        }
                        else if (Engine[LastEngine].iCalculate == CALC_TARGET_PRACTICE) // value 3
                        {
                            double dREM = sqrt((MoonX - EarthX)*(MoonX - EarthX)+
                                                (MoonY - EarthY)*(MoonY - EarthY)+
                                                (MoonZ - EarthZ)*(MoonZ - EarthZ));
                            // for target practice next check is fly out of moon-earth distance anyway this is a missing target
                            if (dREM < dRE)
						    {
							    printf("\n Target practice get to Moon = %f km ", PerigMoon/1000.0);
                                printf("===i=%d===========<==%f=>==v=%f=",i,Engine[EngineToOptimize].FireTime-dRMDelta,dREMV);
                                SCH_Per = SCH_Dist;
                                // SCH_Per is a parameter for that "call"
                                goto NextTry;
						    }
                            if (SCH_Per > SCH_Dist )
                            {
                                SCH_Per = SCH_Dist;
                            }
                            else
                            {
                                if (SCH_Per < 300000000.0)
                                {
                                    printf("\n Traget practice Perigee Moon = %f km ", SCH_Per/1000.0);
                                    printf("===i==%d===========<==%f=>==v=%f=",i,Engine[EngineToOptimize].FireTime-dRMDelta,dREMV);
                                    // SCH_Per is a parameter for that "call"
                                    goto NextTry;
                                }
                            }
                        }
                        else if (Engine[LastEngine].iCalculate == CALC_TARGET_POINT)  // value 5
                        {
							
							double dREM = sqrt((MoonX - EarthX)*(MoonX - EarthX)+
                                                (MoonY - EarthY)*(MoonY - EarthY)+
                                                (MoonZ - EarthZ)*(MoonZ - EarthZ))+20.0*MoonR;
                            // for target practice next check is fly out of moon-earth distance anyway this is a missing target
                            if (dREM < dRE)
						    {
							    printf("\n Target practice get to Moon = %f km ", PerigMoon/1000.0);
                                printf("===i=%d===========<==%f=>==v=%f=",i,Engine[EngineToOptimize].FireTime-dRMDelta,dREMV);
                                SCH_Per = SCH_Dist;
                                // SCH_Per is a parameter for that "call"
                                goto NextTry;
						    }
							if (SCH_Dist < MoonR*2)
							{
								double PosXMoon = 0;
								double PosYMoon = 0;
								double PosZMoon = 0;

                                // first Longitude second latitute
                                 // dolgota,  shirota

		                        getXYZMoon(Targetlongitude,Targetlatitude,PosXMoon,PosYMoon,PosZMoon,&SolarSystem,MOON,EARTH,MoonR);
								if (SCH_Dist < MoonR)
								{
									SCH_Dist = sqrt(
				                    (ProbX - PosXMoon)*(ProbX - PosXMoon)+
						            (ProbY - PosYMoon)*(ProbY - PosYMoon)+
								    (ProbZ - PosZMoon)*(ProbZ - PosZMoon)
									);
									SCH_Per = SCH_Dist;
									printf("\n Traget practice Point on a Moon = %f km ", SCH_Per/1000.0);
									printf("===i==%d===========<==%f=>==v=%f=",i,Engine[EngineToOptimize].FireTime-dRMDelta,dREMV);
										// SCH_Per is a parameter for that "call"
										goto NextTry;
								}
		                        SCH_Dist = sqrt(
				                    (ProbX - PosXMoon)*(ProbX - PosXMoon)+
						            (ProbY - PosYMoon)*(ProbY - PosYMoon)+
								    (ProbZ - PosZMoon)*(ProbZ - PosZMoon)
									);
							}
                            if (SCH_Per > SCH_Dist )
                            {
                                SCH_Per = SCH_Dist;
								iSCH_Per = 1;
                            }
                            else
                            {
								if (iSCH_Per)
								{
									if (SCH_Per < 300000000.0)
									{
										printf("\n Traget practice Point on a Moon = %f km ", SCH_Per/1000.0);
										printf("===i==%d===========<==%f=>==v=%f=",i,Engine[EngineToOptimize].FireTime-dRMDelta,dREMV);
										// SCH_Per is a parameter for that "call"
										goto NextTry;
									}
                                }
                            }
                        }
                        else if (Engine[LastEngine].iCalculate == CALC_PERIOD) // value 6
                        {
                            if (Engine[LastEngine].iCountApogPerig == 3)
                            {
                                if (CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*SlS->TimeSl) == 0)
                                {
                                    exit(0);
                                }
                            }
                        }
                        else if (Engine[LastEngine].iCalculate == CALC_AT_APOGEE_DIFF_TO_3_4_DIST) // 12
                        {
                            if (SCH_Dist > 400000000*1.25)
                                SCH_Dist = 400000000*1.25;
                            if (SCH_Apg < SCH_Dist)
                            {
                                SCH_Apg = SCH_Dist;
                                iSCH_Apg = 1;
                            }
                            else
                            {
                                if (iSCH_Apg)
                                {
                                    printf("\n SCHApogee = %f km (%f) DT = %f at=%d sec", SCH_Apg/1000.0,
                                        (SCH_Apg - GetRadius(&SolarSystem, Engine[LastEngine].NearBody, &Sat, 0))/1000.0,
                                        i + j*SlS->TimeSl - SCH_ApgPerTime, i);
                                    iSCH_Apg = 0;
                                    SCH_Per = SCH_Apg;
                                    SCH_ApgPerTime = (int)(i + j*SlS->TimeSl);
                                    SCH_Per = abs(SCH_Per - 400000000*0.75);
                                    printf("====engine==i=%d====<weight at=%f=>===",i,Engine[EngineToOptimize].Weight);
                                    // SCH_Per is a parameter for that "call"
                                    goto NextTry;
                                }
                            }
                        }
                    }
#endif
#ifdef FIND_IMPULSE_TIME
NextTry:
            SolarSystem = MyTry;
            Sat = MyTrySat;
            Engine[0] = MyEngine[0];Engine[1] = MyEngine[1];Engine[2] = MyEngine[2];Engine[3] = MyEngine[3];Engine[4] = MyEngine[4];Engine[5] = MyEngine[5]; 
            if ((LastEngine >=0) && (LastEngine < MAX_ENGINES))
            {

                switch(TrajectoryOptimizationType)
                {
                case MAXIMUM_BY_TIME: // value 2
                    // first assign intial values
                    if (idRM == 0)
                    {
                        dRM2 = dRM1;
                        dRM1 = SCH_Per; // this is a parameter for optimization (has to be maximized)
                        Engine[EngineToOptimize].FireTime += Engine[EngineToOptimize].OptimizationInitialStep;
                        idRM = 1;
                        idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                    }
                    else if (idRM == 1)
                    {
                        dRM2 = dRM1;
                        dRM1 = SCH_Per;
                        if (dRM2 < dRM1)
                        {
                            printf("\n Maximum at %d %f ", itry,dRM2);
                            Engine[EngineToOptimize].FireTime += Engine[EngineToOptimize].OptimizationInitialStep;
                            idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                        }
                        else
                        {
                            if (Engine[EngineToOptimize].OptimizationFirstDirectionSwitch++)
                            {
                                Engine[EngineToOptimize].OptimizationInitialStep = Engine[EngineToOptimize].OptimizationInitialStep/Engine[EngineToOptimize].OptimizationDecCoef;
                                if (abs(Engine[EngineToOptimize].OptimizationInitialStep) < Engine[EngineToOptimize].OptimizationStop)
                                {
                                    printf("\n optimization reached max delta value");
                                    if (CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*TimeSl) == 0)
                                    {
                                        exit(0);
                                    }
                                    idRM = 0;
                                    break;
                                }
                            }
                            Engine[EngineToOptimize].OptimizationInitialStep = -Engine[EngineToOptimize].OptimizationInitialStep;
                            idRM = 0;
                        }

                    }
                    break;
                case MINIMUM_BY_TIME: // value 1
                    if (idRM == 0)
                    {
                        dRM2 = dRM1;
                        dRM1 = SCH_Per; // this is a parameter for optimization (has to be minimized)
                        Engine[EngineToOptimize].FireTime += Engine[EngineToOptimize].OptimizationInitialStep;
                        idRM = 1;
                        idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                    }
                    
                    else
                    {
                        dRM2 = dRM1;
                        dRM1 = SCH_Per;
                        if (dRM2 > dRM1)
                        {
                            Engine[EngineToOptimize].FireTime += Engine[EngineToOptimize].OptimizationInitialStep;
                            idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                        }
                        else
                        {
                            if (Engine[EngineToOptimize].OptimizationFirstDirectionSwitch++)
                            {
                                Engine[EngineToOptimize].OptimizationInitialStep = Engine[EngineToOptimize].OptimizationInitialStep/Engine[EngineToOptimize].OptimizationDecCoef;
                                if (abs(Engine[EngineToOptimize].OptimizationInitialStep) < Engine[EngineToOptimize].OptimizationStop)
                                {
                                    printf("\n optimization reached min delta value");
                                    if (CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*TimeSl) == 0)
                                    {
                                        exit(0);
                                    }
                                    idRM = 0;
                                    break;
                                }
                            }
                            Engine[EngineToOptimize].OptimizationInitialStep = -Engine[EngineToOptimize].OptimizationInitialStep;
							idRM = 0;
                            printf("\n Minimum at %d %f ", itry,dRM2);
                        }
                    }
                    break;
                case MINIMUM_BY_WEIGHT: //  value 6
                    // first assign intial values
                    if (idRM == 0)
                    {
                        int iIm = 0;
                        dRM2 = dRM1;
                        dRM1 = SCH_Per; // this is a parameter for optimization (has to be minimized)
                        for (iIm = 0; iIm <Engine[EngineToOptimize].iLine; iIm++)
                        {
                            Engine[EngineToOptimize].ValImpl[iIm] += Engine[EngineToOptimize].OptimizationInitialStep*
                                Engine[EngineToOptimize].ValImpl[iIm];
                        }
                        Engine[EngineToOptimize].Weight += Engine[EngineToOptimize].OptimizationInitialStep*
                            Engine[EngineToOptimize].Weight;
                        Engine[EngineToOptimize].TotalWeight += Engine[EngineToOptimize].OptimizationInitialStep*
                            Engine[EngineToOptimize].TotalWeight;
                        Engine[EngineToOptimize].TotalImpulse += Engine[EngineToOptimize].OptimizationInitialStep*
                            Engine[EngineToOptimize].TotalImpulse;
                        
                        idRM = 1;
                        idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                    }
                    else if (idRM == 1)
                    {
                        dRM2 = dRM1;
                        dRM1 = SCH_Per;
                        if (dRM2 > dRM1)
                        {
                            int iIm = 0;
                            printf("\n Minimum at %d %f ", itry,dRM2);
                            for (iIm = 0; iIm <Engine[EngineToOptimize].iLine; iIm++)
                            {
                                Engine[EngineToOptimize].ValImpl[iIm] += Engine[EngineToOptimize].OptimizationInitialStep*
                                    Engine[EngineToOptimize].ValImpl[iIm];
                            }
                            Engine[EngineToOptimize].Weight += Engine[EngineToOptimize].OptimizationInitialStep*
                                Engine[EngineToOptimize].Weight;
                            Engine[EngineToOptimize].TotalWeight += Engine[EngineToOptimize].OptimizationInitialStep*
                                Engine[EngineToOptimize].TotalWeight;

                            Engine[EngineToOptimize].TotalImpulse += Engine[EngineToOptimize].OptimizationInitialStep*
                            Engine[EngineToOptimize].TotalImpulse;
                        
                            idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                        }
                        else
                        {
                            if (Engine[EngineToOptimize].OptimizationFirstDirectionSwitch++)
                            {
                                Engine[EngineToOptimize].OptimizationInitialStep = Engine[EngineToOptimize].OptimizationInitialStep/Engine[EngineToOptimize].OptimizationDecCoef;
                                if (abs(Engine[EngineToOptimize].OptimizationInitialStep) < Engine[EngineToOptimize].OptimizationStop)
                                {
                                    printf("\n optimization reached max delta value");
                                    if (CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*TimeSl) == 0)
                                    {
                                        exit(0);
                                    }
                                    idRM = 0;
                                    break;
                                }
                            }
                            Engine[EngineToOptimize].OptimizationInitialStep = -Engine[EngineToOptimize].OptimizationInitialStep;
                            idRM = 0;
                        }

                    }
                    break;
                case MINIMUM_BY_ANGLE: //  value 4
					// find closest point to but by adjusting angle
                    if (iFirstAngleDone == 0)
                    {
                        LastStepTryAnglesDirValuesX = Engine[EngineToOptimize].XVec;
                        LastStepTryAnglesDirValuesY = Engine[EngineToOptimize].YVec;
                        LastStepTryAnglesDirValuesZ = Engine[EngineToOptimize].ZVec;
						LastStepHistX[0] = LastStepTryAnglesDirValuesX;
                        LastStepHistY[0] = LastStepTryAnglesDirValuesY;
                        LastStepHistZ[0] = LastStepTryAnglesDirValuesZ;
						//TryAnglesDirValues[0] = dRM;
                        iFirstAngleDone = 1;
                        TryAnglesDirDelta = Engine[EngineToOptimize].OptimizationInitialStep;
                    }
                    else
                    {
                        
                        TryAnglesDirValues[iTryAnglesDir] = SCH_Per; // this is a parameter for optimization (has to be minimized)
                        // attempt to check: may be next step is not nesesary- vector is (0,0,0)!? which is bad!
                        while(iTryAnglesDir + 1 <= iMaxTryAnglesDir)
                        {
                            if ((abs(LastStepTryAnglesDirValuesX + TryAnglesDir[iTryAnglesDir+1][0]*TryAnglesDirDelta) <= 0.0000001) &&
                                (abs(LastStepTryAnglesDirValuesY + TryAnglesDir[iTryAnglesDir+1][1]*TryAnglesDirDelta) <= 0.0000001) &&
                                (abs(LastStepTryAnglesDirValuesZ + TryAnglesDir[iTryAnglesDir+1][2]*TryAnglesDirDelta) <= 0.0000001))
                            {
                                // make it garante big
                                TryAnglesDirValues[iTryAnglesDir+1] = SCH_Per*1000;
                                iTryAnglesDir++;
                                continue;
                            }
                            break;
                        }
                        if (++iTryAnglesDir > iMaxTryAnglesDir)
                        {
                            // find minimum
							iFindMin = 0;
                            FindMin = TryAnglesDirValues[iFindMin];
                            
                            newTryAnglesDirDelta=TryAnglesDirDelta;
                            for(int iSe = iFindMin+1; iSe <= iMaxTryAnglesDir; iSe++)
                            {
                                if (FindMin > TryAnglesDirValues[iSe])
                                {
                                    FindMin = TryAnglesDirValues[iSe];
                                    iFindMin = iSe;
                                }
                            }
							// check to adjust TryAnglesDirDelta to be smaller
							if (iFindMin == 0)
							{
                                newTryAnglesDirDelta = TryAnglesDirDelta/Engine[EngineToOptimize].OptimizationDecCoef;
                                printf("\n<TRA:setting name=\"FireAng1\" value=\"0.0\" />");
                                printf("\n<TRA:setting name=\"FireAng2\" value=\"0.0\" />");
                                printf("\n    <TRA:setting name=\"XVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesX+ TryAnglesDir[iFindMin][0]*TryAnglesDirDelta));
                                printf("\n    <TRA:setting name=\"YVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesY+ TryAnglesDir[iFindMin][1]*TryAnglesDirDelta));
                                printf("\n    <TRA:setting name=\"ZVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesZ+ TryAnglesDir[iFindMin][2]*TryAnglesDirDelta));

                                if (newTryAnglesDirDelta < Engine[EngineToOptimize].OptimizationStop)
                                {
                                    printf("\n optimization minimum by angle done");
                                    if (CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*TimeSl) == 0)
                                    {
                                        exit(0);
                                    }
                                    idRM = 0;
                                    break;
                                }
							}
							else
							{
                                int iTemp = 1;
								// check to adjust TryAnglesDirDelta to be smaller
								for (int iHistS = 0; iHistS < 10; iHistS++)
								{
									if ((LastStepHistX[iHistS] == (LastStepTryAnglesDirValuesX+ TryAnglesDir[iFindMin][0]*TryAnglesDirDelta)) &&
										(LastStepHistY[iHistS] == (LastStepTryAnglesDirValuesY+ TryAnglesDir[iFindMin][1]*TryAnglesDirDelta)) &&
										(LastStepHistZ[iHistS] == (LastStepTryAnglesDirValuesZ+ TryAnglesDir[iFindMin][2]*TryAnglesDirDelta)))
									{
                                        newTryAnglesDirDelta = TryAnglesDirDelta/Engine[EngineToOptimize].OptimizationDecCoef;
										printf("\n<TRA:setting name=\"FireAng1\" value=\"0.0\" />");
										printf("\n<TRA:setting name=\"FireAng2\" value=\"0.0\" />");
										printf("\n    <TRA:setting name=\"XVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesX+ TryAnglesDir[iFindMin][0]*TryAnglesDirDelta));
										printf("\n    <TRA:setting name=\"YVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesY+ TryAnglesDir[iFindMin][1]*TryAnglesDirDelta));
										printf("\n    <TRA:setting name=\"ZVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesZ+ TryAnglesDir[iFindMin][2]*TryAnglesDirDelta));

										if (newTryAnglesDirDelta < Engine[EngineToOptimize].OptimizationStop)
										{
                                            printf("\n optimization minimum by angle done");
                                            if (iTemp = CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*TimeSl) == 0)
                                            {
                                                exit(0);
                                            }
                                            idRM = 0;
	                                    }
		                                break;
			                        }
				                }
                                if (iTemp)
                                    break;
							}
                            // adjust next step try
                            Engine[EngineToOptimize].XVec = LastStepTryAnglesDirValuesX + TryAnglesDir[iFindMin][0]*TryAnglesDirDelta;
                            Engine[EngineToOptimize].YVec = LastStepTryAnglesDirValuesY + TryAnglesDir[iFindMin][1]*TryAnglesDirDelta;
                            Engine[EngineToOptimize].ZVec = LastStepTryAnglesDirValuesZ + TryAnglesDir[iFindMin][2]*TryAnglesDirDelta;
							TryAnglesDirValues[0] = TryAnglesDirValues[iFindMin];

                            for (int iHist = 10 - 1; iHist > 0; iHist --)
                            {
                                LastStepHistX[iHist] = LastStepHistX[iHist-1];
                                LastStepHistY[iHist] = LastStepHistY[iHist-1];
                                LastStepHistZ[iHist] = LastStepHistZ[iHist-1];
                            }
                            LastStepHistX[0] = LastStepTryAnglesDirValuesX;
                            LastStepHistY[0] = LastStepTryAnglesDirValuesY;
                            LastStepHistZ[0] = LastStepTryAnglesDirValuesZ;

                            iTryAnglesDir = 1;
                                
                            LastStepTryAnglesDirValuesX = Engine[EngineToOptimize].XVec;
                            LastStepTryAnglesDirValuesY = Engine[EngineToOptimize].YVec;
                            LastStepTryAnglesDirValuesZ = Engine[EngineToOptimize].ZVec;

                            TryAnglesDirDelta = newTryAnglesDirDelta;

                            if ((abs(LastStepTryAnglesDirValuesX + TryAnglesDir[iTryAnglesDir][0]*TryAnglesDirDelta) <= 0.0000001) &&
                                (abs(LastStepTryAnglesDirValuesY + TryAnglesDir[iTryAnglesDir][1]*TryAnglesDirDelta) <= 0.0000001) &&
                                (abs(LastStepTryAnglesDirValuesZ + TryAnglesDir[iTryAnglesDir][2]*TryAnglesDirDelta) <= 0.0000001))
                            {
                                // make it garante big
                                TryAnglesDirValues[iTryAnglesDir] = SCH_Per*1000;
                                iTryAnglesDir++;
                                //continue;
                            }
                        }
                        Engine[EngineToOptimize].XVec = LastStepTryAnglesDirValuesX + TryAnglesDir[iTryAnglesDir][0]*TryAnglesDirDelta;
                        Engine[EngineToOptimize].YVec = LastStepTryAnglesDirValuesY + TryAnglesDir[iTryAnglesDir][1]*TryAnglesDirDelta;
                        Engine[EngineToOptimize].ZVec = LastStepTryAnglesDirValuesZ + TryAnglesDir[iTryAnglesDir][2]*TryAnglesDirDelta;
                    
                    }
                    break;
                }
            }

        } // end of attempts to calculate optimum time of impulse to achive min distance from Moon
#endif

}
void JustRun(TRAOBJ *SlS, TRAOBJ *Sat,TRAIMPLOBJ *Eng, long double ldFrom,long double ldFromTLEEpoch, long long iAllSec, int iItPerS, int irestRun, long double tSl)
{
    SlS->TimeSl = tSl;
    SlS->TimeSl_2 = tSl*tSl;

    long long iSec;
    int iPortionSec;
    for (iSec = 0; iSec < iAllSec; iSec++)
    {
        for (iPortionSec = 0; iPortionSec < iItPerS; iPortionSec++)
        {
            IteraSat(1, SlS, Sat,ldFromTLEEpoch + (iSec +   (long double)iPortionSec/(long double)iItPerS) /86400.0) ;
            IteraSolarSystem(TRUE, SlS);
        }
    }
    for (iPortionSec = 0; iPortionSec < irestRun; iPortionSec++)
    {
        IteraSat(1, SlS, Sat,ldFromTLEEpoch + (iSec +   (long double)iPortionSec/(long double)iItPerS) /86400.0) ;
        IteraSolarSystem(TRUE, SlS);
    }
}
unsigned char bRandBuffer[2048];
int iRa=sizeof(bRandBuffer)/sizeof(unsigned long);
void Ra(unsigned char *bBuffer, int iBufferSize)
{
    HCRYPTPROV hCryptProv = 0;
    if (!CryptAcquireContextW(&hCryptProv,0, 0, PROV_RSA_FULL, 0))
    {
        hCryptProv = NULL;
        if (CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, CRYPT_NEWKEYSET))
        {
        }
    }
    if (hCryptProv)
        CryptGenRandom(hCryptProv, iBufferSize, bRandBuffer);
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);
}
unsigned long ra(void)
{
    if (iRa >= (sizeof(bRandBuffer)/sizeof(unsigned long)))
    {
        Ra(bRandBuffer, sizeof(bRandBuffer));
        iRa =0;
    }
    return ((unsigned long*)&bRandBuffer[0])[iRa++];
}
void GetRandomNVector(long double &Xn, long double &Yn, long double&Zn)
{
    Xn = -(long double)ra();
    Yn = -(long double)ra();
    Zn = -(long double)ra();
    Xn += (long double)ra();
    Yn += (long double)ra();
    Zn += (long double)ra();
    long double Rn = sqrt(Xn*Xn + Yn*Yn + Zn*Zn);
    Xn = Xn/Rn; Yn = Yn/Rn; Zn = Zn/Rn;
}
void SetCalcSat(TRAOBJ *Sat, TRAOBJ *SlS, int iSat, long double X, long double Y, long double Z, long double VX, long double VY, long double VZ)
{
    Sat->X[iSat] += X; Sat->Y[iSat] += Y; Sat->Z[iSat] += Z;
    Sat->VX[iSat] += VX; Sat->VY[iSat] += VY; Sat->VZ[iSat] += VZ;
    Sat->X0divDt2[iSat]=Sat->X[iSat] /SlS->TimeSl_2;
    Sat->Y0divDt2[iSat]=Sat->Y[iSat] /SlS->TimeSl_2;
    Sat->Z0divDt2[iSat]=Sat->Z[iSat] /SlS->TimeSl_2;
    Sat->VX0divDt[iSat]=Sat->VX[iSat] /SlS->TimeSl;
    Sat->VY0divDt[iSat]=Sat->VY[iSat] /SlS->TimeSl;
    Sat->VZ0divDt[iSat]=Sat->VZ[iSat] /SlS->TimeSl;
    Sat->iAtm[iSat] = 1;
    Sat->CountNx = 0; Sat->CountNy = 0; Sat->CountNz = 0;
    Sat->RunOne = TRUE;
}
void RunCalc(TRAOBJ *SlS, TRAOBJ *Sat,TRAIMPLOBJ *Eng, long double ldFrom,long double ldFromTLEEpoch, long long iAllSec, int iItPerS, long double tSl)
{
    SlS->TimeSl = tSl;
    SlS->TimeSl_2 = tSl*tSl;

    // adjust 
    for (int i =0; i< iMAxMesaures; i++)
    {
        if (measures[i].NearBody >0) //gCRSmeasure -> hCRSmeasure
        {
            stateType  StateEarth;
            stateType  StateMoon;
            double dEMRAT = Find_DataInHeader("EMRAT ");
            double dAU = Find_DataInHeader("AU    ")*1000.0;

            Interpolate_State( measures[i].T, EARTH , &StateEarth );
            Interpolate_State( measures[i].T, MOON , &StateMoon );
            double BSX = StateEarth.Position[0]*1000.0 ;
            double BSY = StateEarth.Position[1]*1000.0 ;
            double BSZ = StateEarth.Position[2]*1000.0 ;
            SlS->X[EARTH] = BSX - (StateMoon.Position[0]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
            SlS->Y[EARTH] = BSY - (StateMoon.Position[1]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
            SlS->Z[EARTH] = BSZ - (StateMoon.Position[2]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
            measures[i].X += SlS->X[EARTH];
            measures[i].Y += SlS->Y[EARTH];
            measures[i].Z += SlS->Z[EARTH];
            if (i==0) // for the first measure on first sat set initial velocity
            {
                //Sat->VX[0] = StateEarth.Velocity[0] * 1000.0; Sat->VY[0] = StateEarth.Velocity[1] * 1000.0; Sat->VZ[0] = StateEarth.Velocity[3] * 1000.0;
            }
        }
    }
    // set ininials velositi is equal EARTH velocity
    long double PError = measures[0].Err;
    long double VelError = 0.010704334375;//10.0;//0.07;
    //for (int m = 0; m < iMAxMesaures; m++)
    printf("\n (init) PError =%.12f VelErr=%.12f",PError,VelError);
    int m0 = 0;
    int nextm = 1;
    long double dlIX, dlIY, dlIZ, dlIVX, dlIVY, dlIVZ;
    dlIX = Sat->X[0]; dlIY = Sat->Y[0]; dlIZ = Sat->Z[0];
    dlIVX = Sat->VX[0]; dlIVY = Sat->VY[0]; dlIVZ = Sat->VZ[0];
    //Sat->X[0] += -958.445037841797;   Sat->Y[0] += 629.093017578125;   Sat->Z[0] += -273.815940856934;
    //Sat->VX[0] += 0.001135664937; Sat->VY[0] += 0.000285064067; Sat->VZ[0] += -0.000475006107;
    for (m0= 1;m0 <iMAxMesaures; m0++)
    {
        long double Xn[9], Yn[9], Zn[9], Rn[9];
        int iCmin = 0;
DO_MATHC_AGAIN:
        for (int m = nextm; m <=m0; m++)
        {
            for (int n=0; n <13; n++)
            {
                TRAOBJ SolS1=*SlS;
                TRAOBJ Sat11= *Sat; // 1 error by position 1 error by velocity

                long double ldRunFrom =ldFrom;
                SYSTEMTIME ThatTime;
                long double ldRunFromTLEEpoch = ConvertJulianDayToDateAndTime(ldRunFrom, &ThatTime);
                long long iRunSec = (measures[m].T - measures[0].T)*(24*60*60);

                int irestRun = (((measures[m].T - measures[0].T) - (long double)(iRunSec/(24.0*60.0*60.0))))*24.0*60.0*60.0* iItPerS*10;
                irestRun +=1;
                irestRun/=10;

                long double XYZ_err = PError;
                long double VXYZerr = VelError;
                long double VXn[9], VYn[9], VZn[9];
                long double Xe[9], Ye[9], Ze[9];
                LONG_DOUBLE_INT_VAR _position_[9];
                LONG_DOUBLE_INT_VAR _velosity_[9];
                int iC = 0;
                iCmin = 0;
                long double rmin;
                long double RnSumm = 0;
                stateType  StateEarth;
                Interpolate_State( ldRunFrom, EARTH , &StateEarth );
                for (iC=0; iC < 9; iC++)
                {
                    XYZ_err = PError * (long double)(0xffffff & ra())/((long double)(0xffffff));
                    VXYZerr = VelError * (long double)(0xffffff & ra())/((long double)(0xffffff));

                    if (iC)
                    {
                        GetRandomNVector(Xn[iC], Yn[iC], Zn[iC]);
                        Xn[iC]*= XYZ_err; Yn[iC]*= XYZ_err; Zn[iC]*= XYZ_err;

                        GetRandomNVector(VXn[iC], VYn[iC], VZn[iC]);
                        VXn[iC]*= VXYZerr; VYn[iC]*= VXYZerr; VZn[iC]*= VXYZerr;
                    }
                    else
                    {
                        Xn[iC] =0; Yn[iC] =0; Zn[iC] =0; VXn[iC] =0; VYn[iC] =0; VZn[iC] =0;
                    }
                    SolS1=*SlS; Sat11= *Sat;
                    SetCalcSat(&Sat11, &SolS1, 0, Xn[iC], Yn[iC], Zn[iC], VXn[iC], VYn[iC], VZn[iC]);
                    JustRun(&SolS1, &Sat11,Eng, ldRunFrom,ldRunFromTLEEpoch, iRunSec, iItPerS, irestRun, tSl);
                    Xe[iC] = Sat11.X[0]; Ye[iC] = Sat11.Y[0]; Ze[iC] = Sat11.Z[0];
                    _position_[iC] = Sat11._position_[0];_velosity_[iC] = Sat11._velosity_[0];
                    long double vrmin = sqrt((Xe[iC]-measures[m].X)*(Xe[iC]-measures[m].X)+(Ye[iC]-measures[m].Y)*(Ye[iC]-measures[m].Y)+(Ze[iC]-measures[m].Z)*(Ze[iC]-measures[m].Z));
                    Rn[iC] = vrmin;
                    RnSumm += vrmin;
                
                    if (iC==0)
                    {
                        rmin = vrmin;
                        nextm = m0+1; // if error will match on iC =0 (X=0,0,0, V=0,0,0) than on next measurement all prev measurements can be skipped
                    }
                    else
                    {
                        if (vrmin < rmin)
                        {
                            iCmin = iC; rmin = vrmin;printf("\n min: %.5f",rmin);
                            nextm=1; // value changed needs to start from measurement 1
                        }
                    }
                
                    printf("\n% dE=,%.5f,%.5f,%.5f,%.5f", n, Xe[iC]-measures[m].X, Ye[iC]-measures[m].Y,Ze[iC]-measures[m].Z,sqrt((Xe[iC]-measures[m].X)*(Xe[iC]-measures[m].X)+(Ye[iC]-measures[m].Y)*(Ye[iC]-measures[m].Y)+(Ze[iC]-measures[m].Z)*(Ze[iC]-measures[m].Z))
                        );
                    printf("\n  X=%.12f,%.12f,%.12f,V=%.12f,%.12f,%.12f", Xn[iC],Yn[iC],Zn[iC], VXn[iC],VYn[iC],VZn[iC]);
                    if (vrmin < measures[m].Err)
                    {
                        Sat->X[0] += Xn[iCmin];   Sat->Y[0] += Yn[iCmin];   Sat->Z[0] += Zn[iCmin];
                        Sat->VX[0] += VXn[iCmin]; Sat->VY[0] += VYn[iCmin]; Sat->VZ[0] += VZn[iCmin];
                        printf("\n M0= %d m=%d measuements matched error => next measurement",m0, m);
                        goto NEXT_MEASURE;
                    }
                }
                Sat->X[0] += Xn[iCmin];   Sat->Y[0] += Yn[iCmin];   Sat->Z[0] += Zn[iCmin];
                Sat->VX[0] += VXn[iCmin]; Sat->VY[0] += VYn[iCmin]; Sat->VZ[0] += VZn[iCmin];
                if (iCmin)
                {
                    VelError /=2;
                    printf("\n (2.0) VelErr=%.12f",VelError);
                }
                else
                {
                    if (n == 0)
                    {
                
                        //VelError *= Rn[0]*9.0/ RnSumm;
                        //printf("\n (main) VelErr=%.12f",VelError);
                        VelError /=1.5;
                        printf("\n (1.5) VelErr=%.12f",VelError);
                    }
                    else
                    {
                        VelError /=1.5;
                        printf("\n (1.5) VelErr=%.12f",VelError);
                    }
                }
            }
            printf("\nbest  X=%.12f,%.12f,%.12f,V=%.12f,%.12f,%.12f", Sat->X[0] - dlIX, Sat->Y[0] - dlIY, Sat->Z[0] - dlIZ, Sat->VX[0] - dlIVX, Sat->VY[0] - dlIVY, Sat->VZ[0] - dlIVZ);
            //if (m < m0)
            {
                if (Rn[iCmin] > measures[m].Err) // intermedian measurement did not match error needs to repeat steps
                {
                    printf("\n M0= %d m=%d erro is bigger %.12f=> repeat match ",m0, m,Rn[iCmin]);
                    nextm=1;
                    goto DO_MATHC_AGAIN;
                }
            }
NEXT_MEASURE:;
            printf("\ngood  X=%.12f,%.12f,%.12f,V=%.12f,%.12f,%.12f", Sat->X[0] - dlIX, Sat->Y[0] - dlIY, Sat->Z[0] - dlIZ, Sat->VX[0] - dlIVX, Sat->VY[0] - dlIVY, Sat->VZ[0] - dlIVZ);
        }
    }
    printf("\nfinal  X=%.12f,%.12f,%.12f,V=%.12f,%.12f,%.12f", Sat->X[0] - dlIX, Sat->Y[0] - dlIY, Sat->Z[0] - dlIZ, Sat->VX[0] - dlIVX, Sat->VY[0] - dlIVY, Sat->VZ[0] - dlIVZ);
    
}
void RunSim(TRAOBJ *SlS, TRAOBJ *Sat,TRAIMPLOBJ *Eng, long double ldFrom,long double ldFromTLEEpoch, long long iAllSec, int iItPerS, long double tSl)
{
    FILE *FileOut = fopen(SimulationTempOutputFile,"w");
    if (FileOut)
    {
        if (memcmp(SimulationType,"TLE",3) == 0)
        {
            int iCheck = 0;
            long double AE = 1.0;
#if _USE_ORIGINAL
            long double XKMPER = 6378.1350;//XKMPER kilometers/Earth radii 6378.135
#else
            long double XKMPER = 6378.137;
#endif
		    //long double XKE = BIG_XKE;//.743669161E-1;
            //long double XJ2 = 1.082616E-3;
            //long double CK2=.5*XJ2*AE*AE;
            long double XMNPDA = 1440.0; // XMNPDA time units(minutes) /day 1440.0
            long double TEMP=2*M_PI/XMNPDA/XMNPDA; // 2*pi / (1440 **2)
            long double ProbMeanMotion = Sat->ProbMeanMotion[iCheck];
            long double XNO=ProbMeanMotion*TEMP*XMNPDA; // rotation per day * 2*pi /1440 == rotation per day on 1 unit (1 min)
            long double XNDT2O=Sat->ProbFirstDervMeanMotion[iCheck]*TEMP;
            long double XNDD6O=Sat->ProbSecondDervmeanMotion[iCheck]*TEMP/XMNPDA;
            long double BSTAR=Sat->ProbDragterm[iCheck]/AE;
            long double tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ;
            // next lines has to be removed ==> today they are included only to avoid drag effect
            for (int i = 0; i < SimulationOutputCount; i++)
            {
                if (memcmp(UseSatData, "SGP",3)==0) 
                {
                    if (memcmp(UseSatData, "SGP4",4)==0)
                    {
			            SGP4((SimulationOutputTime[i] - Sat->ProbJD[iCheck])*XMNPDA, 
                            XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				            tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                    }
                    else if (memcmp(UseSatData, "SGP8",4)==0)
                    {
			            SGP8((SimulationOutputTime[i] - Sat->ProbJD[iCheck])*XMNPDA, 
                            XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				            tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                    }
                    else if  (memcmp(UseSatData, "SGP",3)==0)
                    {
			            SGP((SimulationOutputTime[i] - Sat->ProbJD[iCheck])*XMNPDA, 
                            XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                    }
                    tProbX=tProbX*XKMPER/AE*1000.0;                 tProbY=tProbY*XKMPER/AE*1000.0;                 tProbZ=tProbZ*XKMPER/AE*1000.0;
			        tProbVX=tProbVX*XKMPER/AE*XMNPDA/86400.*1000.0;	tProbVY=tProbVY*XKMPER/AE*XMNPDA/86400.*1000.0;	tProbVZ=tProbVZ*XKMPER/AE*XMNPDA/86400.*1000.0;
                }
                else    
                {
                    KeplerPosition(Sat->ProbJD[iCheck],SimulationOutputTime[i],      // prob epoch, and curent time
	    			    Sat->ProbTSec[iCheck], Sat->ProbEcc[iCheck], Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],  Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck], BSTAR,
                        Gbig *SolarSystem.M[EARTH],1, tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ, Sat->ProbMeanMotion[iCheck]);

                }

                if (strcmp(SimulationType,"TLE_G_CRS")==0) // it was request to generate position data with reference to geocentric CRS 
                {
                    fprintf(FileOut,"\n\t<gCRSmeasure>");
                    fprintf(FileOut,"\n\t <M>%d</M>",EARTH);
                    fprintf(FileOut,"\n\t\t<T>%.11f</T>\n\t\t<X>%.5f</X>\n\t\t<Y>%.5f</Y>\n\t\t<Z>%.5f</Z>", SimulationOutputTime[i],tProbX, tProbY, tProbZ);
                    fprintf(FileOut,"\n\t\t<E>1000</E>\n\t\t<D1>0.0</D1>\n\t\t<E1>0.0</E1>\n\t\t<T2>0.0</T2>\n\t\t<E2>0.0</E2>\n\t\t<D3>0.0</D3>\n\t\t<E3>0.0</E3>");
                    fprintf(FileOut,"\n\t</gCRSmeasure>");

                }
                else if (strcmp(SimulationType,"TLE_G_TRS")==0) // it was request to generate position data with reference to geocentric TRS 
                {
#if 1
                    printf("\n TBD");
#else
                    SYSTEMTIME ThatTime;
                    long double dSimTLEEpoch = ConvertJulianDayToDateAndTime(SimulationOutputTime[i], &ThatTime);
                    Sat->Lambda = GreenwichAscensionFromTLEEpoch(dSimTLEEpoch,Sat->precEps,Sat->precTet,Sat->precZ,Sat->nutEpsilon,Sat->nutDFeta);
                    Sat->gcrs_2_trs(tProbX, tProbY, tProbZ);
                    long double dlLAT, dlLON;
                    // LON == negative it is east; positive is west
                    long double H = Sat->GetH(tProbX, tProbY, tProbZ, 6378245.000, 6356863.019,dlLAT, dlLON);

                    fprintf(FileOut,"\n\t<gTRSmeasure>");
                    fprintf(FileOut,"\n\t <M>%d</M>",EARTH);
                    fprintf(FileOut,"\n\t\t<T>%.11f</T>\n\t\t<X>%.5f</X>\n\t\t<Y>%.5f</Y>\n\t\t<Z>%.5f</Z>", SimulationOutputTime[i],tProbX, tProbY, tProbZ);
                    fprintf(FileOut,"\n\t\t<H>%.5f</H>\n\t\t<LAT>%.11f</LAT>\n\t\t<LON>%.11f</LON>", H,dlLAT, dlLON);
                    fprintf(FileOut,"\n\t\t<E>1000</E>\n\t\t<D1>0.0</D1>\n\t\t<E1>0.0</E1>\n\t\t<T2>0.0</T2>\n\t\t<E2>0.0</E2>\n\t\t<D3>0.0</D3>\n\t\t<E3>0.0</E3>");
                    fprintf(FileOut,"\n\t</gTRSmeasure>");
#endif
                }
                else if (strcmp(SimulationType,"TLE_H_CRS")==0) // it was request to generate position data with reference to solar system CRS
                {
                    stateType  StateEarth;
                    stateType  StateMoon;
                    double dEMRAT = Find_DataInHeader("EMRAT ");
                    double dAU = Find_DataInHeader("AU    ")*1000.0;

                    Interpolate_State( SimulationOutputTime[i], EARTH , &StateEarth );
                    Interpolate_State( SimulationOutputTime[i], MOON , &StateMoon );

                    double BSX = StateEarth.Position[0]*1000.0 ;
                    double BSY = StateEarth.Position[1]*1000.0 ;
                    double BSZ = StateEarth.Position[2]*1000.0 ;
                    SlS->X[EARTH] = BSX - (StateMoon.Position[0]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                    SlS->Y[EARTH] = BSY - (StateMoon.Position[1]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                    SlS->Z[EARTH] = BSZ - (StateMoon.Position[2]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                    fprintf(FileOut,"\n\t<hCRSmeasure>");
                    fprintf(FileOut,"\n\t <M>-1</M>");
                    fprintf(FileOut,"\n\t\t<T>%.11f</T>\n\t\t<X>%.5f</X>\n\t\t<Y>%.5f</Y>\n\t\t<Z>%.5f</Z>", SimulationOutputTime[i],tProbX+SlS->X[EARTH], tProbY+SlS->Y[EARTH], tProbZ+SlS->Z[EARTH]);
                    fprintf(FileOut,"\n\t\t<E>1000</E>\n\t\t<D1>0.0</D1>\n\t\t<E1>0.0</E1>\n\t\t<T2>0.0</T2>\n\t\t<E2>0.0</E2>\n\t\t<D3>0.0</D3>\n\t\t<E3>0.0</E3>");
                    fprintf(FileOut,"\n\t</hCRSmeasure>");
                }
            }
        }
        else if (memcmp(SimulationType,"PING", 4) ==0) // simulate ping messages from ground station to satellite (at spesific time from all ground stations)
        {

        }
        else if (memcmp(SimulationType,"GPS",3) ==0) // simulate GPS's raw data from GPS satellites at specific time from GPS satellites
        {

        }
        else if (memcmp(SimulationType,"PULSAR",6) ==0) //simulate PULSAR receving signal from all pulsars at specific time
        {

        }
        fclose(FileOut);
        FileOut = NULL;
        if (UrlTraSimPort!= 0) // yes! it is agly - that is a case when visualization output must to be submit to some server
        {
            PostXMLToServer(SimulationOutputFile, UrlTraSimPort, szURLTraSimFileName, szTraSimFileName);
        }
    }
}
void PrintPV(TRAOBJ *SlS, TRAOBJ *Sat, int iCheck, long double ldFrom, long double Time_SecondsFromStart)
{
            long iSec = Time_SecondsFromStart;
            long double AE = 1.0;
#if _USE_ORIGINAL
            long double XKMPER = 6378.1350;//XKMPER kilometers/Earth radii 6378.135
#else
            long double XKMPER = 6378.137;
#endif
		    //long double XKE = BIG_XKE;//.743669161E-1;

            //long double XJ2 = 1.082616E-3;
            //long double CK2=.5*XJ2*AE*AE;

            long double XMNPDA = 1440.0; // XMNPDA time units(minutes) /day 1440.0
            long double TEMP=2*M_PI/XMNPDA/XMNPDA; // 2*pi / (1440 **2)
            long double ProbMeanMotion = Sat->ProbMeanMotion[iCheck];
            long double XNO=ProbMeanMotion*TEMP*XMNPDA; // rotation per day * 2*pi /1440 == rotation per day on 1 unit (1 min)
            long double XNDT2O=Sat->ProbFirstDervMeanMotion[iCheck]*TEMP;
            long double XNDD6O=Sat->ProbSecondDervmeanMotion[iCheck]*TEMP/XMNPDA;
            long double BSTAR=Sat->ProbDragterm[iCheck]/AE;
            long double tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ;
            // next lines has to be removed ==> today they are included only to avoid drag effect

            //long double TimeFromEpochOfSatInDays = fmod(Sat.ProbEpochOnStart[iCheck] + Time_SecondsFromStart/24.0/60.0/60.0, 1.0/Sat.ProbMeanMotion[iCheck]);
            // first parameter in in minutes from epoch
            if (memcmp(UseSatData, "SGP",3)==0) 
            {
                if (memcmp(UseSatData, "SGP4",4)==0)
                {
			        SGP4((ldFrom - Sat->ProbJD[iCheck]+Time_SecondsFromStart/24.0/60.0/60.0)*XMNPDA, 
                        XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                }
                else if (memcmp(UseSatData, "SGP8",4)==0)
                {
    			    SGP8((ldFrom - Sat->ProbJD[iCheck]+Time_SecondsFromStart/24.0/60.0/60.0)*XMNPDA, 
                        XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                }
                else if  (memcmp(UseSatData, "SGP",3)==0)
                {
			        SGP((ldFrom - Sat->ProbJD[iCheck]+Time_SecondsFromStart/24.0/60.0/60.0)*XMNPDA, 
                        XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
	    			    tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                }
                tProbX=tProbX*XKMPER/AE*1000.0;                 tProbY=tProbY*XKMPER/AE*1000.0;                 tProbZ=tProbZ*XKMPER/AE*1000.0;
			    tProbVX=tProbVX*XKMPER/AE*XMNPDA/86400.*1000.0;	tProbVY=tProbVY*XKMPER/AE*XMNPDA/86400.*1000.0;	tProbVZ=tProbVZ*XKMPER/AE*XMNPDA/86400.*1000.0;
            }
            else
            {
                KeplerPosition(Sat->ProbJD[iCheck],ldFrom+Time_SecondsFromStart/24.0/60.0/60.0,      // prob epoch, and curent time
	    			    Sat->ProbTSec[iCheck], Sat->ProbEcc[iCheck], Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],  Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck], BSTAR,
                        Gbig *SolarSystem.M[EARTH],1, tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ, Sat->ProbMeanMotion[iCheck]);
            }
            long double tX, tY, tZ, tVX, tVY, tVZ;
            tX = Sat->X[iCheck] - SlS->X[EARTH];      tY = Sat->Y[iCheck] - SlS->Y[EARTH];      tZ = Sat->Z[iCheck] - SlS->Z[EARTH];
		    tVX = Sat->VX[iCheck] - SlS->VX[EARTH];   tVY = Sat->VY[iCheck] - SlS->VY[EARTH];   tVZ = Sat->VZ[iCheck] - SlS->VZ[EARTH];
            long double ttProbX, ttProbY, ttProbZ, ttProbVX, ttProbVY, ttProbVZ;
            ttProbX	= tX - tProbX;ttProbY= tY - tProbY; ttProbZ	= tZ - tProbZ;
            ttProbVX = tVX - tProbVX; ttProbVY = tVY - tProbVY; ttProbVZ = tVZ - tProbVZ;
            long double tttX, tttVX;
            tttX = sqrt(ttProbX*ttProbX + ttProbY*ttProbY + ttProbZ*ttProbZ);
            tttVX = sqrt(ttProbVX*ttProbVX + ttProbVY*ttProbVY + ttProbVZ*ttProbVZ);
            double errorCos = (tVX*tProbVX + tVY*tProbVY + tVZ*tProbVZ)/ (sqrt(tVX*tVX +tVY*tVY + tVZ*tVZ)* sqrt(tProbVX*tProbVX + tProbVY*tProbVY + tProbVZ*tProbVZ));
            //double errAngle =  acos(errorCos);
            double errorD = sqrt(tVX*tVX + tVY*tVY + tVZ*tVZ)/sqrt(tProbVX*tProbVX + tProbVY*tProbVY + tProbVZ*tProbVZ);
            double SinAngle = tZ / sqrt(tX*tX + tY*tY + tZ*tZ);
            double SinAngle2 = tX / sqrt(tX*tX + tY*tY);

            double ErrorDD = sqrt(tVX*tVX + tVY*tVY + tVZ*tVZ) - sqrt(tProbVX*tProbVX + tProbVY*tProbVY + tProbVZ*tProbVZ);
            //  printf("\n%f err(X=%f V=%f pr=%f lv=%f) min=%d ",(asin(SinAngle)*180/M_PI),tttX,tttVX, errorD, ErrorDD,iCurSec/60);
            printf("\n%8.4f %8.4f X=%13.5f,%13.5f,%13.5f V=%13.5f,%13.5f,%13.5f e= %f %f  %d",(asin(SinAngle)*180/M_PI),(asin(SinAngle2)*180/M_PI),
            tProbX - tX, tProbY - tY, tProbZ - tZ,
            tProbVX - tVX,tProbVY - tVY,tProbVZ - tVZ,
            tttX,tttVX,iSec/60);

}
void RunProp(TRAOBJ *SlS, TRAOBJ *Sat,TRAIMPLOBJ *Eng, long double ldFrom,long double ldFromTLEEpoch, long long iAllSec, int iItPerS, long double tSl)
{
    SlS->TimeSl = tSl;
    SlS->TimeSl_2 = tSl*tSl;
    long long iSec;
    int iPortionSec;
    int StartSequence = 0;
    int iDay =0;
    long double MinMaxX = .0;
    long double MinMaxY = .0;
    long double MinMaxZ = .0;
    int flFindFirst1KmError = 1;
    stateType  StateEarth;
    stateType  StateMoon;
    double dErrorValue = 10.0; // 1km error == 1km*1km
    long double Time_SecondsFromStart=0;
    int iDistance =0;
    int Apogee = 0;
    int Perigee = 10000000;
    int ApPerStatus = 0; // search for apogee
    int iCountDelay= 0;
	
    for (iSec = 0; iSec < iAllSec; iSec++)
    {
        for (iPortionSec = 0; iPortionSec < iItPerS; iPortionSec++)
        {
            if (JustFlySimulation == 0)
            {
                if (RunOrVoidEngine(1, Eng, SlS, Sat, iSec, iPortionSec, iItPerS, ldFrom))
                {
                        // engine is running
                }
                else
                {
                }
            }
            IteraSat(1, SlS, Sat,ldFromTLEEpoch + (iSec +   (long double)iPortionSec/(long double)iItPerS) /86400.0) ;
            IteraSolarSystem(TRUE, SlS);

            EarthX = SlS->X[EARTH];     EarthY = SlS->Y[EARTH];       EarthZ = SlS->Z[EARTH];
            MoonX = SlS->X[MOON];       MoonY = SlS->Y[MOON];         MoonZ = SlS->Z[MOON];
            if (Sat->h[0] < 0)
            {
                //printf("\n Landed on Earth at sec = %d", iCurSec);
                Sat->flInUse[0] = 0;
            }
            if (iDistance != (int)Sat->Distance[0][EARTH])
            {
                iDistance = (int)Sat->Distance[0][EARTH];
                Sat->iAtm[0] = 1;

            }
            if (ApPerStatus == 0)
            {
                if (Apogee <= (int)Sat->Distance[0][EARTH])
                    Apogee = Sat->Distance[0][EARTH];
                else
                {
                    ApPerStatus = 1; // delay
                    iCountDelay = 100;
                    Time_SecondsFromStart = (iSec +   (long double)(iPortionSec+1)/(long double)iItPerS);
                    PrintPV(SlS, Sat, 0, ldFrom, Time_SecondsFromStart);
                }

            } else if (ApPerStatus == 1)
            {
                if (--iCountDelay == 0)
                {
                    ApPerStatus = 2; // search for perigee
                    Perigee = 1000000000;
                }
            } else if (ApPerStatus == 2)
            {
                if (Perigee >= (int)Sat->Distance[0][EARTH])
                    Perigee = Sat->Distance[0][EARTH];
                else
                {
                    ApPerStatus = 3; // delay
                    iCountDelay = 100;
                }
            } else if (ApPerStatus == 3)
            {
                if (--iCountDelay == 0)
                {
                    ApPerStatus = 0; // search for apogee
                    Apogee  = 0;
                }
            }

            /*if (Apogee <= (int)Sat->Distance[0][EARTH])
            {
                Apogee = Sat->Distance[0][EARTH];
                wasPlus = 1;
            }
            else
            {
                if (wasPlus == 1) // was apogee
                {
                    Time_SecondsFromStart = (iSec +   (long double)(iPortionSec+1)/(long double)iItPerS);
                    PrintPV(SlS, Sat, 0, ldFrom, Time_SecondsFromStart);
                }
                wasPlus = 0;
                Apogee = 0;
            }*/


            double ProbX = Sat->X[0]; double ProbY = Sat->Y[0];      double ProbZ = Sat->Z[0];
            long double dRM, dRM0,dREMV;
            {
                dRM = sqrt( (ProbX - MoonX)*(ProbX - MoonX)+ (ProbY - MoonY)*(ProbY - MoonY)+ (ProbZ - MoonZ)*(ProbZ - MoonZ) );
                dRM0 = dRM;

                if (dRM < MoonR) // TBD Moon is not round!!!
                {
                    double LongOnMoon = 0.0; // dolgota
                    double LatiOnMoon = 0.0; // shirota
                    double PosXMoon = 0;
                    double PosYMoon = 0;
                    double PosZMoon = 0;
                    getLongLatiMoon(LongOnMoon,LatiOnMoon,SlS,MOON,EARTH,Sat,0);
                    getXYZMoon(LongOnMoon,LatiOnMoon,PosXMoon,PosYMoon,PosZMoon,SlS,MOON,EARTH,dRM);
                    dREMV = sqrt((SlS->VX[MOON]-Sat->VX[0])*(SlS->VX[MOON]-Sat->VX[0])+(SlS->VY[MOON]-Sat->VY[0])*(SlS->VY[MOON]-Sat->VY[0])+(SlS->VZ[MOON]-Sat->VZ[0])*(SlS->VZ[MOON]-Sat->VZ[0]));
                    printf("\n Landed on Moon at sec = %f x=%f Y=%f z=%f V=%f", 
                            ((double)iSec) + SlS->TimeSl*((double)iPortionSec), Sat->X[0] -SolarSystem.X[MOON], Sat->Y[0] -SolarSystem.Y[MOON], Sat->Z[0] -SolarSystem.Z[MOON],dREMV);
                    printf("\n Longitute = %f Latitute %f", LongOnMoon, LatiOnMoon);
                    //printf("\n Landed weight = %f from initial = %f (%f percent)", Sat->M[0], MyTrySat.M[0],Sat->M[0]/MyTrySat.M[0]);
#ifdef _DO_VISUALIZATION
                    // store last image 
                    //DrawAnimationSequence(&SolarSystem,&Sat, i,"TRA",&SolarSystem, RGBReferenceBody, dRGBScale, StartSequence, 1);
                    DrawFinalBody(SlS, MOON, Sat, iSec,"TRA", SlS, RGBReferenceBody, dRGBScale, StartSequence);
#endif
                    //dumpXMLParam(&MyTrySat, &Engine[0],EnginesCount);
                    Sat->flInUse[0] = 0;
                    exit(0);
                }
            }
        }

        // this is 1 day position 
        if (iSec%(60*60*24) ==0)
        {
            iDay++;
            printf("\nd=%d x=%f y=%f z=%f \tMx=%f y=%f z= %f", iDay, MinMaxX, MinMaxY, MinMaxZ, 
                        SlS->X[MOON] - SlS->X[EARTH], SlS->Y[MOON] - SlS->Y[EARTH], SlS->Z[MOON] - SlS->X[EARTH]);
        }
        // this flag switch on/off comparation of calculated data against JPL 410
        if (flFindFirst1KmError)
        {
            Interpolate_State( ldFrom+((double)(iSec+1))/(24.0*60.0*60.0) , EARTH , &StateEarth );
            Interpolate_State( ldFrom+((double)(iSec+1))/(24.0*60.0*60.0) , MOON , &StateMoon );
            MoonX = SolarSystem.X[MOON];    MoonY = SolarSystem.Y[MOON];    MoonZ = SolarSystem.Z[MOON];

            EarthX = SolarSystem.X[EARTH];  EarthY = SolarSystem.Y[EARTH];  EarthZ = SolarSystem.Z[EARTH];
#ifdef  TEST_RUN_EARTH_ERROR
            // this error checks position of earth-moon
            // barycentre against JPL
            double EarthBSX = (EarthX*SlS->M[EARTH] + MoonX*SlS->M[MOON])/(SlS->M[EARTH]+SlS->M[MOON]);
            double EarthBSY = (EarthY*SlS->M[EARTH] + MoonY*SlS->M[MOON])/(SlS->M[EARTH]+SlS->M[MOON]);
            double EarthBSZ = (EarthZ*SlS->M[EARTH] + MoonZ*SlS->M[MOON])/(SlS->M[EARTH]+SlS->M[MOON]);

            double EarthBSNX =  StateEarth.Position[0]*1000.0 ;
            double EarthBSNY =  StateEarth.Position[1]*1000.0 ;
            double EarthBSNZ =  StateEarth.Position[2]*1000.0 ;

#else
            // otherwise it will be Moon position
            double EarthBSX = ( MoonX - EarthX); 
            double EarthBSY = ( MoonY - EarthY);
            double EarthBSZ = ( MoonZ - EarthZ);

            double EarthBSNX =  StateMoon.Position[0]*1000.0 ;
            double EarthBSNY =  StateMoon.Position[1]*1000.0 ;
            double EarthBSNZ =  StateMoon.Position[2]*1000.0 ;

#endif
            double tDeltaEarthJPL = (( EarthBSX - EarthBSNX)*( EarthBSX - EarthBSNX) +
                                     ( EarthBSY - EarthBSNY)*( EarthBSY - EarthBSNY) +
                                     ( EarthBSZ - EarthBSNZ)*( EarthBSZ - EarthBSNZ)
                                    );
            if (tDeltaEarthJPL> dErrorValue)
            {
                // error bigger then 1000 M
                double flX;
                double flY;
                double flZ;
                MoonVX = SlS->VX_[MOON]*SlS->TimeSl / SlS->M[MOON];
                MoonVY = SlS->VY_[MOON]*SlS->TimeSl / SlS->M[MOON];
                MoonVZ = SlS->VZ_[MOON]*SlS->TimeSl / SlS->M[MOON];

                EarthVX = SlS->VX_[EARTH]*SlS->TimeSl / SlS->M[EARTH];
                EarthVY = SlS->VY_[EARTH]*SlS->TimeSl / SlS->M[EARTH];
                EarthVZ = SlS->VZ_[EARTH]*SlS->TimeSl / SlS->M[EARTH];
#ifdef TEST_RUN_EARTH_ERROR
                double EarthBSVX = EarthVX;
                double EarthBSVY = EarthVY;
                double EarthBSVZ = EarthVZ;
                double EarthBSNVX =  StateEarth.Velocity[0]*1000.0 ;
                double EarthBSNVY =  StateEarth.Velocity[1]*1000.0 ;
                double EarthBSNVZ =  StateEarth.Velocity[2]*1000.0 ;
                printf("\n Error in Earth position bigger then %f M", sqrt(tDeltaEarthJPL));
#else
                double EarthBSVX = ( MoonVX - EarthVX);
                double EarthBSVY = ( MoonVY - EarthVY);
                double EarthBSVZ = ( MoonVZ - EarthVZ);
                double EarthBSNVX =  StateMoon.Velocity[0]*1000.0 ;
                double EarthBSNVY =  StateMoon.Velocity[1]*1000.0 ;
                double EarthBSNVZ =  StateMoon.Velocity[2]*1000.0 ;
                printf("\n Error in Moon position bigger then %f M", sqrt(dErrorValue));
#endif
                dErrorValue*=2.0;
                printf("\n=%f \nx=%f y=%f z=%f ; JPL EPHEMERIDES:\nx=%f y=%f z=%f %ld sec + %f - %f sec ", 
                                    sqrt(tDeltaEarthJPL), EarthBSX, EarthBSY, EarthBSZ, EarthBSNX, EarthBSNY, EarthBSNZ,
                                    iSec, SlS->TimeSl*iPortionSec, SlS->TimeSl*(iPortionSec+1));
                MoonXYZCalc(flX, flY, flZ, (ldFrom+((double)(iSec+1))/(24.0*60.0*60.0) - 2451544.0)/36525.0);
                printf("\nMoon position by sin/cos approximation\n x=%f  y=%f  z=%f\nvx=%f vy=%f vz=%f ; JPL EPHEMERIDES:\nvx=%f vy=%f vz=%f ", 
                                    flX,flY,flZ, EarthBSVX, EarthBSVY, EarthBSVZ, EarthBSNVX, EarthBSNVY, EarthBSNVZ );
            }
            else
            {
            }

        }
#ifdef _DO_VISUALIZATION
        DrawAnimationSequence(SlS,Sat, iSec,"TRA",SlS, RGBReferenceBody, dRGBScale, StartSequence, 0); 
#endif
        
        if (iSec%(60*60*24) == 0)
        {
            // on first sattelite do compare of the calculated position and SGP4 
            int iCheck = 0;
            Time_SecondsFromStart = (long double) (iSec+1);
            PrintPV(SlS, Sat, 0, ldFrom, Time_SecondsFromStart);
        }
        //Sat.X[0] = tProbX + SolarSystem.X[EARTH]; Sat.Y[0] = tProbY + SolarSystem.Y[EARTH]; Sat.Z[0] = tProbZ + SolarSystem.Z[EARTH];
        //Sat.VX[0] = tProbVX + SolarSystem.VX[EARTH]; Sat.VY[0] = tProbVY + SolarSystem.VY[EARTH]; Sat.VZ[0] = tProbVZ + SolarSystem.VZ[EARTH];

        // needs to dump data for visualization each XX sec
        if (iSec%(60) == 0) // each min output data to XML file
			    dumpTRAvisual(iSec);
		}
		OutLast = TRUE;
		dumpTRAvisual(iSec);
		printf("\n iteration done");
#ifdef _DO_VISUALIZATION
        // store last image 
        //DrawAnimationSequence(&SolarSystem,&Sat, i,"TRA",&SolarSystem, RGBReferenceBody, dRGBScale, StartSequence, 1);
        DrawFinalBody(SlS, MOON, Sat, iSec,"TRA", SlS, RGBReferenceBody, dRGBScale, StartSequence);
#endif
}

void CalcForcesPoly(TRAOBJ *Sat, long double XdivR, long double YdivR, long double sinTetta, long double Height,
                    long double &Fx, long double &Fy, long double &Fz,
                    int iDoList[10][4], int nDoList, int iSkipList[10][4], int nSkipList)
{
    long double Xk[TOTAL_COEF+3];
    long double Yk[TOTAL_COEF+3];
    long double X,Y,Z, Xadd, Yadd, Zadd;
    long double X_,Y_,Z_, Xadd_, Yadd_, Zadd_;
    Sat->R0divR[0] = 1;
    Sat->R0divR[1] = R0_MODEL/Height;
    Sat->FillXkYk(XdivR, YdivR, Xk, Yk);
    Sat->PowerR(Sat->R0divR);
    Sat->PartSummXYZ (Xk,Yk, sinTetta,  X, Xadd, Yadd, Zadd, iDoList[0][0], iDoList[0][1], iDoList[0][2], iDoList[0][3]);
                           Y=X;            Z=X;
    // if skiplist present then 1 can be skipped
    if (nSkipList)
    {
        X=-X;         Y=-Y;          Z=-Z;
    }
    else
    {
        X=1-X;         Y=1-Y;          Z=1-Z;
    }
    Xadd = -Xadd;  Yadd = -Yadd;   Zadd = -Zadd;
    // data to calulate in DoList
    for (int id =1; id < nDoList; id++)
    {
        Sat->PartSummXYZ (Xk,Yk, sinTetta,  X_, Xadd_, Yadd_, Zadd_, iDoList[id][0], iDoList[id][1], iDoList[id][2], iDoList[id][3]);
                         Y_=X_;            Z_=X_;
        X_=-X_;          Y_=-Y_;           Z_=-Z_;
        Xadd_ = -Xadd_;  Yadd_ = -Yadd_;   Zadd_ = -Zadd_;
        X+=X_;           Y+=Y_;            Z+=Z_;
        Xadd += Xadd_; Yadd += Yadd_; Zadd += Zadd_;
    }
    // next is minus values - Poly from n=2 k= 0 can be ignored
    long double Xm1, Ym1, Zm1;
    long double Xaddm1, Yaddm1, Zaddm1;
    Xm1 = 0; Ym1 = 0; Zm1 = 0; Xaddm1 = 0; Yaddm1 = 0; Zaddm1 = 0;
    long double Xm2;
    long double Xaddm2, Yaddm2, Zaddm2;
                
    for (int is = 0; is < nSkipList; is++)
    {
        Sat->PartSummXYZ (Xk,Yk, sinTetta,  Xm2, Xaddm2, Yaddm2, Zaddm2, iSkipList[is][0], iSkipList[is][1], iSkipList[is][2], iSkipList[is][3]);
        Xm1+=-Xm2;         Ym1+=-Xm2;          Zm1+=-Xm2;

        Xaddm1 += -Xaddm2;  Yaddm1 += -Yaddm2;   Zaddm1 += -Zaddm2;
    }
    Fx =(X-Xm1)*XdivR + (Xadd-Xaddm1);
    Fy =(Y-Ym1)*YdivR + (Yadd-Yaddm1);
    Fz =(Z-Zm1)*sinTetta + (Zadd-Zaddm1);
    // get FORCE from Legandre Poly
    long double ForceDD = GM_MODEL / (Height*Height);
    Fx *=ForceDD;   Fy *=ForceDD;      Fz *=ForceDD;
}

void MinusPointForces(long double &FX, long double &FY, long double &FZ, 
                      long double Xtt, long double Ytt, long double Ztt, int imp, int imp_skip)
{
    int j;
    long double ValX0, ValY0, ValZ0, tD_Obj1Obj2, tD_, Sat_ForceDD_i_j, Sat_ForceDD_i_j_div_Sat_Distance_i_j;
    for (j = 0; j < imp; j++)
    {
        if (imp_skip != j)
        {
            ValX0 = (Xtt-MassPoints[j].X);
            ValY0 = (Ytt-MassPoints[j].Y);
            ValZ0 = (Ztt-MassPoints[j].Z);
            tD_Obj1Obj2 = ValX0*ValX0 + ValY0*ValY0 + ValZ0*ValZ0;
            tD_ = sqrt(tD_Obj1Obj2);
            Sat_ForceDD_i_j = MassPoints[j].Mp * GM_MODEL / (tD_Obj1Obj2*tD_);
            FX -= (ValX0) * Sat_ForceDD_i_j;
            FY -= (ValY0) * Sat_ForceDD_i_j;
            FZ -= (ValZ0) * Sat_ForceDD_i_j;
       }
    }
}

long double Functional(TRAOBJ *Sat, int iTotalCheckPoints, int dk, int iDoList[10][4], int nDoList,int iSkipList[10][4], int nSkipList, 
int imp, int imp_skip)
{
    int i;
    int k;
    long double Height;
    long double DHeight;
    long double Xt, Yt, Zt;
    long double X, Y, Z;
    long double Xadd, Yadd, Zadd;
    long double X_, Y_, Z_;
    long double Xadd_, Yadd_, Zadd_;

    long double sinTetta, XdivR, YdivR;
    long double Xk[TOTAL_COEF+3];
    long double Yk[TOTAL_COEF+3];
    long double FX,FY,FZ;
    long double ForceDD;
    long double Norm;
    long double Xn, Yn, Zn;
    long double Angl;
    long double NormZero;
    long double ZeroX, ZeroY, ZeroZ;
    long double ErrorMainX,ErrorMainY, ErrorMainZ;
    long double ErrorMain;
    long double MidDist;
    long double ValX0;
    long double ValY0;
    long double ValZ0;
    long double tD_Obj1Obj2;
    long double tD_;
    long double Sat_ForceDD_i_j;
    long double Sat_ForceDD_i_j_div_Sat_Distance_i_j;
    long double Sat_FX;
    long double Sat_FY;
    long double Sat_FZ;
    ErrorMain = 0;

    for (i = 0; i < iTotalCheckPoints; i++)
    {
        Height =MinH;
        DHeight = (MaxH - MinH)/dk;

        for( k= 0; k < dk; k++, Height+=DHeight)
        {
            ForceDD = GM_MODEL / (Height*Height);
            Xt = Height*TotalCheckPoints[i][0];
            Yt = Height*TotalCheckPoints[i][1];
            Zt = Height*TotalCheckPoints[i][2];
            CalcForcesPoly(Sat, TotalCheckPoints[i][0], TotalCheckPoints[i][1], TotalCheckPoints[i][2], Height,
                    FX,FY,FZ,    iDoList, nDoList, iSkipList,nSkipList);

            ErrorMainX = FX;
            ErrorMainY = FY;
            ErrorMainZ = FZ;

            MinusPointForces(ErrorMainX, ErrorMainY, ErrorMainZ, Xt, Yt, Zt, imp, -1);

            ErrorMain += sqrt(ErrorMainX*ErrorMainX + ErrorMainY*ErrorMainY + ErrorMainZ*ErrorMainZ);
        }
    }
    return ErrorMain;
}
long double BallanceMass(long double StoreMass[(TOTAL_COEF+3)*(TOTAL_COEF+3)], int imp, int imp_set, long double Step)
{
    long double TotalMass = 0;
    int j;
    long double Divisor = imp -1;
    for (j = 0; j < imp; j++)
    {
        MassPoints[j].Mp = StoreMass[j];
        if (imp_set != j)
        {
            TotalMass += MassPoints[j].Mp;
        }
    }
    if (imp ==0)
        return 1.0;
    if (imp ==1)
        return 1.0;
    Divisor = Step/Divisor;
    for (j = 0 ; j < imp; j++)
    {
        if (imp_set != j)
        {
            MassPoints[j].Mp -=Divisor;
        }
    }
    return (1.0 - TotalMass + Step);
}
void FindPosWinMinError(long double &NormZero, long double ForceNorm, long double Angl, long double &NVectorLen, long double PreSeeror,
    long double Xt, long double Yt, long double Zt, long double Xn, long double Yn, long double Zn,
    int iDoList[10][4], int nDoList, 
    int iTotalCheckPoints, TRAOBJ *Sat, int iSkipList[10][4], int nSkipList, int imp, int imp_skip, int imp_set)
{
    // initial step
    NormZero = NVectorLen * cos(Angl);
    long double ZeroX = Xt -NormZero *Xn;
    long double ZeroY = Yt -NormZero *Yn;
    long double ZeroZ = Zt -NormZero *Zn;

    long double Xtt = Xt - 2.0*NormZero *Xn;
    long double Ytt = Yt - 2.0*NormZero *Yn;
    long double Ztt = Zt - 2.0*NormZero *Zn;

    long double Heightt = sqrt(Xtt*Xtt + Ytt*Ytt + Ztt*Ztt);
    long double XttdivH = Xtt/ Heightt;
    long double YttdivH = Ytt/Heightt;
    long double ZttdivH = Ztt/Heightt;
            //Sat_ForceDD_i_j = MassPoints[j].Mp * GM_MODEL / (tD_Obj1Obj2*tD_);

    MassPoints[imp_set].Mp = ForceNorm * NormZero*NormZero / GM_MODEL;
    MassPoints[imp_set].X = ZeroX; MassPoints[imp_set].Y = ZeroY; MassPoints[imp_set].Z = ZeroZ;
    long double FX,FY,FZ;

    CalcForcesPoly(Sat, XttdivH, YttdivH, ZttdivH, Heightt, FX,FY,FZ,    iDoList, nDoList, iSkipList,nSkipList);
    int iSet = imp_set;
    if (iSet >= imp)
        iSet = imp+1;
    MinusPointForces(FX, FY, FZ, Xtt, Ytt, Ztt, iSet, imp_skip);

    long double ErrorMain1 = FX*FX + FY*FY + FZ*FZ;
    if (ErrorMain1 == 0)
        return;
    PreSeeror *= ErrorMain1;

    long double Step = 1.0;

    NVectorLen += Step;

    NormZero = NVectorLen * cos(Angl);
    ZeroX = Xt -NormZero *Xn;
    ZeroY = Yt -NormZero *Yn;
    ZeroZ = Zt -NormZero *Zn;

    Xtt = Xt - 2.0*NormZero *Xn;
    Ytt = Yt - 2.0*NormZero *Yn;
    Ztt = Zt - 2.0*NormZero *Zn;

    Heightt = sqrt(Xtt*Xtt + Ytt*Ytt + Ztt*Ztt);
    XttdivH = Xtt/ Heightt;
    YttdivH = Ytt/Heightt;
    ZttdivH = Ztt/Heightt;
            //Sat_ForceDD_i_j = MassPoints[j].Mp * GM_MODEL / (tD_Obj1Obj2*tD_);

    MassPoints[imp_set].Mp = ForceNorm * NormZero*NormZero / GM_MODEL;
    MassPoints[imp_set].X = ZeroX; MassPoints[imp_set].Y = ZeroY; MassPoints[imp_set].Z = ZeroZ;

    CalcForcesPoly(Sat, XttdivH, YttdivH, ZttdivH, Heightt, FX,FY,FZ,    iDoList, nDoList, iSkipList,nSkipList);
    MinusPointForces(FX, FY, FZ, Xtt, Ytt, Ztt, iSet, imp_skip);

    long double ErrorMain2 = FX*FX + FY*FY + FZ*FZ;
    while (1)
    {
        if (fabs(ErrorMain1 - ErrorMain2) <PreSeeror)
        {
            if (ErrorMain1 >= ErrorMain2)
                break;
            else
            {
                break;
            }
        }

        if (ErrorMain2 < ErrorMain1)
        {
            // contine steps
            ErrorMain1 = ErrorMain2;
        }
        else
        {
            // step reverce direction and make step twice smaller
            ErrorMain1 = ErrorMain2;

            Step = -Step/2;
            if (fabs(Step) < PreSeeror)
                break;
        }
        NVectorLen += Step;

        NormZero = NVectorLen * cos(Angl);
        ZeroX = Xt -NormZero *Xn;
        ZeroY = Yt -NormZero *Yn;
        ZeroZ = Zt -NormZero *Zn;

        Xtt = Xt - 2.0*NormZero *Xn;
        Ytt = Yt - 2.0*NormZero *Yn;
        Ztt = Zt - 2.0*NormZero *Zn;

        Heightt = sqrt(Xtt*Xtt + Ytt*Ytt + Ztt*Ztt);
        XttdivH = Xtt/ Heightt;
        YttdivH = Ytt/Heightt;
        ZttdivH = Ztt/Heightt;
            //Sat_ForceDD_i_j = MassPoints[j].Mp * GM_MODEL / (tD_Obj1Obj2*tD_);

        MassPoints[imp_set].Mp = ForceNorm * NormZero*NormZero / GM_MODEL;
        MassPoints[imp_set].X = ZeroX; MassPoints[imp_set].Y = ZeroY; MassPoints[imp_set].Z = ZeroZ;

        CalcForcesPoly(Sat, XttdivH, YttdivH, ZttdivH, Heightt, FX,FY,FZ,    iDoList, nDoList, iSkipList,nSkipList);
        MinusPointForces(FX, FY, FZ, Xtt, Ytt, Ztt, iSet, imp_skip);
        ErrorMain2 = FX*FX + FY*FY + FZ*FZ;
    }

}
void NormMassPoints(int imp, long double StepM, int j, MASS_POINT_ELEMENT MassPointsI[(TOTAL_COEF+3)*(TOTAL_COEF+3)],
    MASS_POINT_ELEMENT MassPointsSumm[(TOTAL_COEF+3)*(TOTAL_COEF+3)],
    MASS_POINT_ELEMENT MassPointsV[10][(TOTAL_COEF+3)*(TOTAL_COEF+3)])
{
    // first step nothing can be bigger than 1
    int i;
    long double SummM = 0;
    for( i = 0; i < imp+1; i++)
    {
        SummM += MassPoints[i].Mp;
    }
    SummM -= 1.0 ;
    if (SummM != 0.0)
    {
        SummM /= imp+1;
        for( i = 0; i < imp+1; i++)
        {
            MassPoints[i].Mp -= SummM;
        }
        // now make it less then 1 each
        SummM = MassPoints[0].Mp ;
        for( i = 1; i < imp+1; i++)
        {
            if (SummM < MassPoints[i].Mp)
                SummM =MassPoints[i].Mp;
        }
        if (SummM > 1.0)
        {
            for( i = 0; i < imp+1; i++)
            {
                MassPoints[i].Mp/=SummM;
            }
            SummM = 0;
            for( i = 0; i < imp+1; i++)
            {
                SummM += MassPoints[i].Mp;
            }
            SummM -= 1.0 ;
            if (SummM != 0.0)
            {
                SummM /= imp+1;
                for( i = 0; i < imp+1; i++)
                {
                    MassPoints[i].Mp -= SummM;
                }
            }
        }
    }
    for( i = 0; i < imp+1; i++)
    {
        //MassPoints[i].Mp = MassPointsI[i].Mp + 0.5*MassPointsSumm[i].Mp + 0.5*MassPointsV[j][i].Mp;
        MassPointsV[j][i].Mp = (MassPoints[i].Mp - (MassPointsI[i].Mp + 0.5*MassPointsSumm[i].Mp))/0.5;
    }
    
}
void GetOneMassPoint( long double &ErrorMain1, 
    long double &Step, int iDoList[10][4], int nDoList, int dk,
    int iTotalCheckPoints, TRAOBJ *Sat, int iSkipList[10][4], int nSkipList, int imp, int imp_skip, int imp_set)
{
    // initial algorithm in:
    // from ftp://ftp.gfz-potsdam.de/home/sf/bar/publications/BaDie-Milan90.pdf
    // 1. loop for all points and find max abs value of the GP - (summ of all GPf of N-1 points)
    // 2. from selected point goes to the center of the planet to get minimum of the functonal (summ all errors are minimum) that point will be P_candidate
    // 3. find closes points P_close_list (k_val) to P_candidate add to a list P_close_list+P_candidate (size == k_val+1)
    // 4. find optimized value of masses in the P_close_list:
    //    a) loop for each point in the P_close_list find for mass minimum of the functional
    //    b) repeat loop till functional is minimal
    //    (all is ehuristic process == BAD == points position has to be optimized)
    //    lets try montecarlo - kill the problem with random data
    int i,j,k;
    long double Height;
    long double DHeight;
    long double Xt, Yt, Zt;
    long double X, Y, Z;
    long double Xadd, Yadd, Zadd;
    long double X_, Y_, Z_;
    long double Xadd_, Yadd_, Zadd_;
    long double sinTetta, XdivR, YdivR;
    long double Xk[TOTAL_COEF+3];
    long double Yk[TOTAL_COEF+3];
    long double FX,FY,FZ;
    long double ForceDD;
    long double Norm;
    long double Xn, Yn, Zn;
    long double Angl;
    long double NormZero;
    long double ZeroX, ZeroY, ZeroZ;
    long double CenterOfMAssX, CenterOfMAssY, CenterOfMAssZ,Mass;
    long double NVectorX, NVectorY, NVectorZ, NVectorLen;

    long double StoreMass[(TOTAL_COEF+3)*(TOTAL_COEF+3)];
    CenterOfMAssX =0; CenterOfMAssY=0; CenterOfMAssZ=0; Mass=0;
    if (imp)
    {
        for (i = 0; i < imp; i++)
        {
            CenterOfMAssX+= MassPoints[i].X*MassPoints[i].Mp;
            CenterOfMAssY+= MassPoints[i].Y*MassPoints[i].Mp;
            CenterOfMAssZ+= MassPoints[i].Z*MassPoints[i].Mp;
            Mass += MassPoints[i].Mp;
        }
        CenterOfMAssX/=Mass; CenterOfMAssY/=Mass; CenterOfMAssZ/=Mass;
    }
    
    // first run - to find point
    long double SumZeroX, SumZeroY, SumZeroZ;

    SumZeroX = 0; SumZeroY = 0; SumZeroZ = 0;
    long double SumNorm = 0;
    long double NormMax = 0;
    int iMax = 0;
    long double FXmax, FYmax, FZmax;
    long double NVectorXmax, NVectorYmax, NVectorZmax,NVectorLenmax;
    long double Xtmax,Ytmax,Ztmax;
    for (i = 0; i < iTotalCheckPoints; i++)
    {
        Height =MinH;
        DHeight = (MaxH - MinH)/dk;

        for( k= 0; k < dk; k++, Height+=DHeight)
        {
            // calculation of the forces from Legender Poly model
            ForceDD = GM_MODEL / (Height*Height);
            Xt = Height*TotalCheckPoints[i][0];
            Yt = Height*TotalCheckPoints[i][1];
            Zt = Height*TotalCheckPoints[i][2];
            CalcForcesPoly(Sat, TotalCheckPoints[i][0], TotalCheckPoints[i][1], TotalCheckPoints[i][2], Height,
                    FX,FY,FZ,    iDoList, nDoList, iSkipList,nSkipList);
            // now needs to minus all forces from previous Mass Points
            MinusPointForces(FX, FY, FZ, Xt, Yt, Zt, imp, imp_skip);
            // normal of the FORCE vector
            Norm = sqrt(FX*FX + FY*FY + FZ*FZ);
            Xn = FX/Norm;   Yn = FY/Norm;      Zn = FZ/Norm;

            // get center of mass point of the all prev Mass Points 
            NVectorX = Xt;// - CenterOfMAssX;
            NVectorY = Yt;// - CenterOfMAssY;
            NVectorZ = Zt;// - CenterOfMAssZ;
            NVectorLen = sqrt(NVectorX*NVectorX + NVectorY*NVectorY + NVectorZ*NVectorZ);
            NVectorX /= NVectorLen; NVectorY /= NVectorLen; NVectorZ /= NVectorLen;
#if 0
            if (NormMax < Norm)
            {
                iMax = i;
                NormMax = Norm;
                FXmax = FX; FYmax = FY; FZmax = FZ;
                NVectorXmax = NVectorX; NVectorYmax=NVectorY; NVectorZmax=NVectorZ;
                NVectorLenmax = NVectorLen;
                Xtmax=Xt; Ytmax=Yt; Ztmax=Zt;
            }
#else

            // angle
            Angl = AngleBtwNorm(NVectorX,NVectorY,NVectorZ,Xn,Yn,Zn);

            // probable point
            FindPosWinMinError(NormZero, Norm, Angl, NVectorLen, 0.00001,
                            Xt, Yt, Zt, Xn, Yn, Zn,
                            iDoList, nDoList, iTotalCheckPoints, Sat, iSkipList, nSkipList, imp, imp_skip, imp_set);
            
            NormZero = NVectorLen * cos(Angl);
            ZeroX = Xt -NormZero *Xn;
            ZeroY = Yt -NormZero *Yn;
            ZeroZ = Zt -NormZero *Zn;


            MassPoints[imp_set].Mp = Norm * NormZero*NormZero / GM_MODEL;
            MassPoints[imp_set].X = ZeroX; MassPoints[imp_set].Y = ZeroY; MassPoints[imp_set].Z = ZeroZ;

            // calc medium val
            SumZeroX +=ZeroX*MassPoints[imp_set].Mp; SumZeroY +=ZeroY*MassPoints[imp_set].Mp; SumZeroZ +=ZeroZ*MassPoints[imp_set].Mp;
            SumNorm += MassPoints[imp_set].Mp;
#endif
        }
    }
#if 0
    Xn = FXmax/NormMax;
    Yn = FYmax/NormMax;
    Zn = FZmax/NormMax;
    Angl = AngleBtwNorm(NVectorXmax,NVectorYmax,NVectorZmax,Xn,Yn,Zn);
    NormZero = NVectorLenmax * cos(Angl);
    ZeroX = -NVectorLenmax *Xn;
    ZeroY = -NVectorLenmax *Yn;
    ZeroZ = -NVectorLenmax *Zn;
    ZeroX +=Xtmax;
    ZeroY +=Ytmax;
    ZeroZ +=Ztmax;
    SumZeroX = ZeroX; SumZeroY = ZeroY; SumZeroZ = ZeroZ;
#else
    SumZeroX /= iTotalCheckPoints *dk*SumNorm;
    SumZeroY /= iTotalCheckPoints *dk*SumNorm;
    SumZeroZ /= iTotalCheckPoints *dk*SumNorm;
#endif
    
    for(i = 0; i < imp; i++)
    {
        StoreMass[i] = MassPoints[i].Mp;
    }
    
    MassPoints[imp_set].X = SumZeroX; MassPoints[imp_set].Y = SumZeroY; MassPoints[imp_set].Z = SumZeroZ;
    // second run to find the mass
    
    MassPoints[imp_set].Mp = 0;
    
    ErrorMain1 = Functional( Sat, iTotalCheckPoints, dk, iDoList, nDoList,iSkipList, nSkipList, imp+1, imp_skip);
    long double ErrorMain2;
    Step = -0.1;
    MassPoints[imp_set].Mp = Step;
    ErrorMain2 = Functional(Sat, iTotalCheckPoints, dk, iDoList, nDoList,iSkipList, nSkipList, imp+1, imp_skip);
    
    while (1)
    {
        if (fabs(ErrorMain1 - ErrorMain2) <1e-17)
        {
            if (ErrorMain1 >= ErrorMain2)
                break;
            else
            {
                MassPoints[imp_set].Mp -=Step;
                break;
            }
        }

        if (ErrorMain2 < ErrorMain1)
        {
            // contine steps
            ErrorMain1 = ErrorMain2;
        }
        else
        {
            // step reverce direction and make step twice smaller
            ErrorMain1 = ErrorMain2;

            Step = -Step/2;
            if (fabs(Step) < 1e-17)
                break;
        }
        MassPoints[imp_set].Mp += Step;
        ErrorMain2 = Functional(Sat, iTotalCheckPoints, dk, iDoList, nDoList,iSkipList, nSkipList, imp+1, imp_skip);
    }
    if (imp<=1)
        return;

    // some how point found 
    // now optimization:
    // 1.generate 10 random vectors (each with dimention 4 * [number of points]
    // 2.calulates 10 functionals on all this vectors
    // 3. calc summ_vector with Weight == MAX_val_functional - functional + 1 that is a vector with more probable direction
    // 4 generate 10 random vectors + summ_vector
    // 5. calulate 10 functionals on all this vectors
    // 6. calc (0.25*old_summ_vector + 0.75*summ_vector) (0.25 & 0.75 are params)
    // 7. loop to pp 4
    MASS_POINT_ELEMENT MassPointsI[(TOTAL_COEF+3)*(TOTAL_COEF+3)];
    MASS_POINT_ELEMENT MassPointsSumm[(TOTAL_COEF+3)*(TOTAL_COEF+3)];
    MASS_POINT_ELEMENT MassPointsV[10][(TOTAL_COEF+3)*(TOTAL_COEF+3)];
    long double FunctionalVal[10];
    long double FunctionalValOld[10];
    long double StepM = 0.1; // for mass initial step is 0.1
    long double StepXYZ = 10.0; // for position initial step is 10m
    for (j = 0; j < 10; j++)
    {
        FunctionalValOld[j] = 0.0;
    }
    for (i = 0; i < imp+1; i++)
    {
        MassPointsI[i].X = MassPoints[i].X;  MassPointsI[i].Y = MassPoints[i].Y;  MassPointsI[i].Z = MassPoints[i].Z;  MassPointsI[i].Mp = MassPoints[i].Mp;
        MassPointsSumm[i].X =0;  MassPointsSumm[i].Y =0;  MassPointsSumm[i].Z =0;  MassPointsSumm[i].Mp =0;
    }
    long double MIN_PrevFunc = 10e+50;
    long int CountContinue = 1000;
    long double stepxyz = StepXYZ;
    while(1)
    {
        long double MAX_val_functional = 0;
        int jmax =0;
        long double AllVal = 0;

        long double MIN_val_functional = 10e+50;
        int jmin =0;
    
        for (j = 0; j < 10; j++)
        {
            for (i = 0; i < imp+1; i++)
            {
                GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                MassPointsV[j][i].X *= stepxyz;  MassPointsV[j][i].Y *= stepxyz;  MassPointsV[j][i].Z *= stepxyz;
                MassPoints[i].X = MassPointsI[i].X + 0.5*MassPointsSumm[i].X + 0.5*MassPointsV[j][i].X;
                MassPoints[i].Y = MassPointsI[i].Y + 0.5*MassPointsSumm[i].Y + 0.5*MassPointsV[j][i].Y;
                MassPoints[i].Z = MassPointsI[i].Z + 0.5*MassPointsSumm[i].Z + 0.5*MassPointsV[j][i].Z;
                MassPointsV[j][i].Mp = StepM * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                MassPoints[i].Mp = MassPointsI[i].Mp + 0.5*MassPointsSumm[i].Mp + 0.5*MassPointsV[j][i].Mp;
                //if (i == 0)
                //    MassPoints[i].Mp = 1;
                //while (MassPoints[i].Mp > 1) /////?????
                //{
                //    MassPointsV[j][i].Mp = StepM * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                //    MassPoints[i].Mp = MassPointsI[i].Mp + 0.5*MassPointsSumm[i].Mp + 0.5*MassPointsV[j][i].Mp;
                //}
            }
            NormMassPoints(imp, StepM, j, MassPointsI, MassPointsSumm, MassPointsV);
            FunctionalVal[j] = Functional(Sat, iTotalCheckPoints, dk, iDoList, nDoList,iSkipList, nSkipList, imp+1, imp_skip);
            if (MAX_val_functional < FunctionalVal[j])
            {
                MAX_val_functional = FunctionalVal[j];
                jmax = j;
            }
            if (MIN_val_functional >= FunctionalVal[j])
            {
                MIN_val_functional = FunctionalVal[j];
                jmin = j;
            }
        }
        if (MIN_val_functional < MIN_PrevFunc)
        {
            MIN_PrevFunc = MIN_val_functional;
            CountContinue = 1000;
            stepxyz = StepXYZ;
        }
        else // tried values are bigger then prev one
        {
            if (--CountContinue <0)
            {
                CountContinue = 1000;
                stepxyz *= 2.0;
            }
            continue;
        }
        // set minimum of the functional
        for (i = 0; i <  imp+1; i++)
        {
            MassPointsI[i].X =  + 0.5*MassPointsSumm[i].X + 0.5*MassPointsV[jmin][i].X;
            MassPointsI[i].Y = MassPointsI[i].Y + 0.5*MassPointsSumm[i].Y + 0.5*MassPointsV[jmin][i].Y;
            MassPointsI[i].Z = MassPointsI[i].Z + 0.5*MassPointsSumm[i].Z + 0.5*MassPointsV[jmin][i].Z;
            //if ( i == 0)
            //    MassPointsI[i].Mp = 1;
            //else
                MassPointsI[i].Mp = MassPointsI[i].Mp + 0.5*MassPointsSumm[i].Mp + 0.5*MassPointsV[jmin][i].Mp;
        }

        MAX_val_functional *= 1.0;
        long double MIN_coef = MAX_val_functional - FunctionalVal[jmin];
        // get preferable vector
        for (j = 0; j < 10; j++)
        {
            FunctionalVal[j] = (MAX_val_functional - FunctionalVal[j])/MIN_coef;///(MAX_val_functional/1.1);
            AllVal += 0.5*FunctionalValOld[j]+0.5*FunctionalVal[j];
            for (i = 0; i < imp+1; i++)
            {
                MassPointsSumm[i].X = 0.5*MassPointsSumm[i].X*FunctionalValOld[j] + 0.5* MassPointsV[j][i].X*FunctionalVal[j];
                MassPointsSumm[i].Y = 0.5*MassPointsSumm[i].Y*FunctionalValOld[j] + 0.5* MassPointsV[j][i].Y*FunctionalVal[j];
                MassPointsSumm[i].Z = 0.5*MassPointsSumm[i].Z*FunctionalValOld[j] + 0.5* MassPointsV[j][i].Z*FunctionalVal[j];
                MassPointsSumm[i].Mp = 0.5*MassPointsSumm[i].Mp*FunctionalValOld[j] + 0.5* MassPointsV[j][i].Mp*FunctionalVal[j];
            }
        }
        // set preferable vector
        for (i = 0; i <  imp+1; i++)
        {
            MassPointsSumm[i].X /= 10 * AllVal; MassPointsSumm[i].Y /= 10 * AllVal; MassPointsSumm[i].Z /= 10 * AllVal; MassPointsSumm[i].Mp /= 10 * AllVal;
        }
        
        for(j = 0; j < 10; j++)
        {
            FunctionalValOld[j] = FunctionalVal[j];
        }
    }

}
void MassPointGen(TRAOBJ *SlS, TRAOBJ *Sat,TRAIMPLOBJ *Eng, long double ldFrom,long double ldFromTLEEpoch, long long iAllSec, int iItPerS, long double tSl)
{
    int i;
    int k;
    char szLine[1024];
    int iSkipList[10][4];
    int nSkipList = 0;
    int iTotalCheckPoints;
    int iDoList[10][4];
    int nDoList;
    FILE * CheckPointsFile = fopen(MidRandPointsFile, "r");
    if (CheckPointsFile)
    {
        memset(szLine, 0, sizeof(szLine));
        fgets(szLine,sizeof(szLine), CheckPointsFile);
        iTotalCheckPoints = atoi(szLine);
        if (iTotalCheckPoints > MAX_CHECK_POINTS)
        {
            printf("\n error == MAX_CHECK_POINTS");
            exit(-7);
        }

        for (i = 0; i < iTotalCheckPoints; i++)
        {
            memset(szLine, 0, sizeof(szLine));
            fgets(szLine,sizeof(szLine), CheckPointsFile);
            TotalCheckPoints[i][0] = atof(szLine);
            TotalCheckPoints[i][1] = atof(&szLine[26]);
            TotalCheckPoints[i][2] = atof(&szLine[52]);
        }
        fclose(CheckPointsFile);
    }
    else
    {
        CheckPointsFile = fopen(MidRandPointsFile, "w");
        if (CheckPointsFile)
        {
            for (i = 0; i < MAX_CHECK_POINTS; i++)
            {
                GetRandomNVector(TotalCheckPoints[i][0], TotalCheckPoints[i][1], TotalCheckPoints[i][2]);
            }
            fprintf(CheckPointsFile, "%d\n",MAX_CHECK_POINTS);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double) 0.0,(long double) 0.0,(long double) 1.0);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double) 0.0,(long double) 1.0,(long double) 0.0);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double) 1.0,(long double) 0.0,(long double) 0.0);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double)-1.0,(long double) 0.0,(long double) 0.0);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double) 0.0,(long double)-1.0,(long double) 0.0);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double) 0.0,(long double) 0.0,(long double)-1.0);
            for (i = 0; i < MAX_CHECK_POINTS-6; i++)
            {
                fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n", TotalCheckPoints[i][0], TotalCheckPoints[i][1], TotalCheckPoints[i][2]);
            }
            fclose(CheckPointsFile);
        } 
        return;
    }
    MinH += EarthR;
    MaxH += EarthR;
    Sat->precEps =0;
    Sat->precTet =0;
    Sat->precZ =0;
    Sat->nutEpsilon =0;
    Sat->nutDFeta = 0;
    Sat->Lambda = 0;
    int dk = 1;
    long double MassPer;
    long double SumZeroX, SumZeroY, SumZeroZ;
    long double Gerror, step;
    int imp = 0;
    iDoList[0][0] =2; iDoList[0][1] =2;iDoList[0][2] =0;iDoList[0][3] =0;
    nDoList  =1;
    GetOneMassPoint( Gerror, step,iDoList, nDoList, dk,iTotalCheckPoints, Sat, iSkipList, nSkipList, imp,-1, imp);
    printf("\n%03d p=%10f %10f %10f m= %10f e= %f", imp, MassPoints[imp].X, MassPoints[imp].Y, MassPoints[imp].Z, MassPoints[imp].Mp, Gerror);

    imp++;
    GetOneMassPoint( Gerror, step, iDoList, nDoList, dk,iTotalCheckPoints, Sat, iSkipList, nSkipList, imp,-1,imp);
    printf("\n%03d p=%10f %10f %10f m= %10f e= %f", imp, MassPoints[imp].X, MassPoints[imp].Y, MassPoints[imp].Z, MassPoints[imp].Mp, Gerror);

    imp++;
    GetOneMassPoint( Gerror, step, iDoList, nDoList, dk,iTotalCheckPoints, Sat, iSkipList, nSkipList, imp,-1,imp);
    printf("\n%03d p=%10f %10f %10f m= %10f e= %f", 0, MassPoints[0].X, MassPoints[0].Y, MassPoints[0].Z, MassPoints[0].Mp, Gerror);
    printf("\n%03d p=%10f %10f %10f m= %10f e= %f", 1, MassPoints[1].X, MassPoints[1].Y, MassPoints[1].Z, MassPoints[1].Mp, Gerror);
    printf("\n%03d p=%10f %10f %10f m= %10f e= %f", imp, MassPoints[imp].X, MassPoints[imp].Y, MassPoints[imp].Z, MassPoints[imp].Mp, Gerror);
}
int main(int argc, char * argv[])
{
    int iDay;
    int iFlag = 0;
    int flFindMax;
    int flFindMin;
    int OptimMin = 1;

    stateType  StateEarth;
    stateType  StateMoon;
    
    double minDeltaMinMaxD;
    double maxDeltaMinMaxD;
    long iCountMin;

    double dErrorValue = 1000000.0;
    int iApog = 0;
    double Apog = 0.0;
    int iPerig = 0;
    double Perig = 0.0;
    double PerigMoon = 100000000000.0;
    double ApogPergTime = 0;
    double dRE;
    double dRM;
    double dRM0;
    int idRM = 0;
    double dRM1 =0;
    double dRM2 = 0;
    double dRMDelta = 1.0;
    int idRMDelta = 0;
    int StartSequence = 0;
    double dREMV;
    double SCH_Per = 10000000000000.0;
    double SCH_Apg = 0.0;
    double SCH_Dist = 0.0;
    int iSCH_Apg = 0;
    int iSCH_Per = 0;
    int SCH_ApgPerTime = 0;
    

#define MAXTRYANGLESDIR 6
    //double FindMin;
    int iFindMin;
    //double newTryAnglesDirDelta;

    int iFirstAngleDone = 0;
    int iMaxTryAnglesDir = MAXTRYANGLESDIR;
    int iTryAnglesDir = 0;
    double TryAnglesDirDelta = 0.25;
    double TryAnglesDir[MAXTRYANGLESDIR+1][3] = {0,0,0, 0,0,1, 0,0,-1, 0,1,0, 0,-1,0, 1,0,0, -1,0,0}; 
    double TryAnglesDirValues[MAXTRYANGLESDIR+1];
    double LastStepTryAnglesDirValuesX;
    double LastStepTryAnglesDirValuesY;
    //double LastStepTryAnglesDirValuesZ;
#define LASTSTEPHIST 10
    //int iLastStepHist;
    double LastStepHistX[LASTSTEPHIST];
    double LastStepHistY[LASTSTEPHIST];
    double LastStepHistZ[LASTSTEPHIST];
    TRAOBJ MyTry = SolarSystem;
    TRAOBJ MyTrySat = Sat;
    //TRAIMPLOBJ MyEngine[MAX_ENGINES];

	long double tProbTSec,tProbEcc,tProbIncl,tProbAscNode,tProbArgPer,tProbMeanAnom;
	long double tX,tY,tZ,tVX,tVY,tVZ;
    long double Time_SecondsFromStart=0;
    double ttProbX,ttProbY,ttProbZ,ttProbVX,ttProbVY,ttProbVZ;
    double tttX,tttVX;
    char szXMLFileName[3*_MAX_PATH] = {"tra.xml"};

    //InitTraMap(&CurTraMap);
    Sat.Elem = 0;  // zero asatelites at the begining
    Initialize_Ephemeris(BINARY_EP_NAME);
    printf("\nInitialize_Ephemeris=%s",BINARY_EP_NAME);
    if (argc == 2)
    {
        if (argv[1][1] == '?')
        {
            printf("\n TRA.EXE trajectory calculation software. Adobri Solutions LTD. Team Plan B");
            printf("\n licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.");
            printf("\n");
            printf("\n USAGE:");
            printf("\n  TRA.EXE  -?          - help");
            printf("\n  TRA.EXE              - process TRA.XML file");
            printf("\n  TRA.EXE <FILE NAME>  - process <FILE NAME>");
            printf("\n  TRA.EXE <URL> - process <URL> file");
            exit (0);
        }
        else
        {
            strcpy(szXMLFileName,argv[1]);
        }
    }

    if (strstr(szXMLFileName,"http://"))
    {
        // needs to copy original http file from server to a local with temporary name, than process temporary
        char szURLFileName[3*_MAX_PATH];
        char szURLServer[3*_MAX_PATH];
        char sztempFileName[3*_MAX_PATH];
        char szWebServerResp[8096];
        int UrlPort=80;
       	CHttpConnection* m_MainHttpServer = NULL;
    	CInternetSession  *m_MainInternetConnection = NULL;

        if (ParsURL(szURLServer, &UrlPort, szURLFileName, szXMLFileName))
        {
            strcpy(szXMLFileName, "@tra.xml");
        }
        AfxSocketInit();
        if (m_MainHttpServer == NULL)
	    {
		    m_MainInternetConnection = new CInternetSession("SessionToControlServer",12,INTERNET_OPEN_TYPE_DIRECT,NULL, // proxi name
				            NULL, // proxi bypass
				            INTERNET_FLAG_DONT_CACHE|INTERNET_FLAG_TRANSFER_BINARY);
		    try
		    {
			    m_MainHttpServer = 	m_MainInternetConnection->GetHttpConnection( szURLServer, 0, UrlPort, NULL, NULL );
    		}
	    	catch(CInternetException *e)
		    {
			    m_MainHttpServer = NULL;
		    }
	    }
	    if (m_MainHttpServer)
	    {
			CHttpFile* myCHttpFile = NULL;
			try
			{
				myCHttpFile = m_MainHttpServer->OpenRequest( CHttpConnection::HTTP_VERB_GET,
					szURLFileName,
					NULL,//((CGrStnApp*)AfxGetApp())->szLoginRQ,
					NULL,//12345678,
					NULL, 
					NULL, 
					INTERNET_FLAG_EXISTING_CONNECT|
					INTERNET_FLAG_DONT_CACHE|
					INTERNET_FLAG_RELOAD );
			}
			catch(CInternetException *e)
			{
				myCHttpFile = NULL;
			}

			if (myCHttpFile !=NULL)
			{
				try
				{
					myCHttpFile->SendRequest();
					memset(szWebServerResp, 0, sizeof(szWebServerResp));
					{
						DWORD dwSize;
						CString strSize;
						myCHttpFile->QueryInfo(HTTP_QUERY_CONTENT_LENGTH,strSize);
						dwSize = atoi(strSize.GetString());
                        FILE *TempFile = fopen(szXMLFileName, "wb");
                        if (TempFile)
                        {
						    if (dwSize > (sizeof(szWebServerResp)-1))
						    {
							    for (DWORD dwread=0; dwread < dwSize; dwread+= (sizeof(szWebServerResp)-1))
							    {
								    if ((dwSize - dwread) > (sizeof(szWebServerResp)-1))
                                    {
									    if (myCHttpFile->Read(&szWebServerResp,(sizeof(szWebServerResp)-1)))
                                        {
                                            fwrite(&szWebServerResp,(sizeof(szWebServerResp)-1),1,TempFile);
                                        }
                                    }
								    else
                                    {
									    if (myCHttpFile->Read(&szWebServerResp,(dwSize - dwread)))
                                        {
                                            fwrite(&szWebServerResp,(dwSize - dwread),1,TempFile);
                                        }
                                    }
							    }
						    }
						    else
                            {
							    if (myCHttpFile->Read(&szWebServerResp,dwSize))
                                {
                                    fwrite(&szWebServerResp,dwSize,1,TempFile);
                                }
                            }
                            fclose(TempFile);
                        }
					}
				}
				catch(CInternetException *e)
				{
					//ptrApp->m_MainHttpServer = NULL;
				}
				myCHttpFile->Close();
				delete myCHttpFile;
			}
            m_MainHttpServer->Close();
            m_MainInternetConnection->Close();
		}
	}
    FILE *fInput = fopen(szXMLFileName, "r");
    if (fInput != NULL)
    {
        ParamDoAll(fInput);
        fclose(fInput);
    }
    else
    {
        printf("\n file %s missing", szXMLFileName);
        exit(1);
    }
	{
        Interpolate_State( dStartJD , 2 , &StateEarth );
        StartSequence = 0;
        iDay = 0;
        printf("\n iterations per sec = %d", iItearationsPerSec);

#ifdef CALC_SOLAR_SYSTEM
//#define FIND_SPEED_BASED_ON_BC 1
        EarthX = SolarSystem.X[EARTH];
        EarthY = SolarSystem.Y[EARTH];
        EarthZ = SolarSystem.Z[EARTH];

        MoonX = SolarSystem.X[MOON];
        MoonY = SolarSystem.Y[MOON];
        MoonZ = SolarSystem.Z[MOON];
#endif
        printf("\nStart: Earth position: \nx=%f y=%f z=%f  \nMoon position:\nx=%f y=%f z= %f\n Sat position\nx=%f y=%f z= %f\n(run for %ld sec)", 
                 EarthX, 
                 EarthY, 
                 EarthZ,                  
            MoonX - EarthX, MoonY - EarthY, MoonZ - EarthZ, 
            Sat.X[0] - EarthX, Sat.Y[0] - EarthY, Sat.Z[0] - EarthZ, iTotalSec);
        
        double tDeltaEarthN = (( EarthX - StateEarth.Position[0]*1000.0)*( EarthX - StateEarth.Position[0]*1000.0) +
                                             ( EarthY - StateEarth.Position[1]*1000.0)*( EarthY - StateEarth.Position[1]*1000.0) +
                                             ( EarthZ - StateEarth.Position[2]*1000.0)*( EarthZ - StateEarth.Position[2]*1000.0)
                                            );
        printf("\nJPL EPHEMERIDES Earth-Moon Baricenter \nx=%f y=%f z=%f ", 
            StateEarth.Position[0]*1000.0, 
            StateEarth.Position[1]*1000.0, 
            StateEarth.Position[2]*1000.0);
         SYSTEMTIME ThatTime;
        dStartTLEEpoch = ConvertJulianDayToDateAndTime(dStartJD, &ThatTime);

        if (memcmp(Mode,"PROP",4)==0)
        {
            RunProp(&SolarSystem,&Sat,&Engine[0], dStartJD,dStartTLEEpoch, iTotalSec, iItearationsPerSec, TimeSl);
        }
        else if (memcmp(Mode,"SIM",4)==0)
        {
            RunSim(&SolarSystem,&Sat,&Engine[0], dStartJD,dStartTLEEpoch, iTotalSec, iItearationsPerSec, TimeSl);
        }
        else if (memcmp(Mode,"CALC",4)==0)
        {
            RunCalc(&SolarSystem,&Sat,&Engine[0], dStartJD,dStartTLEEpoch, iTotalSec, iItearationsPerSec, TimeSl);
        }
        else if (memcmp(Mode,"OPTIM",5)==0)
        {
        }
        else if (memcmp(Mode,"MASSPOINTS",10)==0)
        {
            MassPointGen(&SolarSystem,&Sat,&Engine[0], dStartJD,dStartTLEEpoch, iTotalSec, iItearationsPerSec, TimeSl);
        }
	}
    if (CpuCore)
    {
        Sat.StopThreads();
    }
	return 0;
}

