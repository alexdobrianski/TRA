/***********************************************************************
     
    2009-2015 (C) Alex Dobrianski tra.cpp oprbit calculation app

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>
************************************************************************/

#define _CRT_SECURE_NO_WARNINGS 1
//#define _WIN32_WINNT 0x05010000

#include "stdafx.h"
#include <afxinet.h>
#include <afxsock.h>

#define _USE_MATH_DEFINES 1
#include <math.h>
#include <stdio.h>
#include <malloc.h>
#include "ephem_read.h"

#define USE_GLOBAL

#include "procXML.h"
#include "tra.h"

//////////////////////////////////////////////////////////////////////////////
//   predefine vaiable to build different flavor
//#define FIND_IMPULSE_TIME 1
//////////////////////////////////////////////////////////////////////////////

#ifdef _DO_VISUALIZATION
#include "JPEGLIB.H"
void write_JPEG_file (char * filename, int quality, int SizeW, int SizeH, int SizeB, unsigned char *bArray, J_COLOR_SPACE ColorCode);
#endif

#define _NORMALIZED_COEF 1

#define MAX_COEF_J 18



MASS_POINT_ELEMENT MassPoints[(TOTAL_COEF+3)*(TOTAL_COEF+3)];
#define MAX_CHECK_POINTS 1000
long double TotalCheckPoints[MAX_CHECK_POINTS][3];

  	
    // see http://vadimchazov.narod.ru/lepa_zov/lesat.pdf
    // P0 == P[0](x) = 1
    // P1 == P[1](x) = x
    // PN == P[N+1](x) = (x*P[N](x)*(2*n+1) - n*P[N-1](x))/(n+1)
    // sample:
    // P2(x) == P[2](x) = 1/2 *(-1+3*x*x)
    // P3(x) == P[3](x) = 1/2 *(-3*x+5*x*x*x)
    // PNK(x) = pow((1-x*x),k/2)* dK(PN(x)/dxK
    // = pow((1-x*x),k/2)* dK((x*P[N](x)*(2*n+1) - n*P[N-1](x))/(n+1))/dxK
    // P21(x) = 3*x*sqrt(1-x*x)
    // P22(x) = 3*(1-x*x)
    // P31(x) = 3/2*(-1+5*x*x)*sqrt(1-x*x)
    // P32(x) = 15*x*(1-x*x)
    // P33(x) = 15*x*pow((1-x*x),3/2)
    // P41(x) = 5/2*(-3*x+7*x*x*x*)*sqrt(1-x*x)
    // P42(x) = 15/2*(-1+7*x*x*)*sqrt(1-x*x)
	// JN = -sqrt(2*n+1) Cl0 from Table D.3
    // CNK = sqrt(2*(2*n+1)) * sqrt(((n-k)!/(n+k)!) * Clm
    // SNK = sqrt(2*(2*n+1) * sqrt((n-k)!/(n+k)!)) * Slm
    // but coeffs from http://www.csr.utexas.edu/publications/statod/TabD.3.new.txt
    // just needs to copy it
	// FM/r * 
	//( 1 
    //	- J2 * (r0/r)**2 * P2(sinPHI)  
    //	- J3 * (r0/r)**3 * P3(sinPHI) 
    //  - J4 * (r0/r)**4 * P4(sinPHI)
    //  - J5 * (r0/r)**5 * P5(sinPHI)
    //  - J6 * (r0/r)**6 * P6(sinPHI)
    //  - J7 * (r0/r)**7 * P7(sinPHI)
    //  - J8 * (r0/r)**8 * P8(sinPHI)
    //  + SUM2=( (r0/r)**2 * P21(sinPHI) * (C21 * cos(1*Lambda) + S21*sin(1*Lanbda)) +
    //           (r0/r)**2 * P22(sinPhi) * (C22 *cos(2*Lambda) + S22*sin(2*Lambda))     )
    //    SUM3=( (r0/r)**3 *P31(sinPHI) * (C31 * cos(1*Lambda) + S31*sin(1*Lambda)) +
    //           (r0/r)**3 *P32(sinPHI) * (C32 * cos(2*Lambda) + S32*sin(2*Lambda)) +
    //           (r0/r)**3 *P33(sinPHI) * (C33 * cos(3*Lambda) + S33*sin(3*Lambda))      )
    //  SUM4= ( (r0/r)**4 *P41(sinPHI) * (C41 * cos(1*Lambda) + S41*sin(1*Lambda)) +
    //          (r0/r)**4 *P42(sinPHI) * (C42 * cos(2*Lambda) + S42*sin(2*Lambda)) +
    //          (r0/r)**4 *P43(sinPHI) * (C43 * cos(3*Lambda) + S43*sin(3*Lambda)) +
    //          (r0/r)**4 *P44(sinPHI) * (C44 * cos(4*Lambda) + S44*sin(3*Lambda))     )
    //  SUM5= ( (r0/r)**5 *P51(sinPHI) * (C51 * cos(1*Lambda) + S51*sin(1*Lambda)) +
    //          (r0/r)**5 *P52(sinPHI) * (C52 * cos(2*Lambda) + S52*sin(2*Lambda)) +
    //          (r0/r)**5 *P53(sinPHI) * (C53 * cos(3*Lambda) + S53*sin(3*Lambda)) +
    //          (r0/r)**5 *P54(sinPHI) * (C54 * cos(4*Lambda) + S54*sin(4*Lambda)) +
    //          (r0/r)**5 *P55(sinPHI) * (C55 * cos(5*Lambda) + S55*sin(5*Lambda))         )
    //  SUM6= ( (r0/r)**6 *P61(sinPHI) * (C61 * cos(1*Lambda) + S61*sin(1*Lambda)) +
    //          (r0/r)**6 *P62(sinPHI) * (C62 * cos(2*Lambda) + S62*sin(2*Lambda)) +
    //          (r0/r)**6 *P63(sinPHI) * (C63 * cos(3*Lambda) + S63*sin(3*Lambda)) +
    //          (r0/r)**6 *P64(sinPHI) * (C64 * cos(4*Lambda) + S64*sin(4*Lambda)) +
    //          (r0/r)**6 *P65(sinPHI) * (C65 * cos(5*Lambda) + S65*sin(5*Lambda)) +
    //          (r0/r)**6 *P66(sinPHI) * (C66 * cos(6*Lambda) + S66*sin(6*Lambda))         )
    //  SUM7= ( (r0/r)**7 *P71(sinPHI) * (C71 * cos(1*Lambda) + S71*sin(1*Lambda)) +
    //          (r0/r)**7 *P72(sinPHI) * (C72 * cos(2*Lambda) + S72*sin(2*Lambda)) +
    //          (r0/r)**7 *P73(sinPHI) * (C73 * cos(3*Lambda) + S73*sin(3*Lambda)) +
    //          (r0/r)**7 *P74(sinPHI) * (C74 * cos(4*Lambda) + S74*sin(4*Lambda)) +
    //          (r0/r)**7 *P75(sinPHI) * (C75 * cos(5*Lambda) + S75*sin(5*Lambda)) +
    //          (r0/r)**7 *P76(sinPHI) * (C76 * cos(6*Lambda) + S76*sin(6*Lambda)) +
    //          (r0/r)**7 *P76(sinPHI) * (C77 * cos(7*Lambda) + S77*sin(7*Lambda))        )
    //  SUM8= ( (r0/r)**8 *P81(sinPHI) * (C81 * cos(1*Lambda) + S81*sin(1*Lambda)) +
    //          (r0/r)**8 *P82(sinPHI) * (C82 * cos(2*Lambda) + S82*sin(2*Lambda)) +
    //          (r0/r)**8 *P83(sinPHI) * (C83 * cos(3*Lambda) + S83*sin(3*Lambda)) +
    //          (r0/r)**8 *P84(sinPHI) * (C84 * cos(4*Lambda) + S84*sin(4*Lambda)) +
    //          (r0/r)**8 *P85(sinPHI) * (C85 * cos(5*Lambda) + S85*sin(5*Lambda)) +
    //          (r0/r)**8 *P86(sinPHI) * (C86 * cos(6*Lambda) + S86*sin(6*Lambda)) +
    //          (r0/r)**8 *P87(sinPHI) * (C87 * cos(7*Lambda) + S86*sin(7*Lambda)) +
    //          (r0/r)**8 *P88(sinPHI) * (C88 * cos(8*Lambda) + S86*sin(8*Lambda))         )

    // moon 0.0002027


    long double __CH[2][7] = {            120,         120,         120,          120,         120,         120,         120,  
                                         640,         700,         760,          820,         860,         920,         980};

    long double __CO[2][5][7] = {    -1.04825,    -0.93106,   -0.820867,    -0.744047,   -0.722471,   -0.687482,   -0.739984,
                                    0.0166305,   0.0141537,   0.0119916,    0.0104743,  0.00980317,  0.00916594,  0.00952854,
                                  -9.24263e-5, -7.29862e-5, -5.79835e-5,  -4.78544e-5, -4.25245e-5, -3.80932e-5, -3.62727e-5,
                                   2.72382e-7,  2.00294e-7,  1.50707e-7,   1.18513e-7,  9.95544e-8,  8.51275e-8,   7.3887e-8,
                                 -2.41355e-10,-1.62006e-10,-1.13026e-10, -8.31498e-11,-6.55175e-11,-5.29972e-11,-4.23907e-11,

                                      50.5034,      61.624,     53.2623,      18.2236,    -31.8442,    -48.7208,    -147.859,
                                    -0.170541,   -0.192967,   -0.144342,  -0.00840024,    0.168327,    0.222996,    0.531652,
                                   2.17232e-4,  2.28061e-4,   1.4659e-4,     -3.88e-5, -2.62603e-4, -3.21884e-4,  -671937e-4,
                                  -1.21902e-7, -1.18715e-7, -6.46443e-8,  4.31384e-8,   1.65454e-7,  1.91495e-7,  3.64787e-7,
                                  2.54037e-11, 2.29638e-11, 1.04227e-11,-1.23832e-11, -3.69355e-11,-4.08067e-11,-7.26268e-11};



    long double __NO[2][3][7] = {      2.058,       2.058,       2.058,        2.058,       2.058,       2.058,        2.058,
                                    5.887e-3,    5.887e-3,    5.887e-3,     5.887e-3,    5.887e-3,    5.887e-3,     5.887e-3,
                                   -4.012e-6,   -4.012e-6,   -4.012e-6,    -4.012e-6,   -4.012e-6,   -4.012e-6,    -4.012e-6,

                                       2.058,       2.058,       2.058,        2.058,       2.058,       2.058,        2.058,
                                    5.887e-3,    5.887e-3,    5.887e-3,     5.887e-3,    5.887e-3,    5.887e-3,     5.887e-3,
                                    -4.012e-6,   -4.012e-6,   -4.012e-6,    -4.012e-6,   -4.012e-6,   -4.012e-6,    -4.012e-6};


    long double __FEO[2][1][7] = {     0.5411,     0.5515,      0.5585,       0.5585,      0.5585,      0.5585,       0.5585,
                                       0.5411,     0.5515,      0.5585,       0.5585,      0.5585,      0.5585,       0.5585};

    long double __DH[2][7] = {            120,         120,         120,          120,         120,         120,         120,  
                                         1500,        1500,        1500,         1500,        1500,        1500,        1500};

    long double __DO[2][5][7] =  { -0.351899,   -0.047813,     0.20981,     0.265174,     0.23047,    0.170074,     0.088141,
                                   0.0057056,  0.00380813,  0.00262881,   0.00275836,  0.00338331,  0.00406131,   0.00468253,
                                   9.95819e-7,   4.2271e-6,   4.24379e-6,    2.08668e-6,   -5.52305e-7,-  2.82114e-6,    -4.24609e-6,
                                  -7.25324e-9,  -8.66826e-9, -6.67328e-9,  -3.69543e-9, -8.23607e-10,  1.38369e-9,   2.53509e-9,
                                   2.9759e-12,  3.06712e-12, 2.13496e-12,   1.11862e-12,  2.21349e-13, -4.27908e-13,   -7.29031e-13,   

                                   -0.351899,   -0.047813,     0.20981,     0.265174,     0.23047,    0.170074,     0.088141,
                                  0.00577056,  0.00380813,  0.00262881,   0.00275836,  0.00338331,  0.00406131,   0.00468253,
                                  9.95819e-7,  4.22771e-6,  4.24379e-6,   2.08668e-6, -5.52305e-7, -2.82114e-6,  -4.24609e-6,
                                 -7.25324e-9, -8.66826e-9, -6.67328e-9,  -3.69543e-9,-8.23607e-10,  1.38369e-9,   2.53509e-9,
                                 2.9759e-12, 3.06712e-12, 2.13496e-12,  1.11862e-12, 2.21349e-13,-4.27908e-13, -7.29031e-13};

   long double __EH[2][7] = {            120,         120,         120,          120,         120,         120,         120,  
                                         600,         700,         780,          800,         800,         900,         960};

    long double __EO[2][9][7] =  {  -0.731596,    -0.752175,    -0.570476,     -0.949573,    -0.967598,     -1.02278,-   0.757903,
                                   0.00597345,  0.00565925,  2.95802e-3,   8.13121e-3,  8.41991e-3,  9.23633e-3,   0.00606068,
                                  -5.82037e-6,   1.8082e-6,  1.68896e-5,-   3.87813e-6,    -3.585e-6,  -6.10128e-6,   7.85296e-6,
                                  6.84634e-8,  3.33822e-8,-   4.7475e-9,   2.37694e-8,  1.74801e-8,  1.78211e-8,   -9.74891e-9,
                                 -9.50483e-11, -5.13965e-11, -1.72711e-11,-   2.7469e-11, -1.96221e-11, -1.70073e-11,   1.5837e-12,
                                     -0.20670,-     0.16971,-     0.14671,-      0.13150,-    0.120916,-     0.11363,-      0.10444,
                                   9.7533e-2,   7.9830e-2,   6.8808e-2,    6.1603e-2,   5.6538e-2,   5.3178e-2,    4.8551e-2,
                                   -1.1817e-2,   -9.4393e-3,   7.9836e-3,    -7.0866e-3,-   6.4324e-3,-   6.0436e-3,    -5.3567e-3,
                                   1.6145e-3,   1.2622e-3,   1.0535e-3,    9.2813e-4,   8.3723e-4,   7.7982e-4,    6.8809e-4,

                                     38.6199,      51.249,     68.4746,       58.422,     7.20188,     21.5948,     -88.4076,
                                   -0.132147,   -0.167373, -2.15659e-1,  -1.66664e-1,  2.16109e-2, -2.02239e-2,     0.338518,
                                  1.75411e-4,  2.11832e-4,  2.62273e-4,   1.85486e-4, -6.52882e-5, -1.72029e-5, -0.000445581,
                                 -1.02417e-7, -1.18221e-7, -1.40972e-7, -9.12345e-8,   5.37077e-8,  2.83017e-8,   2.51729e-7,
                                  .21446e-11, 2.45055e-11, 2.82285e-11,  1.67118e-11, -1.4095e-11,-8.94486e-12,   -5.203e-11,
                                    -0.20670,    -0.16971,    -0.14671,     -0.13150,   -0.120916,    -0.11363,     -0.10444,
                                   9.7533e-2,   7.9830e-2,   6.8808e-2,    6.1603e-2,   5.6538e-2,   5.3178e-2,    4.8551e-2,
                                 -1.1817e-2,   -9.4393e-3,  -7.9836e-3,   -7.0866e-3,  -6.4324e-3,  -6.0436e-3,   -5.3567e-3,
                                 1.6145e-3,    1.2622e-3,   1.0535e-3,    9.2813e-4,   8.3723e-4,   7.7982e-4,    6.8809e-4};


   long double __ET[2][4][7] =  {     -0.2061,   -0.169279,      -0.14637,-      0.13121,-     0.12067,    -0.113399,-     0.104243,
                                   9.4449e-2,   7.7599e-2,   6.7052e-2,    6.0105e-2,   5.5232e-2,   5.1994e-2,    4.7573e-2,
                                   -8.7953e-3,  - 7.1375e-3,   -6.0951e-3,    -5.4388e-3,-   4.9580e-3,   -4.6876e-3,    -4.1711e-3,
                                   8.8385e-4,   6.9025e-4,   5.7456e-4,    5.0585e-4,   4.5512e-4,   4.2548e-4,    3.7068e-4,

                                     -0.2061,   -0.169279,   -0.146377,     -0.13121,    -0.12067,   -0.113399,    -0.104243,
                                   9.4449e-2,   7.7599e-2,   6.7052e-2,    6.0105e-2,   5.5232e-2,   5.1994e-2,    4.7573e-2,
                                  -8.7953e-3,  -7.1375e-3,  -6.0951e-3,   -5.4388e-3,  -4.9580e-3,  -4.6876e-3,   -4.1711e-3,
                                  8.8385e-4,   6.9025e-4,   5.7456e-4,    5.0585e-4,   4.5512e-4,   4.2548e-4,    3.7068e-4};


//#define MAX_FLUX_TABLE 365*2
//int iStarting1007JD;
//long double FLUX107[MAX_FLUX_TABLE];
// coefs for smuzining
long double AlternativePoints[360 ][3] ={
-0.0100,0.0100,92,
4.7500,5.2500,49,
9.5000,10.5000,43,
14.0000,16.0000,42,
19.5000,20.5000,39,
24.5000,25.5000,39,
29.0000,31.0000,39,
34.5000,35.5000,38,
39.0000,41.0000,38,
44.0000,46.0000,38,
49.0000,51.0000,38,
54.0000,56.0000,41,
59.5000,60.5000,37,
64.5000,65.5000,37,
69.5000,70.5000,37,
74.0000,76.0000,37,
79.0000,81.0000,37,
84.0000,86.0000,37,
89.0000,91.0000,37,
94.0000,96.0000,37,
99.0000,101.0000,37,
104.0000,106.0000,37,
109.5000,110.5000,37,
114.5000,115.5000,37,
119.5000,120.5000,37,
124.0000,126.0000,41,
129.5000,130.5000,38,
134.0000,136.0000,42,
139.5000,140.5000,38,
144.5000,145.5000,38,
149.0000,151.0000,39,
154.5000,155.5000,39,
159.5000,160.5000,39,
164.0000,166.0000,42,
169.5000,170.5000,43,
174.7500,175.2500,49,
179.9750,180.0250,92,
184.7500,185.2500,49,
189.5000,190.5000,43,
194.0000,196.0000,42,
199.5000,200.5000,39,
204.5000,205.5000,39,
209.0000,211.0000,39,
214.5000,215.5000,38,
219.0000,221.0000,38,
224.0000,226.0000,38,
229.0000,231.0000,38,
234.0000,236.0000,41,
239.5000,240.5000,37,
244.5000,245.5000,37,
249.5000,250.5000,37,
254.0000,256.0000,37,
259.0000,261.0000,37,
264.0000,266.0000,37,
269.0000,271.0000,37,
274.0000,276.0000,37,
279.0000,281.0000,37,
284.0000,286.0000,37,
289.5000,290.5000,37,
294.5000,295.5000,37,
299.5000,300.5000,37,
304.0000,306.0000,41,
309.0000,311.0000,38,
314.0000,316.0000,38,
319.0000,321.0000,38,
324.5000,325.5000,38,
329.0000,331.0000,39,
334.5000,335.5000,39,
339.5000,340.5000,39,
344.0000,346.0000,42,
349.7500,350.2500,42,
354.9750,355.0250,92};




#ifdef USE_MODEL_3
long double ClmNN[MAX_COEF_J][MAX_COEF_J] = {
    //0             1                    2                   3                   4                   5                   6                  7                     8                   9                10                  11                    12                     13               14                    15               16         17
    0.0,                  0.0,-0.484165371736E-03,  0.957254173792E-06, 0.539873863789E-06, 0.685323475630E-07,-0.149957994714E-06, 0.909789371450E-07, 0.496711667324E-07, 0.276714300853E-07, 0.526222488569E-07,-0.509613707522E-07, 0.377252636558E-07, 0.422982206413E-07,-0.242786502921E-07, 0.147910068708E-08,-0.315322986722E-08,0,
	0.0,                  0.0,-0.186987635955E-09,  0.202998882184E-05,-0.536321616971E-06,-0.621012128528E-07,-0.760879384947E-07, 0.279872910488E-06, 0.233422047893E-07, 0.143387502749E-06, 0.835115775652E-07, 0.151687209933E-07,-0.540654977836E-07,-0.513569699124E-07,-0.186968616381E-07, 0.100817268177E-07, 0.258360856231E-07,0,
	0.0,                  0.0, 0.243914352398E-05,  0.904627768605E-06, 0.350694105785E-06, 0.652438297612E-06, 0.481732442832E-07, 0.329743816488E-06, 0.802978722615E-07, 0.222288318564E-07,-0.942413882081E-07, 0.186309749878E-07, 0.142979642253E-07, 0.559217667099E-07,-0.367789379502E-07,-0.213942673775E-07,-0.233671404512E-07,0,
	0.0,                  0.0,                0.0,  0.721072657057E-06, 0.990771803829E-06,-0.451955406071E-06, 0.571730990516E-07, 0.250398657706E-06,-0.191877757009E-07,-0.160811502143E-06,-0.689895048176E-08,-0.309871239854E-07, 0.393995876403E-07,-0.219360927945E-07, 0.358875097333E-07, 0.521392929041E-07,-0.336019429391E-07,0,
    0.0,                  0.0,                0.0,                 0.0,-0.188560802735E-06,-0.295301647654E-06,-0.862142660109E-07,-0.275114355257E-06,-0.244600105471E-06,-0.900179225336E-08,-0.840764549716E-07,-0.389580205051E-07,-0.686908127934E-07,-0.313762599666E-08, 0.183865617792E-08,-0.408150084078E-07, 0.402316284314E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0, 0.174971983203E-06,-0.267133325490E-06, 0.193765507243E-08,-0.255352403037E-07,-0.166165092924E-07,-0.493395938185E-07, 0.377848029452E-07, 0.309411128730E-07, 0.590049394905E-07, 0.287344273542E-07, 0.124935723108E-07,-0.129501939245E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0, 0.967616121092E-08,-0.358856860645E-06,-0.657361610961E-07, 0.626941938248E-07,-0.375885236598E-07,-0.118676592395E-08, 0.341523275208E-08,-0.359038073075E-07,-0.194810485574E-07, 0.331211643896E-07, 0.140239252323E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0, 0.109185148045E-08, 0.672811580072E-07,-0.118366323475E-06, 0.811460540925E-08, 0.411565188074E-08,-0.186909958587E-07, 0.253002147087E-08, 0.375003839415E-07, 0.596210699259E-07,-0.708412635136E-08,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-0.124092493016E-06, 0.188436022794E-06, 0.404927981694E-07,-0.598410841300E-08,-0.253769398865E-07,-0.983150822695E-08,-0.350946485865E-07,-0.322428691498E-07,-0.209018868094E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,-0.477475386132E-07, 0.125491334939E-06,-0.314231072723E-07, 0.422880630662E-07, 0.247325771791E-07, 0.320284939341E-07, 0.128788268085E-07,-0.218588720643E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0, 0.100538634409E-06,-0.521882681927E-07,-0.617619654902E-08, 0.410324653930E-07, 0.390329180008E-07, 0.104688722521E-07,-0.117529900814E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0, 0.460344448746E-07, 0.112502994122E-07,-0.443869677399E-07, 0.153970516502E-07,-0.111675061934E-08, 0.187574042592E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,-0.249532607390E-08,-0.312622200222E-07, 0.840829163869E-08,-0.323962134415E-07, 0.195400194038E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,-0.612759553199E-07, 0.322147043964E-07,-0.283933019117E-07, 0.138196369576E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,-0.518980794309E-07, 0.519168859330E-08,-0.193182168856E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,                  0,-0.190930538322E-07,-0.145149060142E-07,0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,                  0,                  0,-0.379671710746E-07,0
};
long double SlmNN[MAX_COEF_J][MAX_COEF_J] = {       //   3                   4                     5                   6                 7                     8                      9              10                   11                 12                 13                  14                 15
    0.0,                  0.0,                0.0,                0.0,                0.0,               0.0,                 0.0,                0.0,                0.0,                  0,                  0,                  0,                  0,                  0,                  0,                      0,                      0,         0,
    0.0,                  0.0, 0.119528012031E-08, 0.248513158716E-06,-0.473440265853E-06,-0.944226127525E-07, 0.262890545501E-07, 0.954336911867E-07, 0.590060493411E-07, 0.216834947618E-07,-0.131314331796E-06,-0.268604146166E-07,-0.435675748979E-07, 0.390510386685E-07, 0.294747542249E-07, 0.109773066324E-07, 0.325447560859E-07,0,
    0.0,                  0.0,-0.140016683654E-05,-0.619025944205E-06, 0.662671572540E-06,-0.323349612668E-06,-0.373728201347E-06, 0.930667596042E-07, 0.654175425859E-07,-0.322196647116E-07,-0.515791657390E-07,-0.990693862047E-07, 0.320975937619E-07,-0.627337565381E-07,-0.516779392055E-08,-0.308914875777E-07, 0.288799363439E-07,0,
    0.0,                  0.0,                0.0, 0.141435626958E-05,-0.200928369177E-06,-0.214847190624E-06, 0.902694517163E-08,-0.217198608738E-06,-0.863454445021E-07,-0.742287409462E-07,-0.153768828694E-06,-0.148131804260E-06, 0.244264863505E-07, 0.974829362237E-07, 0.204618827833E-07, 0.172892926103E-07,-0.220418988010E-07,0,
    0.0,                  0.0,                0.0,                0.0, 0.308853169333E-06, 0.496658876769E-07,-0.471408154267E-06,-0.123800392323E-06, 0.700233016934E-07, 0.194666779475E-07,-0.792806255331E-07,-0.636666511980E-07, 0.415081109011E-08,-0.119627874492E-07,-0.226780613566E-07, 0.650174707794E-08, 0.483837716909E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,-0.669384278219E-06,-0.536488432483E-06, 0.177377719872E-07, 0.891462164788E-07,-0.541113191483E-07,-0.505370221897E-07, 0.494736238169E-07, 0.782536279033E-08, 0.664975958036E-07,-0.163882249728E-07, 0.808375563996E-08,-0.319458578129E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,-0.237192006935E-06, 0.151789817739E-06, 0.309238461807E-06, 0.222903525945E-06,-0.795667053872E-07, 0.344769584593E-07, 0.391765484449E-07,-0.657280613686E-08, 0.247831272781E-08,-0.368246004304E-07,-0.350760208303E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0, 0.244415707993E-07, 0.747440473633E-07,-0.965152667886E-07,-0.336629641314E-08,-0.898252808977E-07, 0.356131849382E-07,-0.621470822331E-08,-0.417291319429E-08, 0.531841171879E-08,-0.881581561131E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0, 0.120533165603E-06,-0.308566220421E-08,-0.918705975922E-07, 0.243989612237E-07, 0.169361024629E-07,-0.104740222825E-07,-0.153515265203E-07, 0.221523579587E-07, 0.500527390530E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0, 0.966412847714E-07,-0.376516222392E-07, 0.417731829829E-07, 0.252692598301E-07, 0.452870369936E-07, 0.288804922064E-07, 0.375629820829E-07,-0.395012419994E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,-0.240148449520E-07,-0.183364561788E-07, 0.308375794212E-07,-0.368121029480E-07,-0.144308452469E-08, 0.147222147015E-07, 0.114211582961E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,-0.696662308185E-07,-0.637946501558E-08,-0.476507804288E-08,-0.390548173245E-07, 0.180996198432E-07,-0.303161919925E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,-0.111780601900E-07, 0.878405809267E-07,-0.311327189117E-07, 0.155243104746E-07, 0.666983574071E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0, 0.685261488594E-07, 0.451897224960E-07,-0.422066791103E-08, 0.102778499508E-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,-0.481506636748E-08,-0.243752739666E-07,-0.386174893776E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,                  0,-0.471139421558E-08,-0.327443078739E-07,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,-               0.0,                0.0,                0.0,                  0,                  0,                  0,                  0,                  0, 0.302155372655E-08,0,
};
#else
long double ClmNN[MAX_COEF_J][MAX_COEF_J] = { //2                 3                     4                   5                   6                   7                    8                 9                       10              11              12                  13                        14                15              16       17    
    0.0,                  0.0,-4.841692638330e-04,  9.572027902208e-07, 5.399964106071e-07, 6.866574057291e-08,-1.499596204836e-07, 9.050739327092e-08, 4.947735333891e-08,  2.802002397264e-08, 5.332872206339e-08,-5.076684067354e-08, 3.643698716802e-08, 4.173145479803e-08,-2.266932614809e-08, 2.191678708149e-09,-4.711399566556e-09, 0,
	0.0,                  0.0,-2.234662444661e-10,  2.030466388182e-06,-5.361544237902e-07,-6.292428749088e-08,-7.592505797236e-08, 2.808854277322e-07, 2.315575906154e-08,  1.421495778857e-07, 8.376111145897e-08, 1.561187804078e-08,-5.358752398482e-08,-5.144000572708e-08,-1.877109781623e-08, 9.430607665241e-09, 2.618495087563e-08, 0,
	0.0,                  0.0, 2.439350113369e-06,  9.047846524431e-07, 3.504958968385e-07, 6.520778577638e-07, 4.864539750273e-08, 3.304068238591e-07, 8.001179880843e-08,  2.141393810770e-08,-9.399255140566e-08, 2.011423100703e-08, 1.426661258608e-08, 5.530988811097e-08,-3.591920480342e-08,-2.053202027793e-08,-2.451051568312e-08, 0,
	0.0,                  0.0,                0.0,  7.212871882010e-07, 9.908586325033e-07,-4.518537514124e-07, 5.724334935560e-08, 2.504544598798e-07,-1.937186828289e-08, -1.606138778812e-07,-7.005368053537e-09,-3.057925186015e-08, 3.962415995470e-08,-2.155800022081e-08, 3.651607433528e-08, 5.341304630709e-08,-3.391353117356e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,-1.884976309101e-07,-2.953307723280e-07,-8.601639084556e-08,-2.749966205063e-07,-2.443584112320e-07, -9.366026792641e-09,-8.446628400020e-08,-3.795224682616e-08,-6.772572133772e-08,-3.651797523913e-09, 1.602910566428e-09,-4.017381916458e-08, 4.085472497887e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0, 1.748040283338e-07,-2.671694458420e-07, 1.648725941097e-09,-2.570213990017e-08, -1.631147946221e-08,-4.929098071452e-08, 3.742247518693e-08, 3.087560954874e-08, 5.837167041440e-08, 2.930775661205e-08, 1.224207146925e-08,-1.212203260105e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0, 9.475274175687e-09,-3.588026196467e-07,-6.596595299498e-08,  6.278699700289e-08,-3.758514495974e-08,-1.565920036827e-09, 3.132644254277e-09,-3.504446356069e-08,-1.906970629630e-08, 3.285198624026e-08, 1.387384159872e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0, 1.519895064619e-09, 6.725611206683e-08, -1.179836069693e-07, 8.260939438061e-09, 4.654747377856e-09,-1.905168826766e-08, 3.015092155107e-09, 3.763036962799e-08, 5.965511978744e-08,-8.062457398106e-09, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,-1.240322758207e-07,  1.881291318200e-07, 4.059211174828e-08,-6.301356391485e-09,-2.588852721232e-08,-1.005497521179e-08,-3.494137393294e-08,-3.208864903358e-08,-2.120437927688e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0, -4.755484386124e-08, 1.253832700848e-07,-3.107538124489e-08, 4.191770164809e-08, 2.476679196786e-08, 3.195228258282e-08, 1.329848455013e-08,-2.241391484986e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0, 1.004229077541e-07,-5.224977584439e-08,-6.199896784872e-09, 4.110412490315e-08, 3.880182386363e-08, 1.026325953351e-08,-1.180463195465e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0, 4.623389723690e-08, 1.136258459209e-08,-4.452226413314e-08, 1.564625400671e-08,-1.305441830526e-09, 1.911171902867e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,-2.423026558875e-09,-3.131887022807e-08, 8.460976772264e-09,-3.241821298600e-08, 1.956110670862e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,-6.120881679019e-08, 3.224218717741e-08,-2.836870432250e-08, 1.377544553767e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,-5.187076100301e-08, 5.200241654303e-09,-1.934458914407e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                  0,-1.902751314587e-08,-1.441678809455e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                  0,                  0,-3.830521289156e-08, 0,
    0.0,                  0.0,                0.0,                 0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                  0,                  0,                  0, 0
};
long double SlmNN[MAX_COEF_J][MAX_COEF_J] = {
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                   0,                  0,                 0,                   0,                  0,                  0,                    0,                  0, 0,
    0.0,                  0.0, 1.464715526673e-09, 2.482080433653e-07,-4.735680040417e-07,-9.437428640136e-08, 2.651378843389e-08, 9.512586979716e-08, 5.889592314865e-08,  2.140014207954e-08,-1.310928645967e-07,-2.712348064969e-08,-4.316458223037e-08, 3.869034387873e-08,  2.886211920225e-08,  1.048343697123e-08,  3.334313589953e-08,0,
    0.0,                  0.0,-1.400296540441e-06,-6.189942681083e-07, 6.624855562470e-07,-3.233496172587e-07,-3.737920915147e-07, 9.299919715717e-08, 6.528327073129e-08, -3.169859562924e-08,-5.127653720129e-08,-9.899946750685e-08, 3.109064951397e-08,-6.269439481257e-08, -4.054659579019e-09, -3.029929942704e-08,  2.803047576995e-08,0,
    0.0,                  0.0,                0.0, 1.414368208779e-06,-2.009476685481e-07,-2.149561037572e-07, 8.952473451278e-09,-2.171181625992e-07,-8.596235732981e-08, -7.426799091681e-08,-1.541425435369e-07,-1.488361487913e-07, 2.506149544819e-08, 9.768510167924e-08,  1.969199774505e-08,  1.766096915361e-08, -2.133881575508e-08,0,
    0.0,                  0.0,                0.0,                0.0, 3.088135184212e-07, 4.980925678694e-08,-4.714241836895e-07,-1.240577402167e-07, 6.981012693018e-08,  1.990269145001e-08,-7.902664299306e-08,-6.377016394095e-08, 3.839316687212e-09,-1.175070318615e-08, -2.266180766986e-08,  6.811721256429e-09,  4.798864908709e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,-6.693703781765e-07,-5.364945320709e-07, 1.792751666484e-08, 8.920242844714e-08, -5.404158428580e-08,-5.061601820481e-08, 4.959112109226e-08, 7.588579694650e-09, 6.722686386365e-08, -1.679010211399e-08,  7.621491034307e-09, -3.443409814726e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,-2.373889502183e-07, 1.517953939450e-07, 3.089442033489e-07,  2.229637747856e-07,-7.977013211026e-08, 3.427367173521e-08, 3.898098866254e-08,-6.273525421439e-09,  2.456983563782e-09, -3.646985465262e-08, -3.559593322814e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0, 2.410884394887e-08, 7.486559029971e-08, -9.692324514961e-08,-3.046340591979e-09,-8.982781854875e-08, 3.572792342750e-08,-7.323017189905e-09, -3.933698459869e-09,  5.073057805615e-09, -8.651969069085e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0, 1.205465727993e-07, -3.002262507284e-09,-9.171581581980e-08, 2.454773002353e-08, 1.693748226686e-08,-9.857235841573e-09, -1.544686306971e-08,  2.217210257117e-08,  5.406987372004e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,  9.687949185757e-08,-3.794425045512e-08, 4.207091340282e-08, 2.496229497578e-08, 4.589035920265e-08,  2.846426004693e-08,  3.799393471601e-08, -3.966799165656e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,-2.385629426228e-08,-1.841642451641e-08, 3.093427812562e-08,-3.683656180493e-08, -1.297935326294e-09,  1.469238135563e-08,  1.153517812657e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,-6.967357602229e-08,-6.385321730657e-09,-4.841568358339e-09, -3.904229679272e-08,  1.852183740538e-08, -3.202892179004e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,-1.111510144261e-08, 8.793436179258e-08, -3.111925531137e-08,  1.560533743612e-08,  6.727712403290e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0, 6.814363771627e-08,  4.514881135110e-08, -4.577079272453e-09,  1.048199370467e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0, -4.822175650729e-09, -2.439700582238e-08, -3.864568321338e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                   0, -4.690395287240e-09, -3.277186361861e-08,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                   0,                   0,  2.968301836612e-09,0,
    0.0,                  0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                0.0,                 0.0,                0.0,                  0,                  0,                  0,                   0,                   0,                   0,0
};
#endif

#ifdef USE_MODEL_0

long double Clm[MAX_COEF_J][MAX_COEF_J] = {//2                 3                     4                        5                   6                   7                    8             9 10 11 12 13 14 15 16 17           
    0.0,                  0.0, -0.10826360229840e-02,   0.25325160653E-05,   0.16185636000E-05,    0.2266690830E-06,    -0.5390785906e-06,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0,       -0.2194691e-09,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0,    0.15744102040e-05,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0

 };
long double Slm[MAX_COEF_J][MAX_COEF_J] = {
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,      +0.15362834e-08,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,    -0.9037571782e-06,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                    0,                    0,                    0,                    0,                    0,                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
#else

long double Clm[MAX_COEF_J][MAX_COEF_J] = {//2                 3                     4                        5                   6                   7                    8             9 10 11 12 13 14 15 16 17           
    0.0,                  0.0,-0.10826260745913e-02, 0.25324353457544E-05, 0.16193312050719e-05, 0.22771610163688E-06,-0.53964849049834e-06, 0.35136844210318e-06, 0.20251871520885e-06, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0,-0.24140000522221e-09, 0.21927988018965e-05,-0.50872530365024e-06,-0.53716510187662e-07,-0.59877976856303e-07, 0.20514872797672e-06, 0.16034587141379e-07, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0, 0.15745360427672e-05, 0.30901604455583e-06, 0.78412230752366e-07, 0.10559053538674e-06, 0.60120988437373e-08, 0.32844904836492e-07, 0.65765423316743e-08, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0.0,                  0.0,                  0.0, 0.10055885741455e-06, 0.59215743214072e-07,-0.14926153867389e-07, 0.11822664115915e-08, 0.35285405191512e-08,-0.19463581555399e-09, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,-0.39823957404129e-08,-0.22979123502681e-08,-0.32641389117891e-09,-0.58511949148624e-09,-0.31893580211856e-09, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0.43047675045029e-09,-0.21557711513900e-09, 0.58184856030873e-12,-0.46151734306628e-11, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0.22136925556741e-11,-0.24907176820596e-10,-0.18393642697634e-11, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0.25590780149873e-13, 0.34297618184624e-12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,-0.15803322891725e-12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0

 };
long double Slm[MAX_COEF_J][MAX_COEF_J] = {
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0, 0.15430999737844e-08, 0.26801189379726e-06,-0.44945993508117e-06,-0.80663463828530e-07, 0.21164664354382e-07, 0.69369893525908e-07, 0.40199781599510e-07, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,-0.90386807301869e-06,-0.21140239785975e-06, 0.14815545694714e-06,-0.52326723987632e-07,-0.46503948132217e-07, 0.92823143885084e-08, 0.53813164055056e-08, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0, 0.19720132389889e-06,-0.12011291831397e-07,-0.71008771406986e-08, 0.18431336880625e-09,-0.30611502382788e-08,-0.87235195047605e-09, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0, 0.65256058113396e-08, 0.38730050770804e-09,-0.17844913348882e-08,-0.26361822157867e-09, 0.91177355887255e-10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,-0.16482039468636e-08,-0.43291816989540e-09, 0.63972526639235e-11, 0.16125208346784e-10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,-0.55277122205966e-10, 0.10534878629266e-10, 0.86277431674150e-11, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0.44759834144751e-12, 0.38147656686685e-12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0.15353381397148e-12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0,                  0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};


#endif
// just for convinience to proper orbit clculation




typedef struct Long_Double_Intergal_Var4
{
    long double X;
    long double Y;
    long double Z;

    long double X_h;
    long double Y_h;
    long double Z_h;

    long double X_hh;
    long double Y_hh;
    long double Z_hh;

    long double X_hhh;
    long double Y_hhh;
    long double Z_hhh;

    long CountNx;
    long CountNy;
    long CountNz;


    long CountNx_h;
    long CountNy_h;
    long CountNz_h;

    long CountNx_hh;
    long CountNy_hh;
    long CountNz_hh;
    long double x() 
	{
           return X+X_h+X_hh+X_hhh; 
    };
    long double y() 
	{
            return Y+Y_h+Y_hh+Y_hhh; 
    };
    long double z() 
    { 
            return Z+Z_h+Z_hh+Z_hhh; 
    };
    void adjustX(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNx >= MaxVal)
        {
            CountNx = 0;
            ADJUST(X_h, 0, X);
            if (++CountNx_h >= MaxVal_h)
            {
                CountNx_h = 0;
                ADJUST(X_hh, 0, X_h);
                if (++CountNx_hh >= 983)
                {
                    CountNx_hh = 0;
                    ADJUST(X_hhh, 0, X_hh);
                }
            }
        }
    };
    void adjustY(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNy >= MaxVal)
        {
            CountNy = 0;
            ADJUST(Y_h, 0, Y);
            if (++CountNy_h >= MaxVal_h)
            {
                CountNy_h = 0;
                ADJUST(Y_hh, 0, Y_h);
                if (++CountNy_hh >= 1019)
                {
                    CountNy_hh = 0;
                    ADJUST(Y_hhh, 0, Y_hh);
                }
            }
        }
    };
    void adjustZ(long MaxVal, long MaxVal_h)
    {
        long double ldTemp, ldTemp2;
        if (++CountNz >= MaxVal)
        {
            CountNz = 0;
            ADJUST(Z_h, 0, Z);
            if (++CountNz_h >= MaxVal_h)
            {
                CountNz_h = 0;
                ADJUST(Z_hh, 0, Z_h);
                if (++CountNz_hh >= 1307)
                {
                    CountNz_hh = 0;
                   ADJUST(Z_hhh, 0, Z_hh);
                }
            }
        }
    };

    void ZeroIntegral (void)
    {
        X = 0.0;      Y = 0.0;      Z = 0.0;
        X_h =0.0;    Y_h =0.0;    Z_h =0.0;
        X_hh =0.0;   Y_hh =0.0;   Z_hh =0.0;
        X_hhh =0.0;   Y_hhh =0.0;   Z_hhh =0.0;
        CountNx = 0; CountNy = 0; CountNz = 0;
        CountNx_h = 0; CountNy_h = 0; CountNz_h = 0;
        CountNx_hh = 0; CountNy_hh = 0; CountNz_hh = 0;
    };
} LONG_DOUBLE_INT_VAR4, *PLONG_DOUBLE_INT_VAR4;



#define MINIMUM_BY_TIME 1
#define MAXIMUM_BY_TIME 2
#define MINIMUM_BY_ANGLE 4
#define MINIMUM_BY_WEIGHT 6

#define CALC_PERIGEE 0
#define CALC_APOGEE 1
#define CALC_TARGET_PRACTICE 3
#define CALC_TARGET_POINT 5
#define CALC_PERIOD 6 
#define CALC_MAX_FROM_EARTH 7
#define CALC_INIT_PERIOD 8
#define CALC_FIRE_FIRST_ENGINE_TIME 9
#define CALC_FIRE_SECOND_ENGINE_TIME 10
#define CALC_FIRE_THIRD_ENGINE_TIME_TRY_ONE 11
#define CALC_AT_APOGEE_DIFF_TO_3_4_DIST 12

#define COPYKEPLER(a1,b1,c1) memset(szTempo, 0, sizeof(szTempo)); memcpy(szTempo, b1, c1);  if (szTempo[0] == ' ') {szTempo[0] = '0';if (szTempo[1] == ' ') {szTempo[1] ='0';if (szTempo[2] == ' '){szTempo[2] ='0';}}}a1 = atof(szTempo);


long OldCurentTimeSec;
int OldCurentTimeTD;
int OldCurentIteraPerSec;



long double SunM = 1.9891E30;
long double GMEarthMoon;


long double AUcalc;
long double EarthSmAxAU;



int iFirstMinMax = 0;
long double FirstMinMaxX2 = .0;
long double FirstMinMaxY2 = .0;
long double FirstMinMaxZ2 = .0;

long double DeltaMinMaxD = 1.0E60;


long double EarthX2 = .0;
long double EarthY2 = .0;
long double EarthZ2 = .0;

long double EarthRP;
long double EarthRE;
long double MassRatioSunToEarthPlusMoon;
long double EarthTSolSec;


long double EarthTDays;
long double EarthTSec;

long double MoonRP;
long double MoonRE;

long double MassRatioEarthToMoon;

long double MoonTSec;
long double MoonCurTime;
long double MoonCurTimeS;

long double MoonTPeriod;
int MoonKeplerDone = 0;

int iStartLandingIteraPerSec = 0;

BOOL OutLast = FALSE;

char szMoonKeplerLine1[1024];
char szMoonKeplerLine2[1024];
char szMoonKeplerLine3[1024];






char SimulationTempOutputFile[1024]={"@trasimoutput.xml"};

char CalulationTempOutputFile[1024]={"@tracalc.xml"}; // in CALC mode the output file with 
 
char szCalcinfoFileName[256];


void CalcPlanetForces(TRAOBJ * SlS)
{
    int i;
    int j;
    // calculation of a forces
    for (i = 0; i < SlS->Elem; i++)
    {
        //if (SlS->flInUse[i] ==0)
        //    continue;

        long double *SlS_ForceDD_i_j = &SlS->ForceDD[i][0];
        long double *SlS_GM_j = &SlS->GM[0];
        long double *SlS_Distance2_i_j = &SlS->Distance2[i][0];
        for (j = 0; j < i; j++)
        {
            *SlS_ForceDD_i_j = * SlS_GM_j / *SlS_Distance2_i_j;
            SlS_ForceDD_i_j++;SlS_GM_j++;SlS_Distance2_i_j++;
        }
        SlS_ForceDD_i_j++;SlS_GM_j++;SlS_Distance2_i_j++;

/*
        for (j = 0; j < i; j++)
        {
            SlS->ForceDD[i][j] = SlS->GM[j] / SlS->Distance2[i][j];
        }
*/
        long double *SlS_Distance_i_j = &SlS->Distance[i][i+1];
        for (j = i+1; j < SlS->Elem; j++,SlS_ForceDD_i_j++,SlS_GM_j++,SlS_Distance2_i_j++,SlS_Distance_i_j++)
        {
            //if (i == j) 
            //    continue;
            //if (i > j)
            //{
            //    //SlS->ForceDD[i][j] = SlS->ForceDD[j][i];
            //    SlS->ForceDD[i][j] = SlS->GM[j] / SlS->Distance2[i][j];
            //    continue;
            //}
            //if (SlS->flInUse[j] ==0)
            //    continue;
            long double tD_Obj1Obj2 = (SlS->X[i] - SlS->X[j])*(SlS->X[i] - SlS->X[j]) + 
					    (SlS->Y[i] - SlS->Y[j])*(SlS->Y[i] - SlS->Y[j]) + 
					    (SlS->Z[i] - SlS->Z[j])*(SlS->Z[i] - SlS->Z[j]);

            //if (tD_Obj1Obj2 != SlS->Distance2[i][j])
            {
                *SlS_Distance2_i_j = tD_Obj1Obj2;
                SlS->Distance2[j][i] = tD_Obj1Obj2;
                double tD_ = sqrt(tD_Obj1Obj2);
                *SlS_Distance_i_j = tD_;
                SlS->Distance[j][i] = tD_;

                //if (tD_ != SlS->Distance[i][j])
                {
#if 1
                    //SlS->ForceDD[i][j] = /* SlS->M[i] * */SlS->GM[j] / SlS->Distance2[i][j];
                    *SlS_ForceDD_i_j = * SlS_GM_j / tD_Obj1Obj2;
#else
                    SlS->ForceDD[i][j] = SlS->GMxM[i][j] / SlS->Distance2[i][j];
                    SlS->ForceDD[j][i] = SlS->GMxM[j][i] / SlS->Distance2[j][i];

#endif
                }
            }
        }
    }

    for (i = 0; i < SlS->Elem; i++)
    {
        SlS->FX[i] = 0.0;
        SlS->FY[i] = 0.0;
        SlS->FZ[i] = 0.0;

        //if (SlS->flInUse[i] ==0)
        //    continue;
        long double *SlS_ForceDD_i = &(SlS->ForceDD[i][0]);
        long double *SlS_Distance_i = &(SlS->Distance[i][0]);
        for (j = 0; j < SlS->Elem; j++,SlS_ForceDD_i++, SlS_Distance_i++)
        {
            if (i == j) continue;
            //if (SlS->flInUse[j] ==0)
            //continue;
            long double SlS_ForceDD_i_j_div_SlS_Distance_i_j = *SlS_ForceDD_i/ *SlS_Distance_i;
            SlS->FX[i] += -( SlS->X[i] - SlS->X[j]) * SlS_ForceDD_i_j_div_SlS_Distance_i_j;
            SlS->FY[i] += -( SlS->Y[i] - SlS->Y[j]) * SlS_ForceDD_i_j_div_SlS_Distance_i_j;
            SlS->FZ[i] += -( SlS->Z[i] - SlS->Z[j]) * SlS_ForceDD_i_j_div_SlS_Distance_i_j;
        }
    }

}

int printcount =0;
void CalcSatForces(TRAOBJ * SlS, TRAOBJ * Sat, long double TimeOfCalc)
{
    int i;
    int j;
//    double Summ;
//    double Temp;
    long double DX1,DY1,DZ1;
    long double DX,DY,DZ;


    // calculation of a forces
    // loop for all calulated satellites
    for (i = 0; i < Sat->Elem; i++)
    {
       // loop for all selestial bodies
        long double *Sat_Distance2_i_j = &Sat->Distance2[i][0];
        long double *Sat_Distance_i_j  = &Sat->Distance[i][0];
        long double *Sat_ForceDD_i_j   = &Sat->ForceDD[i][0];
        long double *SlS_GM_j = &SlS->GM[0];
        long double *Sat_DeltaVX_i_j = &Sat->DeltaVX[i][0];
        long double *Sat_DeltaVY_i_j = &Sat->DeltaVY[i][0];
        long double *Sat_DeltaVZ_i_j = &Sat->DeltaVZ[i][0];
        for (j = 0; j < SlS->Elem; j++, Sat_Distance2_i_j++, Sat_Distance_i_j++, Sat_ForceDD_i_j++, SlS_GM_j++, Sat_DeltaVX_i_j++, Sat_DeltaVY_i_j++, Sat_DeltaVZ_i_j++)
        {
            // do we account that? Sun == yes Moon == yes but Saturn == probably no
            //if (SlS->flInUse[j] ==0)
            //    continue;
            // that is the distance*distance from the satellite to selestial body
            long double ValX0 = (Sat->X[i] - SlS->X[j]);
            long double ValY0 = (Sat->Y[i] - SlS->Y[j]);
            long double ValZ0 = (Sat->Z[i] - SlS->Z[j]);

            long double tD_Obj1Obj2 = ValX0*ValX0 + ValY0*ValY0 + ValZ0*ValZ0;
            
            *Sat_Distance2_i_j = tD_Obj1Obj2;
            long double tD_ = sqrt(tD_Obj1Obj2);
            *Sat_Distance_i_j = tD_;
            
#define FAST_CALCULATIONS
#ifdef FAST_CALCULATIONS

            //Sat->ForceDD_ = Sat->ForceDD[i][j];
            *Sat_DeltaVX_i_j =0;
            *Sat_DeltaVY_i_j =0;
            *Sat_DeltaVZ_i_j =0;
            Sat->FXM[i][j] = 0;  Sat->FYM[i][j] = 0;  Sat->FZM[i][j] = 0;

            if (j == Sat->LegBody)
            {
                //long double ModelCoef = SlS->GM[j]/ GM_MODEL;
                *Sat_ForceDD_i_j = GM_MODEL / *Sat_Distance2_i_j;

                Sat->R0divR[0] = 1;
                Sat->R0divR[1] = R0_MODEL/tD_;
                if (*Sat_Distance_i_j < 20*R0_MODEL)
                {
                    long double oXdivR = ValX0 /tD_;
                    long double oYdivR = ValY0 /tD_;
                    long double oZdivR = ValZ0 /tD_;

                    Sat->FastSummXYZ(ValX0,ValY0,ValZ0,Sat->Distance[i][j],DX1,DY1,DZ1, DX,DY,DZ,i);
#define _NO_GM_CORRECTION 1
                    *Sat_DeltaVX_i_j =oXdivR;// + DX1*oXdivR + DX;
                    *Sat_DeltaVY_i_j =oYdivR;// + DY1*oYdivR + DY;
                    *Sat_DeltaVZ_i_j =oZdivR;// + DZ1*oZdivR + DZ;

                    Sat->FXM[i][j] = DX1*oXdivR + DX;  Sat->FYM[i][j] = DY1*oYdivR + DY;  Sat->FZM[i][j] = DZ1*oZdivR+ DZ;

                    //printf("\n %04d %20.18f %20.18f %20.18f %20.18f %20.18f %20.18f %20.18f", printcount++, DX1, DX1*oXdivR, DX1*oYdivR, DX1*oZdivR, DX, DY, DZ); 
                }
            }
            else
            {
                *Sat_ForceDD_i_j = *SlS_GM_j / *Sat_Distance2_i_j; // to get real force need to multiply on mass of the satellite
            }
#else
#endif
        }
    }
    long double *Sat_FX_i = &Sat->FX[0];
    long double *Sat_FY_i = &Sat->FY[0];
    long double *Sat_FZ_i = &Sat->FZ[0];
    // calculation of a XYZ forces
    for (i = 0; i < Sat->Elem; i++,Sat_FX_i++,Sat_FY_i++,Sat_FZ_i++)
    {
        *Sat_FX_i = 0.0;
        *Sat_FY_i = 0.0;
        *Sat_FZ_i = 0.0;

        long double *Sat_DeltaVX_i_j = &Sat->DeltaVX[i][0];
        long double *Sat_DeltaVY_i_j = &Sat->DeltaVY[i][0];
        long double *Sat_DeltaVZ_i_j = &Sat->DeltaVZ[i][0];
        long double *Sat_ForceDD_i_j = &Sat->ForceDD[i][0];
        long double *Sat_Distance_i_j =  &Sat->Distance[i][0];
        for (j = 0; j < SlS->Elem; j++, Sat_DeltaVX_i_j++, Sat_DeltaVY_i_j++, Sat_DeltaVZ_i_j++, Sat_ForceDD_i_j++, Sat_Distance_i_j++)
        {
            //if (SlS->flInUse[j] ==0)
            //continue;
            if (j == Sat->LegBody)
            {
                //Sat->FX[i] += -( Sat->X[i] - SlS->X[j])  * Sat->ForceDD[i][j]/Sat->Distance[i][j] + Sat->DeltaVX[i][j]*Sat->ForceDD[i][j];
                //Sat->FY[i] += -( Sat->Y[i] - SlS->Y[j])  * Sat->ForceDD[i][j]/Sat->Distance[i][j] + Sat->DeltaVY[i][j]*Sat->ForceDD[i][j];
                //Sat->FZ[i] += -( Sat->Z[i] - SlS->Z[j])  * Sat->ForceDD[i][j]/Sat->Distance[i][j] + Sat->DeltaVZ[i][j]*Sat->ForceDD[i][j];

                *Sat_FX_i += - *Sat_DeltaVX_i_j* *Sat_ForceDD_i_j;
                *Sat_FY_i += - *Sat_DeltaVY_i_j* *Sat_ForceDD_i_j;
                *Sat_FZ_i += - *Sat_DeltaVZ_i_j* *Sat_ForceDD_i_j;
                Sat->Fxm[i] = - Sat->FXM[i][j] * *Sat_ForceDD_i_j; Sat->Fym[i] = - Sat->FYM[i][j] * *Sat_ForceDD_i_j; Sat->Fzm[i] = - Sat->FZM[i][j] * *Sat_ForceDD_i_j;

#if 1
                if (Sat->ProbSquare[i])
                {
                    // account Air force:
                    long double AirFX = Sat->VX[i] - SlS->VX[j];
                    long double AirFY = Sat->VY[i] - SlS->VY[j];
                    long double AirFZ = Sat->VZ[i] - SlS->VZ[j];
                    long double AirNorm = sqrt(AirFX*AirFX + AirFY*AirFY + AirFZ*AirFZ);
                    long double AbsAir = AirNorm* Sat->ro[i] * Sat->ProbSquare[i]/2*SlS->TimeSl_2;
                    //long double AbsAir = AirNorm* Sat->ro[i] * 2004.0*SlS->TimeSl_2; // is it? Is ISS looks like square with side= 56.014 m? => S area= 3137.679m^2
                    //long double AbsAir = AirNorm* Sat->Ro * 1568.8395*SlS->TimeSl_2; // is it? Is ISS looks like square with side= 56.014 m? => S area= 3137.679m^2
                    *Sat_FX_i -=AirFX *AbsAir;
                    *Sat_FY_i -=AirFY *AbsAir;
                    *Sat_FZ_i -=AirFZ *AbsAir;
                }
#endif
            }
            else
            {
                long double Sat_ForceDD_i_j_div_Sat_Distance_i_j = *Sat_ForceDD_i_j/ *Sat_Distance_i_j;
                *Sat_FX_i += -( Sat->X[i] - SlS->X[j]) * Sat_ForceDD_i_j_div_Sat_Distance_i_j;
                *Sat_FY_i += -( Sat->Y[i] - SlS->Y[j]) * Sat_ForceDD_i_j_div_Sat_Distance_i_j;
                *Sat_FZ_i += -( Sat->Z[i] - SlS->Z[j]) * Sat_ForceDD_i_j_div_Sat_Distance_i_j;
            }
        }
    }
}
#define VERY_BASIC
#ifdef VERY_BASIC
#if 0
void IteraSolarSystem(BOOL ForceWasCalculated, TRAOBJ * SlS)
{
    int i;
    //int j;
    // calculation of a[i] based on x[i]
    CalcPlanetForces(SlS);
    // calculation of velocities and positions 
    for (i = 0; i < SlS->Elem; i++)
    {
        // this is original formula
        SlS->VX[i] += SlS->FX[i] * SlS->TimeSl/* / SlS->M[i]*/;
        SlS->VY[i] += SlS->FY[i] * SlS->TimeSl/* / SlS->M[i]*/;
        SlS->VZ[i] += SlS->FZ[i] * SlS->TimeSl/* / SlS->M[i]*/;

        SlS->X[i] += SlS->VX[i]*SlS->TimeSl;
        SlS->Y[i] += SlS->VY[i]*SlS->TimeSl;
        SlS->Z[i] += SlS->VZ[i]*SlS->TimeSl;

    }
}
#else
#define NO_SEPARATION_VEL_POS 1
void IteraSolarSystem(BOOL ForceWasCalculated, TRAOBJ * SlS)
{
    XYZ_SPLIT_POINTER_VAR XYZdataPos;
    XYZ_SPLIT_POINTER_VAR XYZdataVel;
    int i;
    //int j;
    // calculation of a[i] based on x[i]
    CalcPlanetForces(SlS);
    // calculation of velocities and positions 

    if (SlS->RunOne)
    {
        SlS->RunOne = FALSE;
        for (i = 0; i < SlS->Elem; i++)
        {
            SlS->_position_[i].ZeroIntegral();
            SlS->_velosity_[i].ZeroIntegral();

#ifdef NO_SEPARATION_VEL_POS
            SlS->_position_[i].X0 = SlS->X[i]/ SlS->TimeSl_2+ SlS->VX[i]/SlS->TimeSl;
            SlS->_position_[i].Y0 = SlS->Y[i]/ SlS->TimeSl_2+ SlS->VY[i]/SlS->TimeSl;
            SlS->_position_[i].Z0 = SlS->Z[i]/ SlS->TimeSl_2+ SlS->VZ[i]/SlS->TimeSl;

#else
            SlS->_position_[i].X0 = SlS->X[i]/ SlS->TimeSl_2; SlS->_position_[i].VX0 = SlS->VX[i]/SlS->TimeSl;
            SlS->_position_[i].Y0 = SlS->Y[i]/ SlS->TimeSl_2; SlS->_position_[i].VY0 = SlS->VY[i]/SlS->TimeSl;
            SlS->_position_[i].Z0 = SlS->Z[i]/ SlS->TimeSl_2; SlS->_position_[i].VZ0 = SlS->VZ[i]/SlS->TimeSl;
#endif

            SlS->_velosity_[i].X0 = SlS->VX[i]/SlS->TimeSl;
            SlS->_velosity_[i].Y0 = SlS->VY[i]/SlS->TimeSl;
            SlS->_velosity_[i].Z0 = SlS->VZ[i]/SlS->TimeSl;
        }
    }
    for (i = 0; i < SlS->Elem; i++)
    {
        XYZdataPos.valX = (SlS->_velosity_[i].x())+ SlS->FX[i];
        XYZdataPos.valY = (SlS->_velosity_[i].y())+ SlS->FY[i];
        XYZdataPos.valZ = (SlS->_velosity_[i].z())+ SlS->FZ[i];
        XYZdataPos.valXM = 0;   XYZdataPos.valYM = 0;  XYZdataPos.valZM = 0;

        XYZdataVel.valX = SlS->FX[i];
        XYZdataVel.valY = SlS->FY[i];
        XYZdataVel.valZ = SlS->FZ[i];
        XYZdataVel.valXM = 0;   XYZdataVel.valYM = 0;  XYZdataVel.valZM = 0;

#ifdef NO_SEPARATION_VEL_POS
        SlS->_position_[i].Add(&XYZdataPos);

        SlS->_velosity_[i].Add(&XYZdataVel);
        SlS->_position_[i].adjustAll();
        SlS->_velosity_[i].adjustall();
        SlS->_position_[i].getIntegral(SlS->X[i], SlS->Y[i], SlS->Z[i]);

#else

        SlS->_position_[i].Addpos(&XYZdataPos, &XYZdataVel);

        SlS->_velosity_[i].Add(&XYZdataVel);
        SlS->_position_[i].adjustAllpos();
        SlS->_velosity_[i].adjustall();
        SlS->_position_[i].getIntegralpos(SlS->X[i], SlS->Y[i], SlS->Z[i]);
#endif
        SlS->X[i] = (SlS->X[i]+ SlS->_velosity_[i].X0 *SlS->_velosity_[i].nX0)* SlS->TimeSl_2;   
        SlS->Y[i] = (SlS->Y[i]+ SlS->_velosity_[i].Y0 *SlS->_velosity_[i].nX0)* SlS->TimeSl_2;   
        SlS->Z[i] = (SlS->Z[i]+ SlS->_velosity_[i].Z0 *SlS->_velosity_[i].nX0)* SlS->TimeSl_2;
        SlS->_velosity_[i].getIntegral(SlS->VX[i], SlS->VY[i], SlS->VZ[i]);
        SlS->VX[i] *= SlS->TimeSl; 
        SlS->VY[i] *= SlS->TimeSl; SlS->VZ[i] *= SlS->TimeSl;
        SlS->_position_[i].nX0++;
        SlS->_velosity_[i].nX0++;

    }
}

#endif
#if 0
void IteraSat(int TimeDirection, TRAOBJ * SlS, TRAOBJ * Sat, long double TimeOfCalc)
{
    int i;
    //int j;
    Sat->Lambda = GreenwichAscensionFromTLEEpoch(TimeOfCalc,Sat->precEps,Sat->precTet,Sat->precZ,Sat->nutEpsilon,Sat->nutDFeta);

    CalcSatForces(SlS, Sat, TimeOfCalc);

    for (i = 0; i < Sat->Elem; i++)
    {
        Sat->X[i] +=Sat->VX[i]*SlS->TimeSl +Sat->FX[i] * TimeSl_2;
        Sat->Y[i] +=Sat->VY[i]*SlS->TimeSl +Sat->FY[i] * TimeSl_2;
        Sat->Z[i] +=Sat->VZ[i]*SlS->TimeSl +Sat->FZ[i] * TimeSl_2;

        Sat->VX[i] += Sat->FX[i] * SlS->TimeSl /* Sat->M[i]*/;
        Sat->VY[i] += Sat->FY[i] * SlS->TimeSl /* Sat->M[i]*/;
        Sat->VZ[i] += Sat->FZ[i] * SlS->TimeSl /* Sat->M[i]*/;


    }
}
#else
void IteraSat(int TimeDirection, TRAOBJ * SlS, TRAOBJ * Sat, long double TimeOfCalc)
{
    int i;
    //int j;
    XYZ_SPLIT_POINTER_VAR XYZdataPos;
    XYZ_SPLIT_POINTER_VAR XYZdataVel;

    Sat->Lambda = GreenwichAscensionFromTLEEpoch(TimeOfCalc,Sat->precEps,Sat->precTet,Sat->precZ,Sat->nutEpsilon,Sat->nutDFeta);

#define TEST_STATIC_EARTH 1
#ifdef TEST_STATIC_EARTH
    Sat->precEps =0;
    Sat->precTet =0;
    Sat->precZ =0;
    Sat->nutEpsilon =0;
    Sat->nutDFeta = 0;
    Sat->Lambda = 0;
#endif

    CalcSatForces(SlS, Sat, TimeOfCalc);

    if (Sat->RunOne)
    {
        Sat->RunOne = FALSE;
        for (i = 0; i < Sat->Elem; i++)
        {
           
            Sat->_position_[i].ZeroIntegral();
            Sat->_velosity_[i].ZeroIntegral();
#ifdef NO_SEPARATION_VEL_POS
            Sat->_position_[i].X0 = Sat->X[i]/ SlS->TimeSl_2 + Sat->VX[i]/SlS->TimeSl;
            Sat->_position_[i].Y0 = Sat->Y[i]/ SlS->TimeSl_2 + Sat->VY[i]/SlS->TimeSl;
            Sat->_position_[i].Z0 = Sat->Z[i]/ SlS->TimeSl_2 + Sat->VZ[i]/SlS->TimeSl;

#else
            Sat->_position_[i].X0 = Sat->X[i]/ SlS->TimeSl_2; Sat->_position_[i].VX0 = Sat->VX[i]/SlS->TimeSl;
            Sat->_position_[i].Y0 = Sat->Y[i]/ SlS->TimeSl_2; Sat->_position_[i].VY0 = Sat->VY[i]/SlS->TimeSl;
            Sat->_position_[i].Z0 = Sat->Z[i]/ SlS->TimeSl_2; Sat->_position_[i].VZ0 = Sat->VZ[i]/SlS->TimeSl;
#endif

            Sat->_velosity_[i].X0 = Sat->VX[i]/SlS->TimeSl;
            Sat->_velosity_[i].Y0 = Sat->VY[i]/SlS->TimeSl;
            Sat->_velosity_[i].Z0 = Sat->VZ[i]/SlS->TimeSl;

        }
    }
    for (i = 0; i < Sat->Elem; i++)
    {
        XYZdataPos.valX = (Sat->_velosity_[i].x())+ Sat->FX[i];
        XYZdataPos.valY = (Sat->_velosity_[i].y())+ Sat->FY[i];
        XYZdataPos.valZ = (Sat->_velosity_[i].z())+ Sat->FZ[i];
        XYZdataPos.valXM = Sat->Fxm[i];   XYZdataPos.valYM = Sat->Fym[i];  XYZdataPos.valZM = Sat->Fzm[i];

        //XYZdataPos.valXM = 0;   XYZdataPos.valYM = 0;  XYZdataPos.valZM = 0;
        //XYZdataPos.valXS = 0;   XYZdataPos.valYS = 0;  XYZdataPos.valZS = 0;

        XYZdataVel.valX = Sat->FX[i];
        XYZdataVel.valY = Sat->FY[i];
        XYZdataVel.valZ = Sat->FZ[i];
        XYZdataVel.valXM = Sat->Fxm[i];   XYZdataVel.valYM = Sat->Fym[i];  XYZdataVel.valZM = Sat->Fzm[i];

        //XYZdataVel.valXM = 0;   XYZdataVel.valYM = 0;  XYZdataVel.valZM = 0;
        //XYZdataVel.valXS = 0;   XYZdataVel.valYS = 0;  XYZdataVel.valZS = 0;

#ifdef NO_SEPARATION_VEL_POS
        Sat->_position_[i].Add(&XYZdataPos);
        Sat->_velosity_[i].Add(&XYZdataVel);
        Sat->_position_[i].adjustAll();
        Sat->_velosity_[i].adjustall();
        Sat->_position_[i].getIntegral(Sat->X[i], Sat->Y[i], Sat->Z[i]);
#else
        Sat->_position_[i].Addpos(&XYZdataPos, &XYZdataVel);
        Sat->_velosity_[i].Add(&XYZdataVel);
        Sat->_position_[i].adjustAllpos();
        Sat->_velosity_[i].adjustall();
        Sat->_position_[i].getIntegralpos(Sat->X[i], Sat->Y[i], Sat->Z[i]);
#endif
        Sat->X[i] = (Sat->X[i]+ Sat->_velosity_[i].X0 *Sat->_velosity_[i].nX0)* SlS->TimeSl_2;   
        Sat->Y[i] = (Sat->Y[i]+ Sat->_velosity_[i].Y0 *Sat->_velosity_[i].nX0)* SlS->TimeSl_2;   
        Sat->Z[i] = (Sat->Z[i]+ Sat->_velosity_[i].Z0 *Sat->_velosity_[i].nX0)* SlS->TimeSl_2;
        Sat->_velosity_[i].getIntegral(Sat->VX[i], Sat->VY[i], Sat->VZ[i]);
        Sat->VX[i] *= SlS->TimeSl; Sat->VY[i] *= SlS->TimeSl; Sat->VZ[i] *= SlS->TimeSl;
        Sat->_position_[i].nX0++;
        Sat->_velosity_[i].nX0++;
    }
}

#endif
#endif
void FireEngine(int TimeDirection, int DeltaTimeFromStart, TRAIMPLOBJ * Engine, TRAOBJ *Sat, int iSat, long double DirX, long double DirY, long double DirZ)
{
    long double VectorValue = sqrt(DirX*DirX + DirY*DirY +DirZ*DirZ);
    long double coeff = 1.0/VectorValue;
    long double dirX = DirX*coeff;
    long double dirY = DirY*coeff;
    long double dirZ = DirZ*coeff;
    // direction of a force is oposit the direction of a firing engine
    long double ForceX = -dirX * Engine->ValImpl[DeltaTimeFromStart];
    long double ForceY = -dirY * Engine->ValImpl[DeltaTimeFromStart];
    long double ForceZ = -dirZ * Engine->ValImpl[DeltaTimeFromStart];
    long double VX = ForceX* Engine->DeltaTime / Sat->M[iSat];
    long double VY = ForceY* Engine->DeltaTime / Sat->M[iSat];
    long double VZ = ForceZ* Engine->DeltaTime / Sat->M[iSat];
    
    Sat->VX[iSat] += VX;
    Sat->VY[iSat] += VY;
    Sat->VZ[iSat] += VZ;

    Sat->X[iSat] += VX * Engine->DeltaTime;
    Sat->Y[iSat] += VY * Engine->DeltaTime;
    Sat->Z[iSat] += VZ * Engine->DeltaTime;
    Sat->M[iSat] -= Engine->Weight * Engine->ValImpl[DeltaTimeFromStart]*Engine->DeltaTime / Engine->TotalImpulse;
}
long double GetRadius(TRAOBJ * SlS, int iBody, long double LongOnMoon,long double LatiOnMoon)
{
    long double dR = 1000000.0; // just for init == bogus radius 1000km
    // TBD earth NOT round
    if (iBody == EARTH)
    {
        dR = EarthR;
    }
    // TBD with the moon the same 
    if (iBody == MOON)
    {
        dR = MoonR;
    }
    return dR;
}
long double GetRadius(TRAOBJ * SlS, int iBody, TRAOBJ * Sat, int iSat)
{
    double dR = 1000000.0; // just for init == bogus radius 1000km
    // TBD earth NOT round
    if (iBody == EARTH)
    {
        dR = EarthR;
    }
    // TBD with the moon the same 
    if (iBody == MOON)
    {
        dR = MoonR;
    }
    return dR;
}

void getLongLatiMoon(double &LongOnMoon,double &LatiOnMoon, TRAOBJ *SlS, int iRefMOON,int iRefEARTH, TRAOBJ *Sat, int iSat)
{
    double dREM = sqrt((SlS->X[iRefMOON] - SlS->X[iRefEARTH])*(SlS->X[iRefMOON] - SlS->X[iRefEARTH])+
                       (SlS->Y[iRefMOON] - SlS->Y[iRefEARTH])*(SlS->Y[iRefMOON] - SlS->Y[iRefEARTH])+
                       (SlS->Z[iRefMOON] - SlS->Z[iRefEARTH])*(SlS->Z[iRefMOON] - SlS->Z[iRefEARTH]));
    double dRM = sqrt((SlS->X[iRefMOON] - Sat->X[iSat])*(SlS->X[iRefMOON] - Sat->X[iSat])+
                       (SlS->Y[iRefMOON] - Sat->Y[iSat])*(SlS->Y[iRefMOON] - Sat->Y[iSat])+
                       (SlS->Z[iRefMOON] - Sat->Z[iSat])*(SlS->Z[iRefMOON] - Sat->Z[iSat]));
    double SatZSin = (Sat->Z[0] -SlS->Z[iRefMOON])/ dRM;
    double EarthZSin = (SlS->Z[iRefEARTH] -SlS->Z[iRefMOON])/ dREM;
    double SatLatiAsin = asin(SatZSin);
    double EarthLatiAsin = asin(EarthZSin);
    LatiOnMoon = (SatLatiAsin-EarthLatiAsin)*180.0/M_PI;
	double SatZCos = cos(SatLatiAsin);
	double EarthZCos = cos(EarthLatiAsin);

    double SatXSin = -(Sat->X[0] -SlS->X[iRefMOON])/ dRM/ SatZCos;
    double EarthXSin = -(SlS->X[iRefEARTH] -SlS->X[iRefMOON])/ dREM/ EarthZCos;

    double SatYCos = (Sat->Y[0] -SlS->Y[MOON])/ dRM/ SatZCos ;
    double EarthYCos = (SlS->Y[iRefEARTH] -SlS->Y[iRefMOON])/ dREM/ EarthZCos;


    double SatLongAsin = asin(SatXSin);
    // check all quarters
    if ((SatXSin >= 0.0) && (SatYCos>=0.0))
        ;
    else if ((SatXSin < 0.0) && (SatYCos>=0.0))
        ;
    else if ((SatXSin < 0.0) && (SatYCos < 0.0))
        SatLongAsin += M_PI/2.0;
    else
        SatLongAsin -= M_PI/2.0;

    double EarthLongAsin = asin(EarthXSin);

    if ((EarthXSin >= 0.0) && (EarthYCos>=0.0))
        ;
    else if ((EarthXSin < 0.0) && (EarthYCos>=0.0))
        ;
    else if ((EarthXSin < 0.0) && (EarthYCos < 0.0))
        EarthLongAsin += M_PI/2.0;
    else
        EarthLongAsin -= M_PI/2.0;

    LongOnMoon = (SatLongAsin-EarthLongAsin)*180.0/M_PI;
}
// PosXMoon,PosYMoon,PosZMoon - is a point on a moon surface ; coordinates are common
void getXYZMoon(double LongOnMoon,double LatiOnMoon,double &PosXMoon,double &PosYMoon,double &PosZMoon, TRAOBJ *SlS,int iRefMOON,int iRefEARTH, double dRadius)
{
    double dREM = sqrt((SlS->X[iRefMOON] - SlS->X[iRefEARTH])*(SlS->X[iRefMOON] - SlS->X[iRefEARTH])+
                       (SlS->Y[iRefMOON] - SlS->Y[iRefEARTH])*(SlS->Y[iRefMOON] - SlS->Y[iRefEARTH])+
                       (SlS->Z[iRefMOON] - SlS->Z[iRefEARTH])*(SlS->Z[iRefMOON] - SlS->Z[iRefEARTH]));
    double EarthZSin = (SlS->Z[iRefEARTH] -SlS->Z[iRefMOON])/ dREM;
    double EarthLatiAsin = asin(EarthZSin);
	double EarthZCos = cos(EarthLatiAsin);
    double EarthLatiDeg = EarthLatiAsin * 180.0/M_PI;
    double SatLatideg = LatiOnMoon + EarthLatiDeg;
    double SatLatiAsin = SatLatideg * M_PI/180.0;
    double SatZSin = sin(SatLatiAsin);
	double SatZCos = cos(SatLatiAsin);

    double EarthXSin = - (SlS->X[iRefEARTH] -SlS->X[iRefMOON])/ dREM/EarthZCos;
    double EarthYCos = (SlS->Y[iRefEARTH] -SlS->Y[iRefMOON])/ dREM/EarthZCos;
    double EarthLongAsin = asin(EarthXSin);
    if ((EarthXSin >= 0.0) && (EarthYCos>=0.0))
        ;
    else if ((EarthXSin < 0.0) && (EarthYCos>=0.0))
        ;
    else if ((EarthXSin < 0.0) && (EarthYCos < 0.0))
        EarthLongAsin += M_PI/2.0;
    else
        EarthLongAsin -= M_PI/2.0;

    double SatLongAsin = LongOnMoon + EarthLongAsin* 180.0/M_PI;
    double SatXSin = sin(SatLongAsin* M_PI/180.0);
    double SatYCos = cos(SatLongAsin* M_PI/180.0);

    
    PosZMoon =   dRadius * SatZSin + SlS->Z[iRefMOON];
    PosXMoon = - dRadius * SatXSin * SatZCos + SlS->X[iRefMOON];
    PosYMoon =   dRadius * SatYCos * SatZCos + SlS->Y[iRefMOON];
}
void GetXYZfromLatLong(double Long,double Lat,double &PosX,double &PosY,double &PosZ, double dRadius)
{
//   LAT = latitude * pi/180    // shirota
//   LON = longitude * pi/180   // dolgota
//   Y =  R * cos(LAT) * cos(LON)
//   Z =  R * sin(LAT) 
//   X = -R * cos(LAT) * sin(LON)

    PosZ =   dRadius * sin(Lat* M_PI/180.0);
    PosX = - dRadius * cos(Lat* M_PI/180.0) * sin(Long* M_PI/180.0);
    PosY =   dRadius * cos(Lat* M_PI/180.0) * cos(Long* M_PI/180.0);
}

#ifdef _DO_VISUALIZATION

unsigned char bRGBImage[IMAGE_W*IMAGE_H*3];

int iCounterToSkip = 0;
                                  // mer      ven       ear      mar      jup         sat       urn      nep       plt       moon        sun
unsigned char PlanetColors[16*3] ={50,50,50, 0,255,0, 0,0,255, 127,0,0, 127,127,0, 127,0,127, 0,127,127, 0,64,64, 64,0,64, 127,127,127, 255,0,0};
unsigned char SatColors[16*3] ={0,0,0, 20,20,20, 30,30,30,};
char szXYZ[6][5] ={"XY", "YZ","XZ", "_YZ", "_XZ", "_XY"};
void putpixel(unsigned char *bRGB, int X, int Y)
{
    int iRow = (X + bRGBImageW/2) + (bRGBImageH - (Y + bRGBImageH/2))*bRGBImageW;
    if ((iRow*3 >=0) && (iRow*3 < (sizeof(bRGBImage) -3)))
    {
        memcpy(&bRGBImage[iRow*3],bRGB, 3);
    }
}
void DrawFinalBody(TRAOBJ *SlS, int iBodyReference, TRAOBJ *Sat, int iSec,char *szInitName, TRAOBJ *XYZReference, int iXYZReference, double Scale, int &StartSequence)
{
    double X1 = SlS->X[iBodyReference] - XYZReference->X[iXYZReference];
    double Y1 = SlS->Y[iBodyReference] - XYZReference->Y[iXYZReference];
    double Z1 = SlS->Z[iBodyReference] - XYZReference->Z[iXYZReference];
    double X2;
    double Y2;
    int i;
    double dRadius = GetRadius(SlS, iBodyReference, Sat, 0);
    switch(iProfile)
    {
    case 0: X2 = X1; Y2 = Y1;break; 
    case 1: X2 = Y1; Y2 = Z1;break; 
    case 2: X2 = X1; Y2 = Z1;break; 
    case 3: X2 = -Y1; Y2 = Z1;break;
    case 4: X2 = -X1; Y2 = Z1;break;
    case 5: X2 = -X1; Y2 = Y1;break; 
    default: break;
    }
    // draw circle
    for (i = 0; i < 365; i++)
    {
        double dDeg = ((double)i) * M_PI /180;
        double X2C = X2 + cos(dDeg)*dRadius;
        double Y2C = Y2 + sin(dDeg)*dRadius;

        if (-Scale < X2C  && X2C < Scale)
        {
            if (((-Scale * bRGBImageH/ bRGBImageW) < Y2C)  && Y2C < ((Scale* bRGBImageH/ bRGBImageW)))
            {
                putpixel(&PlanetColors[iBodyReference*3], (int)(X2C/Scale*bRGBImageH), (int)(Y2C/Scale*bRGBImageH));
            }
        }
    }
    // draw sun day & night lights
    double X1S = SlS->X[SUN] - XYZReference->X[iXYZReference];
    double Y1S = SlS->Y[SUN] - XYZReference->Y[iXYZReference];
    double Z1S = SlS->Z[SUN] - XYZReference->Z[iXYZReference];
    double DS = sqrt(X1S*X1S + Y1S*Y1S + Z1S*Z1S);
    switch(iProfile)
    {
    case 0: X1S = X1S; Y1S = Y1S;break; 
    case 1: X1S = Y1S; Y1S = Z1S;break; 
    case 2: X1S = X1S; Y1S = Z1S;break; 
    case 3: X1S = -Y1S; Y1S = Z1S;break;
    case 4: X1S = -X1S; Y1S = Z1S;break;
    case 5: X1S = -X1S; Y1S = Y1S;break; 
    default: break;
    }
    double dAngleSin = X1S/DS;
    double dAngleCos = Y1S/DS;
    for (i = -(int)dRadius; i < (int)dRadius; i+=1000)
    {
        double X2C = X2 + -dAngleCos*((double)i);
        double Y2C = Y2 + dAngleSin*((double)i);
        if (-Scale < X2C  && X2C < Scale)
        {
            if (((-Scale * bRGBImageH/ bRGBImageW) < Y2C)  && Y2C < ((Scale* bRGBImageH/ bRGBImageW)))
            {
                putpixel(&PlanetColors[iXYZReference*3], (int)(X2C/Scale*bRGBImageH), (int)(Y2C/Scale*bRGBImageH));
            }
        }

    }

    // draw direction to earth
    X1S = SlS->X[EARTH] - XYZReference->X[iXYZReference];
    Y1S = SlS->Y[EARTH] - XYZReference->Y[iXYZReference];
    Z1S = SlS->Z[EARTH] - XYZReference->Z[iXYZReference];
    DS = sqrt(X1S*X1S + Y1S*Y1S + Z1S*Z1S);
    switch(iProfile)
    {
    case 0: X1S = X1S; Y1S = Y1S;break; 
    case 1: X1S = Y1S; Y1S = Z1S;break; 
    case 2: X1S = X1S; Y1S = Z1S;break; 
    case 3: X1S = -Y1S; Y1S = Z1S;break;
    case 4: X1S = -X1S; Y1S = Z1S;break;
    case 5: X1S = -X1S; Y1S = Y1S;break; 
    default: break;
    }
    dAngleSin = X1S/DS;
    dAngleCos = Y1S/DS;
    for (i = 0; i < dRadius; i+=1000)
    {
        double X2C = X2 + dAngleSin*((double)i);
        double Y2C = Y2 + dAngleCos*((double)i);
        if (-Scale < X2C  && X2C < Scale)
        {
            if (((-Scale * bRGBImageH/ bRGBImageW) < Y2C)  && Y2C < ((Scale* bRGBImageH/ bRGBImageW)))
            {
                putpixel(&PlanetColors[iXYZReference*3], (int)(X2C/Scale*bRGBImageH), (int)(Y2C/Scale*bRGBImageH));
            }
        }

    }
    // draw last satelite point
    X1 = Sat->X[0] - XYZReference->X[iXYZReference];
    Y1 = Sat->Y[0] - XYZReference->Y[iXYZReference];
    Z1 = Sat->Z[0] - XYZReference->Z[iXYZReference];
    switch(iProfile)
    {
    case 0: X2 = X1; Y2 = Y1;break; 
    case 1: X2 = Y1; Y2 = Z1;break; 
    case 2: X2 = X1; Y2 = Z1;break; 
    case 3: X2 = -Y1; Y2 = Z1;break;
    case 4: X2 = -X1; Y2 = Z1;break;
    case 5: X2 = -X1; Y2 = Y1;break; 
    default: break;
    }

    if (-Scale < X2  && X2 < Scale)
    {
        if (((-Scale * bRGBImageH/ bRGBImageW) < Y2)  && Y2 < ((Scale* bRGBImageH/ bRGBImageW)))
        {
            putpixel(&SatColors[0], (int)(X2/Scale*bRGBImageH), (int)(Y2/Scale*bRGBImageH));
        }
    }
    if (StartSequence++ < iMaxSeq)
    {
        char szName[256];
        sprintf(szName, "%s%s%05d.jpg", szInitName, &szXYZ[iProfile],StartSequence-1);
        write_JPEG_file(szName, 80, bRGBImageW, bRGBImageH, 3,  bRGBImage, JCS_RGB);
    }
    // draw North pole on a moon
    if (iBodyReference == MOON)
    {

    }
}
void DrawAnimationSequence(TRAOBJ *SlS, TRAOBJ *Sat, int iSec,char *szInitName, TRAOBJ *XYZReference, int iXYZReference, double Scale, int &StartSequence, int storeNow)
{
    int i;
    //int j;

    if ((StartSequence == 0) && (storeNow ==0))
    {
        memset(bRGBImage, 255, sizeof(bRGBImage));
        iCounterToSkip = iMaxCounter;
        StartSequence++;
    }
    for (i = 0; i < SlS->Elem; i++)
    {
        double X1 = SlS->X[i] - XYZReference->X[iXYZReference];
        double Y1 = SlS->Y[i] - XYZReference->Y[iXYZReference];
        double Z1 = SlS->Z[i] - XYZReference->Z[iXYZReference];
        double X2;
        double Y2;
        switch(iProfile)
        {
        case 0: X2 = X1; Y2 = Y1;break; 
        case 1: X2 = Y1; Y2 = Z1;break; 
        case 2: X2 = X1; Y2 = Z1;break; 
        case 3: X2 = -Y1; Y2 = Z1;break;
        case 4: X2 = -X1; Y2 = Z1;break;
        case 5: X2 = -X1; Y2 = Y1;break; 
        default: break;
        }
        if (-Scale < X2  && X2 < Scale)
        {
            if (((-Scale * bRGBImageH/ bRGBImageW) < Y2)  && Y2 < ((Scale* bRGBImageH/ bRGBImageW)))
            {
                putpixel(&PlanetColors[i*3], (int)(X2/Scale*bRGBImageH), (int)(Y2/Scale*bRGBImageH));
            }
        }
    }
    for (i = 0; i < Sat->Elem; i++)
    {
        double X1 = Sat->X[i] - XYZReference->X[iXYZReference];
        double Y1 = Sat->Y[i] - XYZReference->Y[iXYZReference];
        double Z1 = Sat->Z[i] - XYZReference->Z[iXYZReference];
        double X2;
        double Y2;
        switch(iProfile)
        {
        case 0: X2 = X1; Y2 = Y1;break; 
        case 1: X2 = Y1; Y2 = Z1;break; 
        case 2: X2 = X1; Y2 = Z1;break; 
        case 3: X2 = -Y1; Y2 = Z1;break;
        case 4: X2 = -X1; Y2 = Z1;break;
        case 5: X2 = -X1; Y2 = Y1;break;
        default: break;
        }
        if (-Scale < Y2  && Y2 < Scale)
        {
            if ((-Scale * bRGBImageW/ bRGBImageH) < X2  && X2 < (Scale* bRGBImageW/ bRGBImageH))
            {
                putpixel(&SatColors[i*3], (int)(X2/Scale*bRGBImageH), (int)(Y2/Scale*bRGBImageH));
            }
        }
    }
    // store last image
    if ((--iCounterToSkip <= 0) || (storeNow == 1))
    {
        if (storeNow == 1)
        {
            iCounterToSkip++;
        }
        else
            iCounterToSkip = iMaxCounter;
        if (StartSequence++ < iMaxSeq)
        {
            char szName[256];
            sprintf(szName, "%s%s%05d.jpg", szInitName, &szXYZ[iProfile],StartSequence-1);
            //DeleteFile(szName);
            write_JPEG_file (szName, 80, bRGBImageW, bRGBImageH, 3,  bRGBImage, JCS_RGB);

        }
    }

}
#endif

int RunOrVoidEngine(int TimeDirection, TRAIMPLOBJ * Engines, TRAOBJ * SlS, TRAOBJ *Sat, 
                     long long &CurentTimeSec, int &CurentTimeTD, int &CurentIteraPerSec, double StartTimeSec)
{
    int iRet = 0;
    int i,j;
    double SecCalc;
    double DTempo;
    for(i = 0; i < Sat->Elem; i++)
    {
        if (Sat->flInUse)
        {
            for (j = 0; j < EnginesCount; j++)
            {
                if (Engines[j].iEngineOnSatellite == i)
                {
                    if (Engines[j].EngineDone == 0)
                    {
                        if (Engines[j].EngineOn)
                        {
                            // engine is ON
                            iRet = 1;
                            if ((Engines[j].ImplsPointer) < Engines[j].iLine)
                            {
                                FireEngine(1,Engines[j].ImplsPointer, &Engines[j], Sat, i, Engines[j].XVec, Engines[j].YVec, Engines[j].ZVec);
                                double VX = Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[EARTH];
                                double VY = Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[EARTH];
                                double VZ = Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[EARTH];
                                DTempo = sqrt(VX*VX+VY*VY+VZ*VX);
                                
                                VX = Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[MOON];
                                VY = Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[MOON];
                                VZ = Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[MOON];
                                DTempo = sqrt(VX*VX+VY*VY+VZ*VZ);
                                if (j ==4)
                                    printf("\n velocity = %f ", DTempo);
                                double X = Sat->X[Engines[j].iEngineOnSatellite] - SlS->X[MOON];
                                double Y = Sat->Y[Engines[j].iEngineOnSatellite] - SlS->Y[MOON];
                                double Z = Sat->Z[Engines[j].iEngineOnSatellite] - SlS->Z[MOON];
                                DTempo = sqrt(X*X+Y*Y+Z*Z);
                                if (j ==4)
                                    printf(" distance = %f ", DTempo- GetRadius(SlS, MOON, Sat, Engines[j].iEngineOnSatellite));

                            }
                            if ((++(Engines[j].ImplsPointer)) >= Engines[j].iLine)
                            {
                                if (Engines[j].ImplsPointer % Engines[j].IteraPerSec ==0)
                                {
                                    printf("\n cutoff engine=====> %d at= %f",j,Engines[j].FireTime+Engines[j].DeltaTime*Engines[j].iLine);
                                    // engine done
                                    iRet = 0;
                                    Engines[j].EngineDone = 1;
                                    Engines[j].iCountApogPerig = 0;
                                    SlS->TimeSl = SlS->TimeSlOld;
                                    CurentTimeSec = OldCurentTimeSec + Engines[j].ImplsPointer / Engines[j].IteraPerSec;
                                    CurentTimeTD = OldCurentTimeTD;
                                    CurentIteraPerSec = OldCurentIteraPerSec;
                                }
                            }
                        }
                        else
                        {
                            // skip firing engines which we are not interesting
                            if (j > LastEngine)
                                continue;
                            // engine is OFF
                            // SecCalc = CurentTimeSec * CurentIteraPerSec + CurentTimeTD;
                            SecCalc = ((double)CurentTimeSec) + ((double)CurentTimeTD) / ((double)CurentIteraPerSec);
                            if ((Engines[j].FireTime) <= SecCalc)
                            {
								unsigned char EngineColor[3]= {255,0,0};
								double X1 = Sat->X[j] - SolarSystem.X[EARTH];
								double Y1 = Sat->Y[j] - SolarSystem.Y[EARTH];
								double Z1 = Sat->Z[j] - SolarSystem.Z[EARTH];
								double X2;
								double Y2;
#ifdef _DO_VISUALIZATION
								switch(iProfile)
								{
									case 0: X2 = X1; Y2 = Y1;break; 
									case 1: X2 = Y1; Y2 = Z1;break; 
									case 2: X2 = X1; Y2 = Z1;break; 
									case 3: X2 = -Y1; Y2 = Z1;break;
									case 4: X2 = -X1; Y2 = Z1;break;
									case 5: X2 = -X1; Y2 = Y1;break; 
									default: break;
								}
								if (-dRGBScale < X2  && X2 < dRGBScale)
								{
									if (((-dRGBScale * bRGBImageH/ bRGBImageW) < Y2)  && Y2 < ((dRGBScale* bRGBImageH/ bRGBImageW)))
									{
										putpixel(&EngineColor[i*3], (int)(X2/dRGBScale*bRGBImageH), (int)(Y2/dRGBScale*bRGBImageH));
									}
								}
#endif
								printf("\n fire engine=====> %d at= %f",j,Engines[j].FireTime);
                                iRet = 1;
                                Engines[j].EngineOn = 1;
                                Engines[j].ImplsPointer = 0;
                                SlS->TimeSlOld = SlS->TimeSl;
                                SlS->TimeSl = Engines[j].DeltaTime;
                                OldCurentTimeSec = CurentTimeSec;
                                OldCurentTimeTD = CurentTimeTD;
                                OldCurentIteraPerSec = CurentIteraPerSec;
                                CurentTimeTD = 0;
                                CurentIteraPerSec = Engines[j].IteraPerSec;

                                // for now engine fire just in direction of a velocity around nearbody
                                double VX = Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[Engines[j].AngleOnBody];
                                double VY = Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[Engines[j].AngleOnBody];
                                double VZ = Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[Engines[j].AngleOnBody];
                                DTempo = sqrt(VX*VX+VY*VY+VZ*VX);
								// setting both vectors to 1.0 will fire engine in direction
								// ortogonal vector (not in direction of velocity)
								//if ((Engines[j].Ang1 == 1.0) && (Engines[j].Ang2 == 1.0))
                                if (Engines[j].AngleType == 4) // 4 - same direction as vector of velocity to nearbody // this is a brake impulse to land on the moon
                                {
                                    Engines[j].XVec = (Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[Engines[j].AngleOnBody]);
                                    Engines[j].YVec = (Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[Engines[j].AngleOnBody]);
                                    Engines[j].ZVec = (Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[Engines[j].AngleOnBody]);

                                }
                                if (Engines[j].AngleType == 3) // 3 - oposit vector of velocity
                                {
                                    Engines[j].XVec = -(Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[Engines[j].AngleOnBody]);
                                    Engines[j].YVec = -(Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[Engines[j].AngleOnBody]);
                                    Engines[j].ZVec = -(Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[Engines[j].AngleOnBody]);
                                }
                                if (Engines[j].AngleType == 0) // 0 - tangent line to orbit (elipse) oposit velocity  to nearbody
                                {
                                    //Engines[j].XVec = -VX;
                                    //Engines[j].YVec = -VY;
                                    //Engines[j].ZVec = -VZ;
                                    // equation of a plane perpendicular to a vector from center of earth to setelite
                                    // first calculates radius vector (R=(Xs,Ys,Zs)) of a satellite's point reletive to earth (P=(Xs,Yx,Zs))
                                    double Xs = Sat->X[Engines[j].iEngineOnSatellite] - SlS->X[Engines[j].AngleOnBody];
                                    double Ys = Sat->Y[Engines[j].iEngineOnSatellite] - SlS->Y[Engines[j].AngleOnBody];
                                    double Zs = Sat->Z[Engines[j].iEngineOnSatellite] - SlS->Z[Engines[j].AngleOnBody];
                                    // N = (A,B,C) is a normal to a plane (the needs to be in same direction of a radius vector)
                                    DTempo = sqrt(Xs*Xs+Ys*Ys+Zs*Zs);
                                    double Xn = Xs/DTempo;
                                    double Yn = Ys/DTempo;
                                    double Zn = Zs/DTempo;
                                    // PLane : A*(x-Xs) + B*(y-Ys) + C*(z-Zs) = 0
                                    // or Xn*(x-Xs) + Yn*(y-Ys) + Zn*(z-Zs) = 0
                                    // vector (Q=(Xq,Yq,Zq)) perpendicular to R and starting point is P, 4 equation:
                                    //(1)  (x - x1)(y2-y1) = (x2-x1)(y-y1) 
                                    //(2)  (y - y1)(z2-z1) = (y2-y1)(z-z1)
                                    //(3)  (z - z1)(x2-x1) = (z2-z1)(x-x1)
                                    //(4)  Xn*(x-Xs) + Yn*(y-Ys) + Zn*(z-Zs) = 0
                                    // for calculations:
                                    // first calculate 2 vector M1 and M2 ortogonal X and VX
                                    // (1) Xs*XM + Ys*YM + Zs*ZM = 0 => ZM = - (Xs*XM + Ys*YM)/ Zs
                                    // 
                                    // (2) VX*XM + VY*YM + VZ*ZM = 0 => VY*YM = - (VX*XM +VZ*ZM) => VY*YM = - (VX*XM -VZ*(Xs*XM + Ys*YM)/ Zs)
                                    // VY*YM = - ((VX*XM*Zs/Zs -VZ*(Xs*XM + Ys*YM)/ Zs)) => VY*YM = - (VX*XM*Zs -VZ*(Xs*XM + Ys*YM))/ Zs => VY*YM = - (VX*XM*Zs - VZ*Xs*XM - VZ*Ys*YM)/ Zs =>
                                    // VY*YM = - (VX*XM*Zs - VZ*Xs*XM)/ Zs + VZ*Ys*YM/ Zs => VY*YM - VZ*Ys*YM/ Zs = - (VX*XM*Zs - VZ*Xs*XM)/ Zs => YM*(VY*Zs - VZ*Ys)/ Zs = - (VX*XM*Zs - VZ*Xs*XM)/ Zs
                                    // YM*(VY*Zs - VZ*Ys) = - (VX*XM*Zs - VZ*Xs*XM) = > YM = - (VX*XM*Zs - VZ*Xs*XM)/(VY*Zs - VZ*Ys) => YM = - XM * (VX*Zs - VZ*Xs)/(VY*Zs - VZ*Ys)
                                    double XM =  1.0;
                                    double YM = - XM * (VX*Zs - VZ*Xs)/(VY*Zs - VZ*Ys);
                                    double ZM = - (Xs*XM + Ys*YM)/ Zs;
                                    // second calcualtes 2 vectors D1 D2 ortogonal to X and M1
                                    // (3) Xs*Xd + Ys*Yd + Zs*Zd = 0 => Zd = - (Xs*Xd + Ys*Yd)/Zs 
                                    //
                                    // (4) XM*Xd + YM*Yd + ZM*Zd = 0 => YM*Yd = -(XM*Xd + ZM*Zd) => YM*Yd = -(XM*Xd - ZM*(Xs*Xd + Ys*Yd)/Zs) => YM*Yd = -(XM*Xd*Zs - ZM*Xs*Xd - ZM*Ys*Yd)/Zs =>
                                    // YM*Yd = -(XM*Xd*Zs - ZM*Xs*Xd)/Zs + ZM*Ys*Yd/Zs => YM*Yd - ZM*Ys*Yd/Zs = -(XM*Xd*Zs - ZM*Xs*Xd)/Zs => Yd*(YM*Zs/Zs - ZM*Ys/Zs) = -(XM*Xd*Zs - ZM*Xs*Xd)/Zs
                                    // Yd*(YM*Zs - ZM*Ys) = -(XM*Xd*Zs - ZM*Xs*Xd) => Yd = -(XM*Xd*Zs - ZM*Xs*Xd)/(YM*Zs - ZM*Ys) => Yd = -Xd*(XM*Zs - ZM*Xs)/(YM*Zs - ZM*Ys)
                                    double Xd1 =  1.0;
                                    double Yd1 = -Xd1*(XM*Zs - ZM*Xs)/(YM*Zs - ZM*Ys);
                                    double Zd1 = - (Xs*Xd1 + Ys*Yd1)/Zs ;
                                    double Xd2 =  -1.0;
                                    double Yd2 = -Xd2*(XM*Zs - ZM*Xs)/(YM*Zs - ZM*Ys);
                                    double Zd2 = - (Xs*Xd2 + Ys*Yd2)/Zs ;
                                    // conformation: D and X are ortogonal and M and D is ortogonal
                                    DTempo = sqrt(Xs*Xd1+Ys*Yd1+Zs*Zd1);
                                    DTempo = sqrt(Xs*Xd2+Ys*Yd2+Zs*Zd2);
                                    DTempo = sqrt(Xs*XM+Ys*YM+Zs*ZM);
                                    // calculation - which of a vectors D1 or D2 close to vector of velocity
                                    // cos(alfa) = ( (x2 -x1)(x4-x3) + (y2-y1)(y4-y3) + (z2-z1)(z4-z3) )/ ( sqrt( (x2-x1)^2 + (y2-y1)^2 +(z2-z1)^2 )*sqrt( (x4-x3)^2 + (y4-y3)^2 +(z4-z3)^2 )
                                    double cosAlfa1 = (Xd1*VX + Yd1*VY + Zd1*VZ) / sqrt(Xd1*Xd1 + Yd1*Yd1+ Zd1*Zd1) / sqrt(VX*VX + VY*VY +VZ*VZ);
                                    double cosAlfa2 = (Xd2*VX + Yd2*VY + Zd2*VZ) / sqrt(Xd2*Xd2 + Yd2*Yd2+ Zd2*Zd2) / sqrt(VX*VX + VY*VY +VZ*VZ);

                                    if (cosAlfa1 < cosAlfa2)
                                    {
                                        Engines[j].XVec = -Xd2;
                                        Engines[j].YVec = -Yd2;
                                        Engines[j].ZVec = -Zd2;
                                    }
                                    else
                                    {
                                        Engines[j].XVec = -Xd1;
                                        Engines[j].YVec = -Yd1;
                                        Engines[j].ZVec = -Zd1;
                                    }
                                    if (j==4) // for a brake impulse into a vector of velociti around moon
                                    {
                                        //Engines[j].XVec = -(Sat->X[Engines[j].iEngineOnSatellite] - SlS->X[MOON]);
                                        //Engines[j].YVec = -(Sat->Y[Engines[j].iEngineOnSatellite] - SlS->Y[MOON]);
                                        //Engines[j].ZVec = -(Sat->Z[Engines[j].iEngineOnSatellite] - SlS->Z[MOON]);

                                        Engines[j].XVec = (Sat->VX[Engines[j].iEngineOnSatellite] - SlS->VX[MOON]);
                                        Engines[j].YVec = (Sat->VY[Engines[j].iEngineOnSatellite] - SlS->VY[MOON]);
                                        Engines[j].ZVec = (Sat->VZ[Engines[j].iEngineOnSatellite] - SlS->VZ[MOON]);
                                    }
                                }
								//else if ((Engines[j].Ang1 != 0.0) && (Engines[j].Ang2 != 0.0))
                                else if (Engines[j].AngleType == 1) // 1 - two angles set with reference to NearBody centre direction
								{
								}
                                else if (Engines[j].AngleType == 2) // 2 - three angles set vector fire (constant all fire time) 
								{
									//Engines[j].XVec = 8;
                                    //Engines[j].YVec = 0;
                                    //Engines[j].ZVec = -16;
                                    Engines[j].XVec = Engines[j].XVec;
                                    Engines[j].YVec = Engines[j].YVec;
                                    Engines[j].ZVec = Engines[j].ZVec;
								}

                            }
                        }
                    }
                }
            }
        }
    }
    return (iRet);
}


long double TimeSlOld = 0;//0.01;

#define CALC_SOLAR_SYSTEM 1
void AssignFromNASAData(TRAOBJ * SlS, double JDSec)
{
    double aproxim;
    //double RBarisMoon;
    //double RBarisEarth;
    //double VEarthOrbit;
    //double VMoonOrbit;
    //double VDelta;
    double Temp0;
    double Temp1;
    double Temp2;
    double Temp3;
    double Temp4;

    stateType  State;
    double dEMRAT = Find_DataInHeader("EMRAT ");
    double dAU = Find_DataInHeader("AU    ")*1000.0;
	// store
	AU = dAU;
    SlS->Elem = 11;
    aproxim = 0.58782958984375;
    aproxim = 1.0;
    aproxim = 1.0;//1.0496393116944882060883002708885;
#define PlanetsCount SlS->Elem
//#define PlanetsCount PLANET_COUNT
    for (int i = 0; i < PlanetsCount; i++)
    {
        SlS->flInUse[i] = 1;        
        for (int j = 0; j < PlanetsCount; j++)
        {
            SlS->Distance2[i][j] = 0.0;
        }
        Interpolate_State( JDSec , i , &State );
        SlS->X[i] = State.Position[0]*1000.0;
        SlS->Y[i] = State.Position[1]*1000.0;
        SlS->Z[i] = State.Position[2]*1000.0;
        SlS->VX[i] = State.Velocity[0]*1000.0;
        SlS->VY[i] = State.Velocity[1]*1000.0;
        SlS->VZ[i] = State.Velocity[2]*1000.0;
        switch(i)
        {
        case 0: SlS->GM[i] = Find_DataInHeader("GM1   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 1: SlS->GM[i] = Find_DataInHeader("GM2   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 2: SlS->GM[i] = Find_DataInHeader("GMB   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);//*(dEMRAT)/(dEMRAT+1.0);
            SlS->GM[i] *=(dEMRAT)/(dEMRAT+1); 
            SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 3: SlS->GM[i] = Find_DataInHeader("GM4   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 4: SlS->GM[i] = Find_DataInHeader("GM5   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 5: SlS->GM[i] = Find_DataInHeader("GM6   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 6: SlS->GM[i] = Find_DataInHeader("GM7   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 7: SlS->GM[i] = Find_DataInHeader("GM8   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 8: SlS->GM[i] = Find_DataInHeader("GM9   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);SlS->M[i] = SlS->GM[i]/Gbig;break;
        case 9: SlS->GM[i] = Find_DataInHeader("GMB   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);
            SlS->GM[i] /=(dEMRAT+1); 
            SlS->M[i] = SlS->GM[i]/Gbig;
            {
                double BSX = SlS->X[EARTH];
                double BSY = SlS->Y[EARTH];
                double BSZ = SlS->Z[EARTH];
                double BSVX = SlS->VX[EARTH];
                double BSVY = SlS->VY[EARTH];
                double BSVZ = SlS->VZ[EARTH];
#if 0
                SlS->X[i] += SlS->X[EARTH];
                SlS->Y[i] += SlS->Y[EARTH];
                SlS->Z[i] += SlS->Z[EARTH];
                SlS->VX[i] += SlS->VX[EARTH];
                SlS->VY[i] += SlS->VY[EARTH];
                SlS->VZ[i] += SlS->VZ[EARTH];
#else
                SlS->X[EARTH] = BSX - (SlS->X[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                SlS->Y[EARTH] = BSY - (SlS->Y[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                SlS->Z[EARTH] = BSZ - (SlS->Z[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                Temp4 = sqrt(
                                (SlS->X[9])*(SlS->X[9])+
                                (SlS->Y[9])*(SlS->Y[9])+
                                (SlS->Z[9])*(SlS->Z[9])
                                );
                printf("\n D Earth - Moon %f ", Temp4);
                Temp1 = sqrt(
                                ((SlS->X[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9])))*
                                ((SlS->X[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9]))) +
                                ((SlS->Y[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9])))*
                                ((SlS->Y[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9]))) +
                                ((SlS->Z[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9])))*
                                ((SlS->Z[9]*SlS->M[2]/(SlS->M[2]+SlS->M[9])))
                                );

                 printf("\n D BC  - Moon %f ", Temp1);
                 Temp1 = sqrt(
                                SlS->GM[2] / Temp1
                                );

                 Temp2 = sqrt(
                                (SlS->VX[9])*(SlS->VX[9])+
                                (SlS->VY[9])*(SlS->VY[9])+
                                (SlS->VZ[9])*(SlS->VZ[9])
                                );
                 Temp3 = Find_DataInHeader("GMB   ")*dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0);
                 SlS->X[MOON] = SlS->X[EARTH] + SlS->X[MOON];
                 SlS->Y[MOON] = SlS->Y[EARTH] + SlS->Y[MOON];
                 SlS->Z[MOON] = SlS->Z[EARTH] + SlS->Z[MOON];

                 SlS->VX[EARTH] = BSVX - /*aproxim**/(SlS->VX[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                 SlS->VY[EARTH] = BSVY - /*aproxim**/(SlS->VY[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                 SlS->VZ[EARTH] = BSVZ - /*aproxim**/(SlS->VZ[MOON]/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                 Temp0 = (/*aproxim**/(SlS->VX[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON])))*
                                (/*aproxim**/(SlS->VX[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]))) +
                                (/*aproxim**/(SlS->VY[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON])))*
                                (/*aproxim**/(SlS->VY[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]))) +
                                (/*aproxim**/(SlS->VZ[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON])))*
                                (/*aproxim**/(SlS->VZ[MOON]*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON])));
                 SlS->VX[MOON] = SlS->VX[EARTH] + SlS->VX[MOON];
                 SlS->VY[MOON] = SlS->VY[EARTH] + SlS->VY[MOON];
                 SlS->VZ[MOON] = SlS->VZ[EARTH] + SlS->VZ[MOON];
#endif
            }
            break;
        case 10: SlS->GM[i] = Find_DataInHeader("GMS   ") *dAU*dAU*dAU/(24.0*60.0*60.0*24.0*60.0*60.0); SlS->M[i] = SlS->GM[i]/Gbig;break;
        }
    }

    printf("\n Earth velocity =%f", sqrt(Temp0));
    printf("\n Moon sqrt =%f", Temp1);
    printf("\n Moon velocity N =%f", Temp2);

    // this is done to reduce errors and avid unnessary 5 mul/div operations
    // temporary X_, VX_ will just added (in paralel can be done actualy) 
    SlS->TimeSl = TimeSl;
    SlS->TimeSl_2 = TimeSl*TimeSl;
    for (int i = 0; i <SlS->Elem; i++)
    {
        SlS->VX_[i] = 0;
        SlS->VY_[i] = 0;
        SlS->VZ_[i] = 0;

        SlS->X_[i] = 0;
        SlS->Y_[i] = 0;
        SlS->Z_[i] = 0;

        SlS->X0divDt2[i]=SlS->X[i]* SlS->M[i] /SlS->TimeSl_2;
        SlS->Y0divDt2[i]=SlS->Y[i]* SlS->M[i] /SlS->TimeSl_2;
        SlS->Z0divDt2[i]=SlS->Z[i]* SlS->M[i] /SlS->TimeSl_2;

        SlS->VX0divDt[i]=SlS->VX[i]* SlS->M[i] /SlS->TimeSl;
        SlS->VY0divDt[i]=SlS->VY[i]* SlS->M[i] /SlS->TimeSl;
        SlS->VZ0divDt[i]=SlS->VZ[i]* SlS->M[i] /SlS->TimeSl;

        for (int j = 0; j < SlS->Elem; j++)
        {
            SlS->GMxM[i][j] = SlS->GM[i]*SlS->M[j];
        }
    }
    SlS->CountNx = 0; SlS->CountNy = 0; SlS->CountNz = 0;
    SlS->RunOne = TRUE;
}
void SGP4(long double TSINCE, long double nuXNDT2O, long double nuXNDD6O,long double BSTAR, long double XINCL,
          long double XNODEO, long double EO, long double OMEGAO,long double XMO, long double XNO,
		  long double &X,long double &Y,long double &Z,long double &XDOT,long double &YDOT,long double &ZDOT);

void SGP8(long double TSINCE, long double nuXNDT2O, long double nuXNDD6O,long double BSTAR, long double XINCL,
          long double XNODEO, long double EO, long double OMEGAO,long double XMO, long double XNO,
		  long double &X,long double &Y,long double &Z,long double &XDOT,long double &YDOT,long double &ZDOT);

void SGP(long double TS, long double XNDT2O,long double XNDD6O,long double nuBSTAR,long double XINCL, long double XNODEO,long double EO, long double OMEGAO, long double XMO, long double XNO, 
	long double &X,long double &Y,long double &Z,long double &XDOT,long double &YDOT,long double &ZDOT);

void KeplerPosition(long double SatEpoch, long double CurTime, long double T,long double Ecc, long double Incl, long double AssNode, long double ArgPer, long double MeanAnm, long double BSTAR, long double GM, int doCorrection, 
                    long double &Xm, long double &Ym, long double &Zm, long double &VX, long double &VY, long double &VZ, long double ProbMeanMotion);

#define _USE_ORIGINAL 1
void AssignAllSatelites(TRAOBJ * SlS, int iBody, TRAOBJ * sat, double JDSec)
{
    long double tempProbX;
    long double tempProbY;
    long double tempProbZ;
    long double tempProbVX;
    long double tempProbVY;
    long double tempProbVZ;

    long double tProbX=0.;
    long double tProbY=0.;
    long double tProbZ=0.;
    long double tProbVX=0.;
    long double tProbVY=0.;
    long double tProbVZ=0.;

    for (int nSat = 0; nSat <sat->Elem; nSat++)
    {
        long double AE = 1.0;
        long double BSTAR=sat->ProbDragterm[nSat]/AE;
                
        if ( memcmp(UseSatData, "SGP",3)==0)
        {

            //Sat.ProbEpochOnStart[nSat] =fmod(dStartJD - Sat.ProbJD[nSat],1.0/Sat.ProbMeanMotion[nSat]);

#if _USE_ORIGINAL
	        long double XKMPER = 6378.1350;//XKMPER kilometers/Earth radii 6378.135
#else
	        long double XKMPER = 6378.137;
#endif
			//long double XKE = BIG_XKE;//.743669161E-1;
            //XKE = sqrt(Gbig * SolarSystem.M[EARTH])*pow(AE/*(long double)6378.1350*//(long double)1440.0, (long double)3.0/(long double)2.0);;
			//long double XJ2 = 1.082616E-3;
			//long double CK2=.5*XJ2*AE*AE;
			//double XMNPDA = 1440.0;
			//double TEMP=2.0*M_PI/XMNPDA/XMNPDA;
			//double XNO=ProbMeanMotion*TEMP*XMNPDA;
            long double XMNPDA = 1440.0; // XMNPDA time units(minutes) in day is 1440.0 minutes
	        long double TEMP=2*M_PI/XMNPDA/XMNPDA; // 2*pi / (1440 **2)
		    long double XNO=sat->ProbMeanMotion[nSat]*TEMP*XMNPDA; // rotation per day * 2*pi /1440 == rotation per day on 1 unit (1 min)
            long double XNDT2O=sat->ProbFirstDervMeanMotion[nSat]*TEMP;
            long double XNDD6O=sat->ProbSecondDervmeanMotion[nSat]*TEMP/XMNPDA;
            /*
            long double A1=pow((XKE/XNO),(long double)2.0/(long double)3.0);
            TEMP=1.5*CK2*(3.*cos(Sat.ProbIncl[nSat])*cos(ProbIncl)-1.)/pow((1.-Sat.ProbEcc[nSat]*Sat.ProbEcc[nSat]),(long double)1.5);
            long double DEL1=TEMP/(A1*A1);
            long double AO=A1*(1.-DEL1*(.5*(2.0/3.0)+DEL1*(1.+134./81.*DEL1)));
            long double DELO=TEMP/(AO*AO);
            long double XNODP=XNO/(1.+DELO);
            //IF((TWOPI/XNODP/XMNPDA) .GE. .15625) IDEEP=1
            */

            //TSINCE=TS
            //IFLAG=1
            // first one does not use BSTAR
            //SGP((Sat.ProbEpochOnStart[nSat])*XMNPDA, XNDT2O,XNDD6O,BSTAR,Sat.ProbIncl[nSat], Sat.ProbAscNode[nSat],Sat.ProbEcc[nSat], 
            //               Sat.ProbArgPer[nSat], Sat.ProbMeanAnom[nSat],XNO, 
            //	tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
            //tProbX=tProbX*XKMPER/AE*1000.0;
            //tProbY=tProbY*XKMPER/AE*1000.0;
            //tProbZ=tProbZ*XKMPER/AE*1000.0;
            //tProbVX=tProbVX*XKMPER/AE*XMNPDA/86400.*1000.0;
            //tProbVY=tProbVY*XKMPER/AE*XMNPDA/86400.*1000.0;
            //tProbVZ=tProbVZ*XKMPER/AE*XMNPDA/86400.*1000.0;
            // second one does not use XNDT2O,XNDD6O
            // in next call XN0 and ProbMeanMotion connected by a formula:
            // Sat.ProbMeanMotion[nSat] = XNO / (2*pi) * 1440.0
            if (memcmp(UseSatData, "SGP4",4)==0)
                SGP4((JDSec - sat->ProbJD[nSat])*XMNPDA, XNDT2O,XNDD6O,BSTAR,sat->ProbIncl[nSat], sat->ProbAscNode[nSat],sat->ProbEcc[nSat], 
                     sat->ProbArgPer[nSat], sat->ProbMeanAnom[nSat],XNO, 
                     tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
            else if (memcmp(UseSatData, "SGP8",4)==0)
                SGP8((JDSec - sat->ProbJD[nSat])*XMNPDA, XNDT2O,XNDD6O,BSTAR,sat->ProbIncl[nSat], sat->ProbAscNode[nSat],sat->ProbEcc[nSat], 
                     sat->ProbArgPer[nSat], sat->ProbMeanAnom[nSat],XNO, 
                     tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
            else if (memcmp(UseSatData, "SGP",3)==0)
                SGP((JDSec - sat->ProbJD[nSat])*XMNPDA, XNDT2O,XNDD6O,BSTAR,sat->ProbIncl[nSat], sat->ProbAscNode[nSat],sat->ProbEcc[nSat], 
                    sat->ProbArgPer[nSat], sat->ProbMeanAnom[nSat],XNO, 
                    tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
            else
            {
                printf("\n error in UseSatData == unknown value");
                exit(99);
            }
            tProbX=tProbX*XKMPER/AE*1000.0;                  tProbY=tProbY*XKMPER/AE*1000.0;                 tProbZ=tProbZ*XKMPER/AE*1000.0;
            tProbVX=tProbVX*XKMPER/AE*XMNPDA/86400.*1000.0;  tProbVY=tProbVY*XKMPER/AE*XMNPDA/86400.*1000.0; tProbVZ=tProbVZ*XKMPER/AE*XMNPDA/86400.*1000.0;
            // SGP4
            sat->X[nSat] = tProbX + SlS->X[iBody];
            sat->Y[nSat] = tProbY + SlS->Y[iBody];
            sat->Z[nSat] = tProbZ + SlS->Z[iBody];
            sat->VX[nSat] = tProbVX + SlS->VX[iBody];
            sat->VY[nSat] = tProbVY + SlS->VY[iBody];
            sat->VZ[nSat] = tProbVZ + SlS->VZ[iBody];
        }
        else // Kepler
        {
            KeplerPosition(sat->ProbJD[nSat],JDSec,      // prob epoch, and curent time
                sat->ProbTSec[nSat], // - orbit period in sec
                sat->ProbEcc[nSat],             // - Eccentricity
                sat->ProbIncl[nSat],            // - Inclination
                sat->ProbAscNode[nSat],         // - Longitude of ascending node
                sat->ProbArgPer[nSat],          // - Argument of perihelion
                sat->ProbMeanAnom[nSat],        // - Mean Anomaly (degrees)
                BSTAR,
                Gbig *SolarSystem.M[EARTH],1,
                tempProbX,tempProbY,tempProbZ,tempProbVX,tempProbVY,tempProbVZ, sat->ProbMeanMotion[nSat]);
            //Sat.Lambda = dStartGreenwichA;
            //Sat.Lambda  = M_PI * 15.0 / 8.0; //3.0 / 8.0; 11.0 / 8.0;
            //Sat.M[0] = ProbM;
            sat->X[nSat] = tempProbX + SlS->X[iBody];
            sat->Y[nSat] = tempProbY + SlS->Y[iBody];
            sat->Z[nSat] = tempProbZ + SlS->Z[iBody];
            sat->VX[nSat] = tempProbVX + SlS->VX[iBody];
            sat->VY[nSat] = tempProbVY + SlS->VY[iBody];
            sat->VZ[nSat] = tempProbVZ + SlS->VZ[iBody];

            long double tProbTSec = 0;
            long double tProbEcc = 0;
            long double tProbIncl = 0;
            long double tProbAscNode = 0;
            long double tProbArgPer = 0;
            long double tProbMeanAnom = 0;

            /*
            //long double e_ecc = Sat.ProbEcc[nSat];
            //long double e_incl = Sat.ProbIncl[nSat];
            //long double e_asc_node = Sat.ProbAscNode[nSat];
            //long double e_arg_per = Sat.ProbArgPer[nSat];
            //long double e_mean_anomaly = Sat.ProbMeanAnom[nSat];
            long double e_q=0.0;
            long double e_major_axis=0.0;
            long double e_t0=0.0;
            long double e_w0=0.0;
            long double e_angular_momentum=0.0;
            long double e_perih_time=0.0;
            long double e_minor_to_major=0.0;
            long double e_lon_per=0.0;
            long double e_sideways_x=0.0;
            long double e_sideways_y=0.0;
            long double e_sideways_z=0.0;
            long double vec_x=0.0;
            long double vec_y=0.0;
            long double vec_z=0.0;
            long double e_perih_vec_x=0.0,e_perih_vec_y=0.0,e_perih_vec_z=0.0;
            long double loc_x=0.0, loc_y=0.0, loc_z=0.0, loc_r=0.0,vel_x=0.0,vel_y=0.0,vel_z=0.0,t=0.0;
            // first (mass) from NASA and second is just convinient constant
            long double gm = SolarSystem.M[EARTH] * Gbig;
            long double e_epoch = Sat.ProbEpoch[Sat.Elem]*24.0*60.0*60.0;
            do_element_setup( e_epoch, Sat.ProbEcc[nSat], Sat.ProbIncl[nSat], Sat.ProbAscNode[nSat], Sat.ProbArgPer[nSat],Sat.ProbMeanAnom[nSat],
                              e_q, e_major_axis,e_t0,e_w0,e_angular_momentum,e_perih_time,
                              e_minor_to_major, e_lon_per,
                              e_sideways_x, e_sideways_y, e_sideways_z,
                              vec_x, vec_y,vec_z, gm, Sat.ProbTSec[Sat.Elem]);
            // this will reset mean anomaly to time == dStartJD*24.0*60.0*60.0
            posn_and_vel( e_epoch, Sat.ProbEcc[nSat], Sat.ProbIncl[nSat], Sat.ProbAscNode[nSat], Sat.ProbArgPer[nSat],Sat.ProbMeanAnom[nSat],
                        e_q, e_major_axis,e_t0,e_w0,e_angular_momentum,e_perih_time,
                        e_minor_to_major, e_lon_per,
                        e_sideways_x, e_sideways_y, e_sideways_z,
                        vec_x,vec_y,vec_z,
                        loc_x, loc_y, loc_z, loc_r,vel_x,vel_y,vel_z,dStartJD*24.0*60.0*60.0, gm);
            */
            long double tVX = tempProbVX;
            long double tVY = tempProbVY;
            long double tVZ = tempProbVZ;
            // that is for debugging GPS sattelites only
#if 0
            
            //01234567890123456789012345678901234567890123456789012345678901234567890
            //1 25544U 98067A   04236.56031392  .00020137  00000-0  16538-3 0  5135\
            //2 25544  51.6335 341.7760 0007976 126.2523 325.9359 15.70406856328903"
            //    };
            // "ISS (ZARYA)"    The common name for the object based on information from the SatCat.
            // "1"              Line Number
            // "25544"          Object Identification Number
            // "U"              Elset Classification
            // "98067A"         International Designator
            //  98                   - designate the launch year of the object
            //    067                - launch number, starting from the beginning of the year
            //       A               - indicates the piece of the launch: "A" is a payload 
            // "04236.56031392" Element Set Epoch (UTC)
            //  04                   - year
            //    236.56031392       - day
            // "_.00020137"      1st Derivative of the Mean Motion with respect to Time
            // "_00000-0"        2nd Derivative of the Mean Motion with respect to Time (decimal point assumed)
            // "_16538-3"        B* Drag Term
            // "0"              Element Set Type
            // "_513"            Element Number
            // "5"              Checksum
            //                        The checksum is the sum of all of the character in the data line, modulo 10. 
            //                        In this formula, the following non-numeric characters are assigned the indicated values: 
            //                        Blanks, periods, letters, '+' signs -> 0
            //                        '-' signs -> 1
            // "2"             Line Number
            // "25544"         Object Identification Number
            // "_51.6335"       Orbit Inclination (degrees)
            // "341.7760"      Right Ascension of Ascending Node (degrees)
            // "0007976"       Eccentricity (decimal point assumed)
            // "126.2523"      Argument of Perigee (degrees)
            // "325.9359"      Mean Anomaly (degrees)
            // "15.70406856"    Mean Motion (revolutions/day)
            // "328903"        Revolution Number at Epoch

                              // NAVSTAR 54 (USA 177)
            // 1 28190U 04009A   12103.48551084  .00000032  00000-0  10000-3 0  3101
            // 2 28190 055.0111 121.3785 0080561 006.7787 353.3670 02.00552748 59113
            //
            //         orbit inclanation
            //                  Right Ascension of Ascending Node



            // testing GPS sattelite #0x13=19 on UTC= 492765.99999995105 week: 1683 time 16:52:46
            long double m1ProbTSec, m1ProbEcc, m1ProbIncl, m1ProbAscNode, m1ProbArgPer, m1ProbMeanAnom;
            long double m2ProbTSec, m2ProbEcc, m2ProbIncl, m2ProbAscNode, m2ProbArgPer, m2ProbMeanAnom;
            tProbX = -24891582.164414;
            tProbY = -6179787.716544;
            tProbZ = 7602393.375224;
            tProbVX = -760.24581128329362;
            tProbVY = -633.026865;
            tProbVZ = -2950.637702;
            DumpKeplers(m1ProbTSec, // - orbit period in sec
		    		    m1ProbEcc,             // - Eccentricity
                        m1ProbIncl,            // - Inclination
                        m1ProbAscNode,         // - Longitude of ascending node
                        m1ProbArgPer,          // - Argument of perihelion
                        m1ProbMeanAnom,        // - Mean Anomaly (degrees)
                        SolarSystem.M[EARTH],0.0,
                        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
            m1ProbIncl = m1ProbIncl / M_PI * 180;
            m1ProbAscNode = m1ProbAscNode / M_PI * 180;
            m1ProbArgPer = m1ProbArgPer / M_PI * 180;
            m1ProbMeanAnom = m1ProbMeanAnom / M_PI * 180;
            // tProbArgPer	6.0013685480087604	double 343.85308910345697
            // tProbAscNode	0.28308821186056238	double 16.219759769515520
            // tProbEcc	0.35006709180942119	double
            // tProbIncl	1.4375592933975376	double 82.366080311487735
            // tProbMeanAnom	3.1240698993743474	double 178.99602013800990
            // tProbTSec	27757.763563012952	double
            // testing GPS sattelite #13 on UTC= 492841.99999994022 (75.99999998917 sec later)
            tProbX = -24948509.734849;
            tProbY = -6227303.238357;
            tProbZ = 7377692.112397;
            tProbVX = -737.80818258029888;
            tProbVY = -617.413576;
            tProbVZ = -2962.493300;
            DumpKeplers(m2ProbTSec, // - orbit period in sec
				        m2ProbEcc,             // - Eccentricity
                        m2ProbIncl,            // - Inclination
                        m2ProbAscNode,         // - Longitude of ascending node
                        m2ProbArgPer,          // - Argument of perihelion
                        m2ProbMeanAnom,        // - Mean Anomaly (degrees)
                        SolarSystem.M[EARTH],0.0,
                        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
            m2ProbIncl = m2ProbIncl / M_PI * 180;
            m2ProbAscNode = m2ProbAscNode / M_PI * 180;
            m2ProbArgPer = m2ProbArgPer / M_PI * 180;
            m2ProbMeanAnom = m2ProbMeanAnom / M_PI * 180;
            
            // tProbArgPer	6.0101929578191724	double 344.35869054228738
            // tProbAscNode	0.28215312764826711	double 16.166183390661683
            // tProbEcc	0.34889965261994360	double
            // tProbIncl	1.4407074570581755	double 82.546456802458735
            // tProbMeanAnom	3.1243871650157362	double 179.01419812024599
            // tProbTSec	27795.543500545853	double
            // position and Keplers does not match == something wrong - also wrong inclanation that sattelite must be 55 degree
#endif
#if 0
            // mean amomaly on curent time
            DumpKeplers(tProbTSec, // - orbit period in sec
		    		    tProbEcc,             // - Eccentricity
                        tProbIncl,            // - Inclination
                        tProbAscNode,         // - Longitude of ascending node
                        tProbArgPer,          // - Argument of perihelion
                        tProbMeanAnom,        // - Mean Anomaly (degrees)
                        SolarSystem.M[EARTH],0.0,
                        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
            tProbIncl = tProbIncl / M_PI * 180;
            tProbAscNode = tProbAscNode / M_PI * 180;
            tProbArgPer = tProbArgPer / M_PI * 180;
            tProbMeanAnom = tProbMeanAnom / M_PI * 180;
            // mean amomaly on curent time
            DumpKeplers(tProbTSec, // - orbit period in sec
				        tProbEcc,             // - Eccentricity
                        tProbIncl,            // - Inclination
                        tProbAscNode,         // - Longitude of ascending node
                        tProbArgPer,          // - Argument of perihelion
                        tProbMeanAnom,        // - Mean Anomaly (degrees)
                        SolarSystem.M[EARTH],0.0,
                        tempProbX,tempProbY,tempProbZ,tempProbVX,tempProbVY,tempProbVZ);
            tProbIncl = tProbIncl / M_PI * 180;
            tProbAscNode = tProbAscNode / M_PI * 180;
            tProbArgPer = tProbArgPer / M_PI * 180;
            tProbMeanAnom = tProbMeanAnom / M_PI * 180;
            // mean amomaly on curent time
            /*DumpKeplers(tProbTSec, // - orbit period in sec
		    		    tProbEcc,             // - Eccentricity
                        tProbIncl,            // - Inclination
                        tProbAscNode,         // - Longitude of ascending node
                        tProbArgPer,          // - Argument of perihelion
                        tProbMeanAnom,        // - Mean Anomaly (degrees)
                        SolarSystem.M[EARTH],0.0,
                        tempProbX,tempProbY,tempProbZ,vel_x,vel_y,vel_z);
             tProbIncl = tProbIncl / M_PI * 180;
             tProbAscNode = tProbAscNode / M_PI * 180;
             tProbArgPer = tProbArgPer / M_PI * 180;
             tProbMeanAnom = tProbMeanAnom / M_PI * 180;
             
             long double VecAngle = AngleBtw(tempProbVX,tempProbVY,tempProbVZ,vel_x,vel_y,vel_z);
             printf("\n angle =%f",VecAngle);
             */
            //printf(" 
#endif
        }
        //printf("\n Was ProbPer = %f", ProbPer);
        //printf("\n Was ProbAph = %f", ProbAph);
        // for today only one sattelite
        //Sat.Elem = 1;
        sat->flInUse[nSat] = 1;
        sat->X[nSat] += sat->DX[nSat]; sat->Y[nSat] += sat->DY[nSat]; sat->Z[nSat] += sat->DZ[nSat];
        sat->VX[nSat] += sat->DVX[nSat]; sat->VY[nSat] += sat->DVY[nSat]; sat->VZ[nSat] += sat->DVZ[nSat];
    }
    // this is done to reduce errors and avoid unnessary 5 mul/div operations
    // temporary X_, VX_ will just added (in paralel calculations can be done actualy faster) 
    SlS->TimeSl = TimeSl;
    SlS->TimeSl_2= SlS->TimeSl*SlS->TimeSl;
    for (int i = 0; i <sat->Elem; i++)
    {
        sat->VX_[i] = 0;    sat->VY_[i] = 0;    sat->VZ_[i] = 0;
        sat->X_[i] = 0 ;    sat->Y_[i] = 0 ;    sat->Z_[i] = 0 ;
        
        sat->X0divDt2[i]=sat->X[i] /SlS->TimeSl_2;
        sat->Y0divDt2[i]=sat->Y[i] /SlS->TimeSl_2;
        sat->Z0divDt2[i]=sat->Z[i] /SlS->TimeSl_2;
        sat->VX0divDt[i]=sat->VX[i] /SlS->TimeSl;
        sat->VY0divDt[i]=sat->VY[i] /SlS->TimeSl;
        sat->VZ0divDt[i]=sat->VZ[i] /SlS->TimeSl;
        sat->iAtm[i] = 1;
    }
    sat->CountNx = 0; sat->CountNy = 0; sat->CountNz = 0;
    sat->RunOne = TRUE;
}
BOOL SwitchWas = FALSE;
long double OldTperiod;
long long SetiMayTimes;
LONG_DOUBLE_INT_VAR Store_velosity_sls[PLANET_COUNT];
LONG_DOUBLE_INT_VAR Store_position_sls[PLANET_COUNT];
LONG_DOUBLE_INT_VAR Store_velosity_sat[PLANET_COUNT];
LONG_DOUBLE_INT_VAR Store_position_sat[PLANET_COUNT];

long double Store_X0divDt2_sls[PLANET_COUNT];
long double Store_Y0divDt2_sls[PLANET_COUNT];
long double Store_Z0divDt2_sls[PLANET_COUNT];
long double Store_VX0divDt_sls[PLANET_COUNT];
long double Store_VY0divDt_sls[PLANET_COUNT];
long double Store_VZ0divDt_sls[PLANET_COUNT];

long double Store_X0divDt2_sat[PLANET_COUNT];
long double Store_Y0divDt2_sat[PLANET_COUNT];
long double Store_Z0divDt2_sat[PLANET_COUNT];
long double Store_VX0divDt_sat[PLANET_COUNT];
long double Store_VY0divDt_sat[PLANET_COUNT];
long double Store_VZ0divDt_sat[PLANET_COUNT];


BOOL SwitchCalcTimePeriod(TRAOBJ * SlS, TRAOBJ * sat, long long iMayTimes)
{
    int i;
    if (SwitchWas == TRUE)
        return FALSE;
    SwitchWas = TRUE;
    SetiMayTimes = iMayTimes;
    OldTperiod = SlS->TimeSl;
    long double OldTperiod2 = SlS->TimeSl_2;
    long double NewTimePeriod = OldTperiod / iMayTimes;
    SlS->TimeSl = NewTimePeriod;
    SlS->TimeSl_2 = NewTimePeriod*NewTimePeriod;
    sat->TimeSl = SlS->TimeSl;
    sat->TimeSl_2 = SlS->TimeSl_2;
    long double MayTimes2 = (long double)(iMayTimes * iMayTimes);

    for (i = 0; i <SlS->Elem; i++)
    {
        Store_X0divDt2_sls[i] = SlS->X0divDt2[i];  Store_Y0divDt2_sls[i] = SlS->Y0divDt2[i];   Store_Z0divDt2_sls[i] = SlS->Z0divDt2[i];
        Store_VX0divDt_sls[i] = SlS->VX0divDt[i];  Store_VY0divDt_sls[i] = SlS->VY0divDt[i];   Store_VZ0divDt_sls[i] = SlS->VZ0divDt[i];

        SlS->X0divDt2[i]=(MayTimes2 * SlS->X0divDt2[i]);
        SlS->Y0divDt2[i]=(MayTimes2 * SlS->Y0divDt2[i]);
        SlS->Z0divDt2[i]=(MayTimes2 * SlS->Z0divDt2[i]);

        SlS->VX0divDt[i]=((long double)iMayTimes*SlS->VX0divDt[i]);
        SlS->VY0divDt[i]=((long double)iMayTimes*SlS->VY0divDt[i]);
        SlS->VZ0divDt[i]=((long double)iMayTimes*SlS->VZ0divDt[i]);

#ifdef NO_SEPARATION_VEL_POS
        Store_position_sls[i].X0 = SlS->_position_[i].X0;  Store_position_sls[i].Y0 = SlS->_position_[i].Y0;  Store_position_sls[i].Z0 = SlS->_position_[i].Z0;
        SlS->_position_[i].X0 = (SlS->X0divDt2[i]+ SlS->VX0divDt[i])/SlS->M[i] ;
        SlS->_position_[i].Y0 = (SlS->Y0divDt2[i]+ SlS->VY0divDt[i])/SlS->M[i] ;
        SlS->_position_[i].Z0 = (SlS->Z0divDt2[i]+ SlS->VZ0divDt[i])/SlS->M[i] ;
#else
        Store_position_sls[i].X0 = SlS->_position_[i].X0;    Store_position_sls[i].Y0 = SlS->_position_[i].Y0;    Store_position_sls[i].Z0 = SlS->_position_[i].Z0;
        Store_position_sls[i].VX0 = SlS->_position_[i].VX0;  Store_position_sls[i].XY0 = SlS->_position_[i].VY0;  Store_position_sls[i].VZ0 = SlS->_position_[i].VZ0;
        SlS->_position_[i].X0 = SlS->X0divDt2[i]/SlS->M[i]; SlS->_position_[i].VX0 = SlS->VX0divDt[i]/SlS->M[i];
        SlS->_position_[i].Y0 = SlS->Y0divDt2[i]/SlS->M[i]; SlS->_position_[i].VY0 = SlS->VY0divDt[i]/SlS->M[i];
        SlS->_position_[i].Z0 = SlS->Z0divDt2[i]/SlS->M[i]; SlS->_position_[i].VZ0 = SlS->VZ0divDt[i]/SlS->M[i];
#endif
        Store_velosity_sls[i].X0 = SlS->_velosity_[i].X0;  Store_velosity_sls[i].Y0 = SlS->_velosity_[i].Y0;  Store_velosity_sls[i].Z0 = SlS->_velosity_[i].Z0;
        SlS->_velosity_[i].X0 = SlS->VX0divDt[i]/SlS->M[i] ;
        SlS->_velosity_[i].Y0 = SlS->VY0divDt[i]/SlS->M[i] ;
        SlS->_velosity_[i].Z0 = SlS->VZ0divDt[i]/SlS->M[i] ;
        SlS->_position_[i].nX0 *= iMayTimes;
        SlS->_velosity_[i].nX0 *= iMayTimes;
    }

    for (i = 0; i <sat->Elem; i++)
    {
        Store_X0divDt2_sat[i] = sat->X0divDt2[i];  Store_Y0divDt2_sat[i] = sat->Y0divDt2[i];   Store_Z0divDt2_sat[i] = sat->Z0divDt2[i];
        Store_VX0divDt_sat[i] = sat->VX0divDt[i];  Store_VY0divDt_sat[i] = sat->VY0divDt[i];   Store_VZ0divDt_sat[i] = sat->VZ0divDt[i];

        sat->X0divDt2[i] = (MayTimes2 * sat->X0divDt2[i]);
        sat->Y0divDt2[i] = (MayTimes2 * sat->Y0divDt2[i]);
        sat->Z0divDt2[i] = (MayTimes2 * sat->Z0divDt2[i]);

        sat->VX0divDt[i] = ((long double)iMayTimes * sat->VX0divDt[i]);
        sat->VY0divDt[i] = ((long double)iMayTimes * sat->VY0divDt[i]);
        sat->VZ0divDt[i] = ((long double)iMayTimes * sat->VZ0divDt[i]);
         
        //Sat->X[i] = (Sat->X[i]+ Sat->_velosity_[i].X0 *Sat->_velosity_[i].nX0)* SlS->TimeSl_2;   
        //Sat->Y[i] = (Sat->Y[i]+ Sat->_velosity_[i].Y0 *Sat->_velosity_[i].nX0)* SlS->TimeSl_2;   
        //Sat->Z[i] = (Sat->Z[i]+ Sat->_velosity_[i].Z0 *Sat->_velosity_[i].nX0)* SlS->TimeSl_2;
        //Sat->_velosity_[i].getIntegral(Sat->VX[i], Sat->VY[i], Sat->VZ[i]);
        //Sat->VX[i] *= SlS->TimeSl; Sat->VY[i] *= SlS->TimeSl; Sat->VZ[i] *= SlS->TimeSl;
#ifdef NO_SEPARATION_VEL_POS
        Store_position_sat[i].X0 = sat->_position_[i].X0;  Store_position_sat[i].Y0 = sat->_position_[i].Y0;  Store_position_sat[i].Z0 = sat->_position_[i].Z0;
        sat->_position_[i].X0 = sat->X0divDt2[i] + sat->VX0divDt[i];
        sat->_position_[i].Y0 = sat->Y0divDt2[i] + sat->VY0divDt[i];
        sat->_position_[i].Z0 = sat->Z0divDt2[i] + sat->VZ0divDt[i];
#else
        Store_position_sat[i].X0 = sat->_position_[i].X0;    Store_position_sat[i].Y0 = sat->_position_[i].Y0;    Store_position_sat[i].Z0 = sat->_position_[i].Z0;
        Store_position_sat[i].VX0 = sat->_position_[i].VX0;  Store_position_sat[i].XY0 = sat->_position_[i].VY0;  Store_position_sat[i].VZ0 = sat->_position_[i].VZ0;
        Sat->_position_[i].X0 = sat->X0divDt2[i]; Sat->_position_[i].VX0 = sat->VX0divDt[i];
        Sat->_position_[i].Y0 = sat->Y0divDt2[i]; Sat->_position_[i].VY0 = sat->VY0divDt[i];
        Sat->_position_[i].Z0 = sat->Z0divDt2[i]; Sat->_position_[i].VZ0 = sat->VZ0divDt[i];
#endif
        Store_velosity_sat[i].X0 = sat->_velosity_[i].X0;  Store_velosity_sat[i].Y0 = sat->_velosity_[i].Y0;  Store_velosity_sat[i].Z0 = sat->_velosity_[i].Z0;
        sat->_velosity_[i].X0 = sat->VX0divDt[i];
        sat->_velosity_[i].Y0 = sat->VY0divDt[i];
        sat->_velosity_[i].Z0 = sat->VZ0divDt[i];
        sat->_position_[i].nX0 *= iMayTimes;
        sat->_velosity_[i].nX0 *= iMayTimes;
    }
    return TRUE;
}


BOOL SwitchBackCalcTimePeriod(TRAOBJ * SlS, TRAOBJ * sat)
{
    int i;
    if (SwitchWas == FALSE)
        return FALSE;
    for (i = 0; i <SlS->Elem; i++)
    {
        if (SlS->_velosity_[i].nX0 % SetiMayTimes)
            return FALSE;
    }
    for (i = 0; i <sat->Elem; i++)
    {
        if (sat->_velosity_[i].nX0 % SetiMayTimes)
            return FALSE;
    }
    SwitchWas = FALSE;
    long double OldTperiod2 = SlS->TimeSl_2;
    long double NewTimePeriod = OldTperiod;// * (long double)SetiMayTimes;
    SlS->TimeSl = NewTimePeriod;
    SlS->TimeSl_2 = NewTimePeriod*NewTimePeriod;
    sat->TimeSl = SlS->TimeSl;
    sat->TimeSl_2 = SlS->TimeSl_2;
    long double MayTimes2 = (long double)(SetiMayTimes * SetiMayTimes);

    for (i = 0; i <SlS->Elem; i++)
    {
        SlS->X0divDt2[i] = Store_X0divDt2_sls[i];
        SlS->Y0divDt2[i] = Store_Y0divDt2_sls[i];
        SlS->Z0divDt2[i] = Store_Z0divDt2_sls[i];

        SlS->VX0divDt[i] = Store_VX0divDt_sls[i];
        SlS->VY0divDt[i] = Store_VY0divDt_sls[i];
        SlS->VZ0divDt[i] = Store_VZ0divDt_sls[i];

#ifdef NO_SEPARATION_VEL_POS
        SlS->_position_[i].X0 = Store_position_sls[i].X0;
        SlS->_position_[i].Y0 = Store_position_sls[i].Y0;
        SlS->_position_[i].Z0 = Store_position_sls[i].Z0;
#else
        SlS->_position_[i].X0 = Store_position_sls[i].X0;
        SlS->_position_[i].Y0 = Store_position_sls[i].Y0;
        SlS->_position_[i].Z0 = Store_position_sls[i].Z0;
        SlS->_position_[i].VX0= Store_position_sls[i].VX0;
        SlS->_position_[i].VY0= Store_position_sls[i].XY0;
        SlS->_position_[i].VZ0= Store_position_sls[i].VZ0;
#endif
        SlS->_velosity_[i].X0 = Store_velosity_sls[i].X0;
        SlS->_velosity_[i].Y0 = Store_velosity_sls[i].Y0;
        SlS->_velosity_[i].Z0 = Store_velosity_sls[i].Z0;

        SlS->_position_[i].nX0 /= SetiMayTimes;
        SlS->_velosity_[i].nX0 /= SetiMayTimes;
    }

    for (i = 0; i <sat->Elem; i++)
    {
        sat->X0divDt2[i]= Store_X0divDt2_sat[i];  
        sat->Y0divDt2[i]= Store_Y0divDt2_sat[i];
        sat->Z0divDt2[i]= Store_Z0divDt2_sat[i];
        sat->VX0divDt[i]= Store_VX0divDt_sat[i];
        sat->VY0divDt[i]= Store_VY0divDt_sat[i];
        sat->VZ0divDt[i]= Store_VZ0divDt_sat[i];
#ifdef NO_SEPARATION_VEL_POS
        sat->_position_[i].X0 = Store_position_sat[i].X0;
        sat->_position_[i].Y0 = Store_position_sat[i].Y0;
        sat->_position_[i].Z0 = Store_position_sat[i].Z0;
#else
        sat->_position_[i].X0 = Store_position_sat[i].X0;
        sat->_position_[i].Y0 = Store_position_sat[i].Y0;
        sat->_position_[i].Z0 = Store_position_sat[i].Z0;
        sat->_position_[i].VX0= Store_position_sat[i].VX0;
        sat->_position_[i].VY0= Store_position_sat[i].XY0;
        sat->_position_[i].VZ0= Store_position_sat[i].VZ0;
#endif
        sat->_velosity_[i].X0 = Store_velosity_sat[i].X0;
        sat->_velosity_[i].Y0 = Store_velosity_sat[i].Y0;
        sat->_velosity_[i].Z0 = Store_velosity_sat[i].Z0;
        sat->_position_[i].nX0 /= SetiMayTimes;
        sat->_velosity_[i].nX0 /= SetiMayTimes;
    }
    return TRUE;
}

// main engine to dump keplers elements as it is (no drag)
void DumpKeplers(long double &T,long double &Ecc, long double &Incl, long double &AssNode, long double &ArgPer, long double &MeanAnm, long double Mass, long double mass, 
                    long double &X, long double &Y, long double &Z, long double &VX, long double &VY, long double &VZ)
{
	// see http://www.projectpluto.com/source.htm or http://www.projectpluto.com/lunar.zip
	// code based on classel.cpp
	//const double *v = r + 3;
	//const double r_dot_v = r[0] * v[0] + r[1] * v[1] + r[2] * v[2];
	long double r_dot_v = X*VX + Y*VY + Z*VZ;
	//const double dist = sqrt( r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
	long double R = sqrt(X*X + Y*Y + Z*Z);
	//const double v2 = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
	long double Vsq = VX*VX + VY*VY + VZ*VZ;
	//const double inv_major_axis = 2. / dist - v2 / gm;
	long double GbigMass = Gbig * Mass;
	long double InvMAxis = 2.0 / R - Vsq / GbigMass;
	long double h0, n0;
	long double h[3], e[3], ecc2;
	long double ecc, perihelion_speed, gm_over_h0;
	int i;

	//h[0] = r[1] * v[2] - r[2] * v[1];
	h[0]   = Y * VZ   - Z * VY;
	//h[1] = r[2] * v[0] - r[0] * v[2];
	h[1] = Z * VX - X * VZ;
	// h[2] = r[0] * v[1] - r[1] * v[0];
	h[2] = X * VY - Y * VX;
	n0 = h[0] * h[0] + h[1] * h[1];
	h0 = n0 + h[2] * h[2];
	n0 = sqrt( n0);
	h0 = sqrt( h0);

	//elem->asc_node = atan2( h[0], -h[1]);
	AssNode= atan2( h[0], -h[1]);
	//if (AssNode < 0.0)
	//	AssNode = 2*M_PI + AssNode;
    // elem->incl = asine( n0 / h0);
	Incl = asin( n0 / h0);
    if( h[2] < 0.)                   /* retrograde orbit */
         Incl = M_PI - Incl;
	//e[0] = (v[1] * h[2] - v[2] * h[1]) / gm - r[0] / dist;
	e[0] = (VY * h[2] - VZ * h[1]) / GbigMass - X / R;
	//e[1] = (v[2] * h[0] - v[0] * h[2]) / gm - r[1] / dist;
	e[1] = (VZ * h[0] - VX * h[2]) / GbigMass - Y / R;
	//e[2] = (v[0] * h[1] - v[1] * h[0]) / gm - r[2] / dist;
	e[2] = (VX * h[1] - VY * h[0]) / GbigMass - Z / R;
	ecc2 = 0.;
	for( i = 0; i < 3; i++)
	{
		ecc2 += e[i] * e[i];
	}
	//elem->minor_to_major = sqrt( fabs( 1. - ecc2));
	long double BdivA = sqrt( abs( 1. - ecc2));
	//ecc = elem->ecc = sqrt( ecc2);
	ecc = Ecc = sqrt( ecc2);
	for( i = 0; i < 3; i++)
	{
		e[i] /= ecc;
	}
	gm_over_h0 = GbigMass / h0;
	//perihelion_speed = gm_over_h0 + sqrt( gm_over_h0 * gm_over_h0 - inv_major_axis * gm);
	perihelion_speed = gm_over_h0 + sqrt( gm_over_h0 * gm_over_h0 - InvMAxis * GbigMass);
	//elem->q = h0 / perihelion_speed;
	long double q = h0 / perihelion_speed;
	long double major_axis;
	long double t0;
	//long double perih_time;
	long double w0;
	if( InvMAxis)
    {
		//elem->major_axis = 1. / inv_major_axis;
		major_axis = 1. / InvMAxis;
		//elem->t0 = elem->major_axis * sqrt( fabs( elem->major_axis) / gm);
		t0 = major_axis * sqrt( abs( major_axis) / GbigMass);
		T = sqrt(4.0*M_PI*M_PI*abs(major_axis)*abs(major_axis)*abs(major_axis)/GbigMass);
		// or T = 2*PI*t0
		// from formula T*T = sqrt(4*pi^2*a^3/(G*m))
    }
	const long double cos_arg_per = (h[0] * e[1] - h[1] * e[0]) / n0;

	if( cos_arg_per < .7 && cos_arg_per > -.7)
		ArgPer = acos( cos_arg_per);
	else
    {
		const long double sin_arg_per = (e[0] * h[0] * h[2] + e[1] * h[1] * h[2] - e[2] * n0 * n0) / (n0 * h0);
		if (n0 * h0)
		{
			ArgPer = abs( asin( sin_arg_per));
			if( cos_arg_per < 0.)
				ArgPer = M_PI - ArgPer;
		}
		else
			ArgPer = 0.0;

	}
	if( e[2] < 0.)
		ArgPer = M_PI + M_PI - ArgPer;

	if( InvMAxis > 0.)         /* elliptical case */
    {
		const long double e_cos_E = 1. - R * InvMAxis;
		const long double e_sin_E = r_dot_v / sqrt( GbigMass * major_axis);
		const long double ecc_anom = atan2( e_sin_E, e_cos_E);

		MeanAnm = ecc_anom - ecc * sin( ecc_anom);
/*    elem->t0 = elem->major_axis * sqrt( elem->major_axis / gm);   */
		//elem->perih_time = t - elem->mean_anomaly * elem->t0;
		//perih_time = t - MeanAnm * t0;
	}
	else if( InvMAxis < 0.)         /* hyperbolic case */
    {
		const long double z = (1. - R * InvMAxis) / ecc;
		long double f = log( z + sqrt( z * z - 1.));

		if( r_dot_v < 0.)
			f = -f;
		MeanAnm = ecc * sinh( f) - f;
		//elem->perih_time = t - elem->mean_anomaly * fabs( elem->t0);
		//perih_time = t - MeanAnm * abs( t0);
		h0 = -h0;
	}
	else              /* parabolic case */
    {
		long double tau;

		tau = sqrt( R / q - 1.);
		if( r_dot_v < 0.)
			tau = -tau;
		w0 = (3. / M_SQRT2) / (q * sqrt( q / GbigMass));
/*    elem->perih_time = t - tau * (tau * tau / 3. + 1) *                   */
/*                                      elem->q * sqrt( 2. * elem->q / gm); */
	    //elem->perih_time = t - tau * (tau * tau / 3. + 1) * 3. / elem->w0;
		//perih_time = t - tau * (tau * tau / 3. + 1) * 3. / w0;
    }

	//for( i = 0; i < 3; i++)
	//	elem->perih_vec[i] = e[i];
	//elem->sideways[0] = (e[2] * h[1] - e[1] * h[2]) / h0;
	//elem->sideways[1] = (e[0] * h[2] - e[2] * h[0]) / h0;
	//elem->sideways[2] = (e[1] * h[0] - e[0] * h[1]) / h0;
	//elem->angular_momentum = h0;
}

//A brief header is given below:
//
//Des'n     H     G   Epoch     M        Peri.      Node       Incl.       e            n           a        Reference #Obs #Opp    Arc    rms  Perts   Computer
//
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//00001    3.34  0.12 K118R 199.31747   72.44742   80.37910   10.58595  0.0785634  0.21418897   2.7665466  0 MPO110568  6063  94 1802-2006 0.61 M-v 30h MPCW       0000      (1) Ceres              20061025
//00002    4.13  0.11 K118R 181.70142  310.06331  173.12644   34.84160  0.2312416  0.21365561   2.7711488  0 MPO135420  7253  93 1827-2008 0.59 M-v 28h MPCW       0000      (2) Pallas             20080101
//00003    5.33  0.32 K118R 122.32357  248.18733  169.91025   12.98086  0.2551627  0.22576192   2.6711744  0 MPO135420  6278  91 1824-2008 0.60 M-v 38h MPCW       0000      (3) Juno               20080308
//00004    3.20  0.32 K118R  56.40276  149.88186  103.90428    7.13461  0.0883124  0.27164416   2.3612165  0 MPO135420  6449  82 1827-2007 0.60 M-v 18h MPCW       0000      (4) Vesta              20070808
//00005    6.85  0.15 K118R 334.02337  358.78351  141.61007    5.36742  0.1903560  0.23868879   2.5738390  0 MPO 41498  2178 100 1845-2002 0.56 M-v 38h Goffin     0000      (5) Astraea            20021114
//00006    5.71  0.24 K118R  76.23230  239.28896  138.72650   14.75022  0.2022525  0.26104401   2.4247124  0 MPO135420  5011  81 1848-2008 0.55 M-v 38h MPCW       0007      (6) Hebe               20080222
//00007    5.51  0.15 K118R 111.53561  145.26277  259.65080    5.52306  0.2305428  0.26737788   2.3862672  0 MPO135420  4443  76 1848-2008 0.60 M-v 38h MPCW       0000      (7) Iris               20080308
//00008    6.49  0.28 K118R  70.05922  285.18420  110.93525    5.88786  0.1564761  0.30182794   2.2010492  0 MPO 25662  2438 102 1847-2000 0.54 M-v 38h Goffin     0000      (8) Flora              20001115
//00009    6.28  0.17 K118R 248.44234    6.24383   68.94919    5.57547  0.1227453  0.26749937   2.3855446  0 MPO 25662  2131  96 1822-2001 0.54 M-v 38h Goffin     0000      (9) Metis              20011024
//00010    5.43  0.15 K118R  15.29657  313.01188  283.41502    3.84094  0.1164623  0.17722252   3.1389913  0 MPC 35055  2261 104 1849-1999 0.53 M-v 38h Goffin     0000     (10) Hygiea             19990306
//00011    6.55  0.15 K118R 281.05531  195.04403  125.60104    4.62566  0.0990377  0.25651561   2.4531655  0 MPO135420  3974  82 1850-2007 0.63 M-v 38h MPCW       0000     (11) Parthenope         20070725
//00012    7.24  0.22 K118R  79.04846   69.82359  235.48673    8.36699  0.2207436  0.27628481   2.3347016  0 MPO 57621  2635  86 1850-2003 0.56 M-v 38h Goffin     0000     (12) Victoria           20030921
//00013    6.74  0.15 K118R 240.86929   80.14640   43.27015   16.54560  0.0853678  0.23830803   2.5765798  0 MPO  2601   946  54 1850-2000 0.77 M-v 38h Williams   0000     (13) Egeria             20000131
//00014    6.30  0.15 K118R 221.96593   97.35232   86.20615    9.10849  0.1656321  0.23651727   2.5895689  0 MPO   595  1765  84 1851-2000 0.54 M-v 38h Goffin     0000     (14) Irene              20000402
//00015    5.28  0.23 K118R   2.13972   97.67316  293.21965   11.73525  0.1886022  0.22924203   2.6440716  0 MPO 25662  2071  91 1851-2001 0.52 M-v 38h Goffin     0000     (15) Eunomia            20010712
//00016    5.90  0.20 K118R  98.10135  226.95821  150.29920    3.09929  0.1374216  0.19745426   2.9207320  0 MPC 35055  1831  96 1852-1998 0.53 M-v 38h Goffin     0000     (16) Psyche             19980614

//this function transformed from original code to cross check another functions
void setup_orbit_vectors( long double &e_epoch, long double &e_ecc, long double &e_incl, long double &e_asc_node, long double &e_arg_per,long double &e_mean_anomaly,
	long double &e_q, long double &e_major_axis,long double &e_t0,long double &e_w0,long double &e_angular_momentum,long double &e_perih_time,
	long double &e_minor_to_major, long double &e_lon_per,
	long double &e_sideways_x, long double &e_sideways_y, long double &e_sideways_z,
	long double &vec_x, long double &vec_y,long double &vec_z,long double gm)
{
   long double sin_incl = sin( e_incl), cos_incl = cos( e_incl);
   //double *vec;
   long double vec_len;
   //double up[3];
   long double up_x, up_y, up_z;
   //int i;

   e_minor_to_major = sqrt( abs( (long double)1. - e_ecc * e_ecc));
   e_lon_per = e_asc_node + atan2( sin( e_arg_per) * cos_incl,
                                       cos( e_arg_per));
   //vec = e->perih_vec;

   vec_x = cos( e_lon_per);
   vec_y = sin( e_lon_per);
   vec_z = (sin_incl / cos_incl) * sin( e_lon_per - e_asc_node);
   //vec_len = sqrt( 1. + vec[2] * vec[2]);
   vec_len = sqrt( 1. + vec_z * vec_z);
   //for( i = 0; i < 3; i++)
   //   vec[i] /= vec_len;
   vec_x /= vec_len;
   vec_y /= vec_len;
   vec_z /= vec_len;
            /* 'up' is a vector perpendicular to the plane of the orbit */
   up_x =  sin( e_asc_node) * sin_incl;
   up_y = -cos( e_asc_node) * sin_incl;
   up_z = cos_incl;

   e_sideways_x = up_y * vec_z - up_z * vec_y;
   e_sideways_y = up_z * vec_x - up_x * vec_z;
   e_sideways_z = up_x * vec_y - up_y * vec_x;
}
// this function transformed from original code to cross check another functions
void derive_quantities( long double &e_epoch, long double &e_ecc, long double &e_incl, long double &e_asc_node, long double &e_arg_per,long double &e_mean_anomaly,
	long double &e_q, long double &e_major_axis,long double &e_t0,long double &e_w0,long double &e_angular_momentum,long double &e_perih_time,
	long double &e_minor_to_major, long double &e_lon_per,
	long double &e_sideways_x, long double &e_sideways_y, long double &e_sideways_z,
	long double &vec_x, long double &vec_y,long double &vec_z,long double gm)
{
   if( e_ecc != 1.)    /* for non-parabolic orbits: */
      {
      e_major_axis = e_q / abs(1. - e_ecc);
      e_t0 = e_major_axis * sqrt( e_major_axis / gm);
      }
   else
      {
      e_w0 = (3. / sqrt((long double)2.0)) / (e_q * sqrt( e_q / gm));
      e_major_axis = e_t0 = 0.;
      }
  //setup_orbit_vectors( e);
}
// this function transformed from original code to cross check another functions
void do_element_setup( long double &e_epoch, long double &e_ecc, long double &e_incl, long double &e_asc_node, long double &e_arg_per,long double &e_mean_anomaly,
	long double &e_q, long double &e_major_axis,long double &e_t0,long double &e_w0,long double &e_angular_momentum,long double &e_perih_time,
	long double &e_minor_to_major, long double &e_lon_per,
	long double &e_sideways_x, long double &e_sideways_y, long double &e_sideways_z,
	long double &vec_x, long double &vec_y,long double &vec_z,long double gm, long double T)
{
	//elem->mean_anomaly  *= PI / 180.;
	//elem->arg_per       *= PI / 180.;
	//elem->asc_node      *= PI / 180.;
	//elem->incl          *= PI / 180.;
	long double Temp = (((gm * T * T / 4.0) / M_PI) / M_PI);
    long double A = pow(Temp, (long double)1.0 / (long double)3.0);

    //A= EarthSmAx;
    long double B = A * sqrt(1.0 - e_ecc * e_ecc);
	e_major_axis =  A;
	e_q = e_major_axis * (1. - e_ecc);
	//derive_quantities( elem, gm);
	if( e_ecc != 1.)    /* for non-parabolic orbits: */
	{
		e_major_axis = e_q / abs(1. - e_ecc);
		e_t0 = e_major_axis * sqrt( e_major_axis / gm);
    }
	else
    {
		e_w0 = (3. / sqrt((long double)2.0)) / (e_q * sqrt( e_q / gm));
		e_major_axis = e_t0 = 0.;
    }
	//setup_orbit_vectors( e);
	{
		long double sin_incl = sin( e_incl), cos_incl = cos( e_incl);
		//double *vec;
		long double vec_len;
		//double up[3];
		long double up_x, up_y, up_z;
		//int i;

		e_minor_to_major = sqrt( abs( (long double)1. - e_ecc * e_ecc));
		e_lon_per = e_asc_node + atan2( sin( e_arg_per) * cos_incl,
                                       cos( e_arg_per));
		//vec = e->perih_vec;

		vec_x = cos( e_lon_per);
		vec_y = sin( e_lon_per);
		vec_z = (sin_incl / cos_incl) * sin( e_lon_per - e_asc_node);
		//vec_len = sqrt( 1. + vec[2] * vec[2]);
		vec_len = sqrt( 1. + vec_z * vec_z);
		//for( i = 0; i < 3; i++)
		//   vec[i] /= vec_len;
		vec_x /= vec_len;
		vec_y /= vec_len;
		vec_z /= vec_len;
            /* 'up' is a vector perpendicular to the plane of the orbit */
		up_x =  sin( e_asc_node) * sin_incl;
		up_y = -cos( e_asc_node) * sin_incl;
		up_z = cos_incl;

		e_sideways_x = up_y * vec_z - up_z * vec_y;
		e_sideways_y = up_z * vec_x - up_x * vec_z;
		e_sideways_z = up_x * vec_y - up_y * vec_x;
	}   
	e_angular_momentum = sqrt( gm * e_q * (1. + e_ecc));
	e_perih_time = e_epoch - e_mean_anomaly * e_t0;
	//e_is_asteroid = 1;
	//elem->central_obj = 0;
}


#define MAX_ITERATIONS 7
long double asinh( long double z)
{
   return( log( z + sqrt( z * z + 1.)));
}
long double near_parabolic( long double ecc_anom, long double e)
{
   long double anom2 = (e > 1. ? ecc_anom * ecc_anom : -ecc_anom * ecc_anom);
   long double term = e * anom2 * ecc_anom / 6.;
   long double rval = (1. - e) * ecc_anom - term;
   int n = 4;

   while( fabs( term) > 1e-15)
      {
      term *= anom2 / (double)(n * (n + 1));
      rval -= term;
      n += 2;
      }
   return( rval);
}

#define THRESH 1.e-8
#define MIN_THRESH 1.e-15
// from the same source - good sample of a keplers solution
long double kepler(long double ecc, long double mean_anom)
{
   long double curr, err, thresh, offset = 0.;
   long double delta_curr = 1.;
   int is_negative = 0, n_iter = 0;

   if( !mean_anom)
      return( 0.);

   if( ecc < .3)     /* low-eccentricity formula from Meeus,  p. 195 */
      {
      curr = atan2( sin( mean_anom), cos( mean_anom) - ecc);
            /* two correction steps,  and we're done */
      for( n_iter = 2; n_iter; n_iter--)
         {
         err = curr - ecc * sin( curr) - mean_anom;
         curr -= err / (1. - ecc * cos( curr));
         }
      return( curr);
      }

   if( ecc < 1.)
      if( mean_anom < -M_PI || mean_anom > M_PI)
         {
         double tmod = fmod( mean_anom, (long double)M_PI * (long double)2.);

         if( tmod > M_PI)             /* bring mean anom within -pi to +pi */
            tmod -= 2. * M_PI;
         else if( tmod < -M_PI)
            tmod += 2. * M_PI;
         offset = mean_anom - tmod;
         mean_anom = tmod;
         }

   if( mean_anom < 0.)
      {
      mean_anom = -mean_anom;
      is_negative = 1;
      }

   curr = mean_anom;
   thresh = THRESH * fabs( 1. - ecc);
               /* Due to roundoff error,  there's no way we can hope to */
               /* get below a certain minimum threshhold anyway:        */
   if( thresh < MIN_THRESH)
      thresh = MIN_THRESH;
   if( (ecc > .8 && mean_anom < M_PI / 3.) || ecc > 1.)    /* up to 60 degrees */
      {
      double trial = mean_anom / fabs( 1. - ecc);

      if( trial * trial > 6. * fabs(1. - ecc))   /* cubic term is dominant */
         {
         if( mean_anom < M_PI)
            trial = pow( 6. * mean_anom,(long double)1.0/(long double)3.0);
         else        /* hyperbolic w/ 5th & higher-order terms predominant */
            trial = asinh( mean_anom / ecc);
         }
      curr = trial;
      }
   if( ecc > 1. && mean_anom > 4.)    /* hyperbolic, large-mean-anomaly case */
      curr = log( mean_anom);

   if( ecc < 1.)
      while( fabs( delta_curr) > thresh)
         {
         if( n_iter++ > MAX_ITERATIONS)
            err = near_parabolic( curr, ecc) - mean_anom;
         else
            err = curr - ecc * sin( curr) - mean_anom;
         delta_curr = -err / (1. - ecc * cos( curr));
         curr += delta_curr;
         }
   else
      while( fabs( delta_curr) > thresh)
         {
         if( n_iter++ > MAX_ITERATIONS)
            err = -near_parabolic( curr, ecc) - mean_anom;
         else
            err = ecc * sinh( curr) - curr - mean_anom;
         delta_curr = -err / (ecc * cosh( curr) - 1.);
         curr += delta_curr;
         }
   return( is_negative ? offset - curr : offset + curr);
}

// this function transformed from original code to cross check another functions
int posn_and_vel( long double &e_epoch, long double &e_ecc, long double &e_incl, long double &e_asc_node, long double &e_arg_per,long double &e_mean_anomaly,
	long double &e_q, long double &e_major_axis,long double &e_t0,long double &e_w0,long double &e_angular_momentum,long double &e_perih_time,
	long double &e_minor_to_major, long double &e_lon_per,
	long double &e_sideways_x, long double &e_sideways_y, long double &e_sideways_z,
	long double &e_perih_vec_x,long double &e_perih_vec_y,long double &e_perih_vec_z,
	long double &loc_x, long double &loc_y, long double &loc_z, long double &loc_r,long double &vel_x,long double &vel_y,long double &vel_z,long double t, long double gm)
{
	t -= e_perih_time;
	if( e_ecc != 1.)    /* not parabolic */
	{
		t /= e_t0;
		if( e_ecc < 1.)     /* elliptical case;  throw out extra orbits */
        {                    /* to fit mean anom between -PI and PI */
			t = fmod( (long double)t, (long double)M_PI * 2.);
			if( t < -M_PI) t += 2. * M_PI;
			if( t >  M_PI) t -= 2. * M_PI;
		}
		e_mean_anomaly = t;
	}
	//posn_part_ii( elem, t, loc, vel);
	{
		long double true_anom, r, x, y, r0;

		if( e_ecc == 1.)    /* parabolic */
		{
			long double g = e_w0 * t * .5;

			y = pow( g + sqrt( g * g + 1.), (long double)1.0/ (long double)3.0);
			true_anom = 2. * atan( y - 1. / y);
		}
		else           /* got the mean anomaly;  compute eccentric,  then true */
		{
			long double ecc_anom;

			ecc_anom = kepler( e_ecc, e_mean_anomaly);
			if( e_ecc > 1.)     /* hyperbolic case */
			{
				x = (e_ecc - cosh( ecc_anom));
				y = sinh( ecc_anom);
			}
			else           /* elliptical case */
			{
				x = (cos( ecc_anom) - e_ecc);
				y =  sin( ecc_anom);
			}
			y *= e_minor_to_major;
			true_anom = atan2( y, x);
		}

		r0 = e_q * (1. + e_ecc);
		r = r0 / (1. + e_ecc * cos( true_anom));
		x = r * cos( true_anom);
		y = r * sin( true_anom);
		loc_x = e_perih_vec_x * x + e_sideways_x * y;
		loc_y = e_perih_vec_y * x + e_sideways_y * y;
		loc_z = e_perih_vec_z * x + e_sideways_z * y;
		loc_r = r;
		//if( vel && (elem->angular_momentum != 0.))
		{
			long double angular_component = e_angular_momentum / (r * r);
			long double radial_component = e_ecc * sin( true_anom) *
                                e_angular_momentum / (r * r0);
			long double x1 = x * radial_component - y * angular_component;
			long double y1 = y * radial_component + x * angular_component;
			//int i;

			//for( i = 0; i < 3; i++)
			//   vel[i] = elem->perih_vec[i] * x1 + elem->sideways[i] * y1;
			vel_x = e_perih_vec_x * x1 + e_sideways_x * y1;
			vel_y = e_perih_vec_y * x1 + e_sideways_y * y1;
			vel_z = e_perih_vec_z * x1 + e_sideways_z * y1;
		}
	}

   return( 0);
}
// today value is in Gbig * Mass = 398600441499999.87 in m**3/s**2
//#define BIG_XKE 7.43669161331734132e-2

// was based in SGP4 on G=398600.8 km**3/s**2
//#define R0_MODEL 6378136.30

#define BIG_XKE .743669161E-1


// see http://www.amsat.org/amsat/keps/kepmodel.html
// or http://en.wikipedia.org/wiki/Orbital_elements
//    SatEpoch  - satellite epoch
//    T         - orbit period in sec 
//                 for Mean Motion (revolutions/day) needs T = 60*60*24 / Mean_Motion
//    Ecc       - Eccentricity
//    Incl      - Inclination
//    AssNode   - Longitude of ascending node (where the orbit passes upward through the reference plane)
//    ArgPer    - Argument of perihelion angle to per (lower point) point
//    MeanAnm   - Mean Anomaly (degrees)
//    Mass      - Mass of first body
//    mass      - Mass of second body
//                assuming:
//     Z  - pointed up
//     Y  - to right
//     X  - to point of view
//
//                or:
//     Z  - point north from ecliptic
//     X  - to easter
//     Y  - to point of view
// XY plain is equatorial plain for earth's satellites, or for planets it is a ecliptic 
// plane (the plane of the Earth's orbit around the Sun). In both cases X points to easter/
// this function now does not care about drag - which is bad 
void KeplerPosition(long double SatEpoch, long double CurTime, long double T,long double Ecc, long double Incl, long double AssNode, long double ArgPer, long double MeanAnm, long double BSTAR, long double GM, int doCorrection, 
                    long double &Xm, long double &Ym, long double &Zm, long double &VX, long double &VY, long double &VZ, long double ProbMeanMotion)
{
    long double XMNPDA_XMNPDA = 24.0*60.0*60.0;//1440.0; // XMNPDA time units(minutes) /day 1440.0
	long double XMNPDA = 24.0*60.0;//1440.0; // XMNPDA time units(minutes) /day 1440.0
	long double TEMP_=2*M_PI/XMNPDA/XMNPDA; // 2*pi / (1440 **2)
	long double TEMP_TEMP_=2*M_PI/XMNPDA_XMNPDA/XMNPDA_XMNPDA; // 2*pi / (1440 **2)
	long double XNO=ProbMeanMotion*TEMP_*XMNPDA; // rotation per day * 2*pi /1440 == rotation per day on 1 unit (1 min/sec)
	long double XNO_XNO=ProbMeanMotion*TEMP_TEMP_*XMNPDA_XMNPDA; // rotation per day * 2*pi /1440 == rotation per day on 1 unit (1 min/sec)
	long double XKE = BIG_XKE;//.743669161E-1;
	long double XKMPER = 6378.1350;
	//IF (IFLAG .EQ. 0) GO TO 100
	//* RECOVER ORIGINAL MEAN MOTION (XNODP) AND SEMIMAJOR AXIS (AODP)
	//* FROM INPUT ELEMENTS
	//A1=(XKE/XNO)**TOTHRD;
	long double XJ2 = 1.082616E-3;
	long double XJ3 = -.253881E-5;
	long double XJ4 = -1.65597E-6;
	long double AE = 1.0;
	long double QO =120.0;
	long double SO = 78.0;

	long double CK2=.5*XJ2*AE*AE;
	//CK4=-.375*XJ4*AE**4
	long double CK4=-.375*XJ4*AE*AE*AE*AE;
	long double QOMS2T=pow(((QO-SO)*AE/XKMPER),(long double)4.0);
	long double S=AE*(1.+SO/XKMPER);
	//A1=(XKE/XNO)**TOTHRD;
	long double A1=pow((XKE/XNO),(long double)2.0/(long double)3.0);
	long double A1_A1=pow((XKE/XNO_XNO),(long double)2.0/(long double)3.0);
	long double COSIO=cos(Incl);
	long double THETA2=COSIO*COSIO;
	long double X3THM1=3.*THETA2-1.;
	long double EOSQ=Ecc*Ecc;
	long double BETAO2=1.-EOSQ;
	long double BETAO=sqrt(BETAO2);
	long double DEL1=1.5*CK2*X3THM1/(A1*A1*BETAO*BETAO2);
	//AO=A1*(1.-DEL1*(.5*TOTHRD+DEL1*(1.+134./81.*DEL1)))
	long double AO=A1*(1.-DEL1*(.5*(2.0/3.0)+DEL1*(1.+134./81.*DEL1)));
	long double DELO=1.5*CK2*X3THM1/(AO*AO*BETAO*BETAO2);
    // ProbMeanMotion = XNO / (2*pi) * 1440.0
	long double XNODP=XNO/(1.+DELO);
    if (doCorrection)
    {
        T = 1.0/ (XNODP / M_PI/2.0 * 1440.0) * 24.0 * 60.0 * 60.0;
    }
    // and this is a semimajor axis
	long double AODP=AO/(1.-DELO);
    if (doCorrection)
    {
    }
	//* INITIALIZATION
	//* FOR PERIGEE LESS THAN 220 KILOMETERS, THE ISIMP FLAG IS SET AND
	//* THE EQUATIONS ARE TRUNCATED TO LINEAR VARIATION IN SQRT A AND
	//* QUADRATIC VARIATION IN MEAN ANOMALY. ALSO, THE C3 TERM, THE
	//* DELTA OMEGA TERM, AND THE DELTA M TERM ARE DROPPED.
	int ISIMP=0;
	//IF((AODP*(1.-EO)/AE) .LT. (220./XKMPER+AE)) ISIMP=1
	if((AODP*(1.-Ecc)/AE) < (220./XKMPER+AE)) 
		ISIMP=1;
	//* FOR PERIGEE BELOW 156 KM, THE VALUES OF
	//* S AND QOMS2T ARE ALTERED
	long double S4=S;
	long double QOMS24=QOMS2T;
	long double PERIGE=(AODP*(1.-Ecc)-AE)*XKMPER;
	//IF(PERIGE .GE. 156.) GO TO 10
	if (PERIGE >= 156.) 
		goto M_10;
	S4=PERIGE-78.;
	//IF(PERIGE .GT. 98.) GO TO 9
	if (PERIGE >=98.) 
		goto M_9;
	S4=20.;
M_9:
	//QOMS24=((120.-S4)*AE/XKMPER)**4;
	QOMS24=pow(((120.-S4)*AE/XKMPER),4);
	S4=S4/XKMPER+AE;
M_16:
M_10:
	long double PINVSQ=1./(AODP*AODP*BETAO2*BETAO2);
	long double TSI=1./(AODP-S4);
	long double ETA=AODP*Ecc*TSI;
	long double ETASQ=ETA*ETA;
	long double EETA=Ecc*ETA;
	long double PSISQ=abs(1.-ETASQ);
	//COEF=QOMS24*TSI**4
	long double COEF=QOMS24*TSI*TSI*TSI*TSI;
	//COEF1=COEF/PSISQ**3.5;
	long double COEF1=COEF/pow(PSISQ,(long double)3.5);

	long double C2=COEF1*XNODP*(AODP*(1.+1.5*ETASQ+EETA*(4.+ETASQ))+.75* CK2*TSI/PSISQ*X3THM1*(8.+3.*ETASQ*(8.+ETASQ)));
	long double C1=BSTAR*C2;
	long double SINIO=sin(Incl);
	//A3OVK2=-XJ3/CK2*AE**3;
	long double A3OVK2=-XJ3/CK2*(AE*AE*AE);
	long double C3=COEF*TSI*A3OVK2*XNODP*AE*SINIO/Ecc;
	long double X1MTH2=1.-THETA2;
	long double C4=2.*XNODP*COEF1*AODP*BETAO2*(ETA*(2.+.5*ETASQ)+Ecc*(.5+2.*ETASQ)-2.*CK2*TSI/
			(AODP*PSISQ)*(-3.*X3THM1*(1.-2.*EETA+ETASQ* (1.5-.5*EETA))+.75*X1MTH2*(2.*ETASQ-EETA* (1.+ETASQ))*cos(2.*ArgPer)));
	long double C5=2.*COEF1*AODP*BETAO2*(1.+2.75*(ETASQ+EETA)+EETA*ETASQ);
	long double THETA4=THETA2*THETA2;
	long double TEMP1=3.*CK2*PINVSQ*XNODP;
	long double TEMP2=TEMP1*CK2*PINVSQ;
	long double TEMP3=1.25*CK4*PINVSQ*PINVSQ*XNODP;
	long double XMDOT=XNODP+.5*TEMP1*BETAO*X3THM1+.0625*TEMP2*BETAO* (13.-78.*THETA2+137.*THETA4);
	long double X1M5TH=1.-5.*THETA2;
	long double OMGDOT=-.5*TEMP1*X1M5TH+.0625*TEMP2*(7.-114.*THETA2+ 395.*THETA4)+TEMP3*(3.-36.*THETA2+49.*THETA4);
	long double XHDOT1=-TEMP1*COSIO;
	long double XNODOT=XHDOT1+(.5*TEMP2*(4.-19.*THETA2)+2.*TEMP3*(3.-7.*THETA2))*COSIO;
	long double OMGCOF=BSTAR*C3*cos(ArgPer);
	long double XMCOF=-(2.0/3.0)*COEF*BSTAR*AE/EETA;
	long double XNODCF=3.5*BETAO2*XHDOT1*C1;
	long double T2COF=1.5*C1;
	long double XLCOF=.125*A3OVK2*SINIO*(3.+5.*COSIO)/(1.+COSIO);
	long double AYCOF=.25*A3OVK2*SINIO;
	//DELMO=(1.+ETA*COS(XMO))**3
	long double DELMO=pow((1.+ETA*cos(MeanAnm)),3);
	long double SINMO=sin(MeanAnm);
	long double X7THM1=7.*THETA2-1.;
	// IF(ISIMP .EQ. 1) GO TO 90
	if (ISIMP == 1) 
		goto M_90;
	long double C1SQ=C1*C1;
	long double D2=4.*AODP*TSI*C1SQ;
	long double TEMP=D2*TSI*C1/3.;
	long double D3=(17.*AODP+S4)*TEMP;
	long double D4=.5*TEMP*AODP*TSI*(221.*AODP+31.*S4)*C1;
M_17:
	long double T3COF=D2+2.*C1SQ;
	long double T4COF=.25*(3.*D3+C1*(12.*D2+10.*C1SQ));
	long double T5COF=.2*(3.*D4+12.*C1*D3+6.*D2*D2+15.*C1SQ*(2.*D2+C1SQ));
M_90:
	//IFLAG=0;
	//* UPDATE FOR SECULAR GRAVITY AND ATMOSPHERIC DRAG
M_100:
    long double TSINCE = (CurTime - SatEpoch)*(24.0 * 60.0* 60.0);
	long double XMDF=MeanAnm+XMDOT*TSINCE;
	long double OMGADF=ArgPer+OMGDOT*TSINCE;
	long double XNODDF=AssNode+XNODOT*TSINCE;
	long double OMEGA=OMGADF;
	long double XMP=XMDF;
	long double TSQ=TSINCE*TSINCE;
	long double XNODE=XNODDF+XNODCF*TSQ;
	long double TEMPA=1.-C1*TSINCE;
	long double TEMPE=BSTAR*C4*TSINCE;
	long double TEMPL=T2COF*TSQ;
	// IF(ISIMP .EQ. 1) GO TO 110
	if (ISIMP == 1) 
		goto M_110;
	long double DELOMG=OMGCOF*TSINCE;
	// DELM=XMCOF*((1.+ETA*COS(XMDF))**3-DELMO)
	long double DELM=XMCOF*(pow((1.+ETA*cos(XMDF)),3)-DELMO);
	TEMP=DELOMG+DELM;
	XMP=XMDF+TEMP;
	OMEGA=OMGADF-TEMP;
	long double TCUBE=TSQ*TSINCE;
	long double TFOUR=TSINCE*TCUBE;
	TEMPA=TEMPA-D2*TSQ-D3*TCUBE-D4*TFOUR;
	TEMPE=TEMPE+BSTAR*C5*(sin(XMP)-SINMO);
	TEMPL=TEMPL+T3COF*TCUBE+TFOUR*(T4COF+TSINCE*T5COF);
M_110:
	//A=AODP*TEMPA**2;
	//long double A=AODP*TEMPA*TEMPA;
	long double Eee=Ecc-TEMPE;



    long double Omega0 = ArgPer;

	long double TettaDelta = 0.0;

    // Tetta = contrclockwise angle from perihelion
	// Mean Anomaly
    // [aka "M0" or "MA" or "Phase"]
	// 	Mean anomaly is simply an angle that marches uniformly in time from 0 to 360 degrees during one revolution. It is defined to be 0 degrees at perigee, and therefore is 180 degrees at apogee. 
	// The mean anomaly increases uniformly from 0 to 2*PI() radians during each orbit. However, it is not an angle. 
	// Due to Kepler's second law, the mean anomaly is proportional to the area swept by the focus-to-body line since the last periapsis.
    // The mean anomaly is usually denoted by the letter M, and is given by the formula
	// cos(TrueAnomaly) = (cos(E) - e) / (1 - e*cos(E))
	// and E - is a essentric anomaly formula is:
	// M = E - e*sin(E) 
	// first calculates how many orbits was done from a epoche time till current moment of time
	TettaDelta = CurTime - SatEpoch;
	TettaDelta  *= (24.0 * 60.0 * 60.0);
	TettaDelta /= T;
	int iTettaDelta = (int)TettaDelta;
	TettaDelta -= iTettaDelta;
    TettaDelta *= T;
    TettaDelta /= 24.0*60.0*60.0;
	TettaDelta *= 2.0 * M_PI;


	long double M = MeanAnm + TettaDelta;
    if (doCorrection)
    {
        //M = XMP;
        Ecc = Eee;
        //ArgPer = OMEGA;
        //AssNode = XNODE;
    }
    //// find E
    long double E = M;
    long double ENext = E - Ecc * sin(E);
    long double DeltaE = abs(ENext - M);
	long double PresM = abs(M) * 1.0E-15;
	int iAdditionalAttempts = 3;
    while (iAdditionalAttempts > 0)
    {
        ENext = E - Ecc * sin(E);
        DeltaE = abs(ENext - M);
		if (PresM >= DeltaE)
			iAdditionalAttempts--;
	
		E = E - ( ENext - M) /2;
    }

	long double CosPhi = (cos(E) - Ecc)/(1.0 -Ecc*cos(E));



	long double Tetta = acos(CosPhi);
	// for conformation see: http://www.jgiesen.de/kepler/kepler.html
    
	// first calulate a = (G*M1*T*T/(4*Pi*Pi))in power 1/3
    long double Temp = ((((GM * T * T) / 4.0) / M_PI) / M_PI);
    long double A = pow(Temp, (long double)1.0 / (long double)3.0);

    //A= EarthSmAx;
    long double B = A * sqrt(1.0 - Ecc * Ecc);

    //printf("\n Calc A      = %f", A);
	// calulates R
    // X - pointed right and to perihelion
    // Y - pointed down
    // Z is not in use X-Y is a orbit plain
    // see pic1.bmp
    long double R = (B * B / ( 1.0 + Ecc * cos(Tetta))) / A;
    long double X0 = R*cos(Tetta);
	long double Y0 = R*sin(Tetta);
	long double Z0 = 0.0;

    long double VR = sqrt(((GM))*A/B/B) * Ecc * sin(Tetta);
    long double VN = sqrt(((GM))*A/B/B) * (1.0 +Ecc *cos(Tetta));

    int DirectionContrClock = 1;

    if (AssNode >=0.0 && AssNode < M_PI)
        DirectionContrClock = 0;
    long double VXm0;
    long double VYm0;
    long double VZm0;
    long double M_TrAnom[4]={-1,1,1,1};
	long double M_argper[4] = {1,-1,1,1};
	long double M_incl[4] = {1,-1,1,1};
	long double M_AsNode[4] = {1,-1,1,1};
    //if (DirectionContrClock)
    //{
    //    VXm0 =  -sin(Tetta) * VN - cos(Tetta) * VR;//- cos(Tetta) * VN + sin(Tetta) * VR;// - cos(Tetta) * VN + sin(Tetta) * VR;
    //    VYm0 = cos(Tetta) * VN - sin(Tetta) * VR;//- sin(Tetta) * VN - cos(Tetta) * VR;//  sin(Tetta) * VN - cos(Tetta) * VR;
    //    VZm0 = 0.0;
    //
    //}
    //else
    {
        VXm0 = M_TrAnom[0]*sin(Tetta) * VN + M_TrAnom[1]*cos(Tetta) * VR;
        VYm0 = M_TrAnom[2]*cos(Tetta) * VN + M_TrAnom[3]*sin(Tetta) * VR;
        VZm0 = 0.0;
    }

    // perihelium direction adjust:
    // rotation vector (X0,Y0) by angle omega clockwise will get vector (X1,Y1)
    //
    
    long double X1 = X0 * cos(ArgPer) - Y0 * sin(ArgPer);
    long double Y1 = X0 * sin(ArgPer) + Y0 * cos(ArgPer);
    long double Z1 = Z0;

    long double VXm1 = M_argper[0]*VXm0 * cos(ArgPer) + M_argper[1]* VYm0 * sin(ArgPer);
    long double VYm1 = M_argper[2]*VXm0 * sin(ArgPer) + M_argper[3]*VYm0 * cos(ArgPer);
    long double VZm1 = VZm0;

    // inclanation direction adjust 
    // incl (satellite) = incl
    long double X2 = X1;
    long double Y2 = Y1 * cos(Incl) - Z1 * sin(Incl);
    long double Z2 = Y1 * sin(Incl) + Z1 * cos(Incl);;

    long double VXm2 = VXm1;
    long double VYm2 = M_incl[0]*VYm1 * cos(Incl) + M_incl[1]* VZm1 * sin(Incl);
    long double VZm2 = M_incl[2]*VYm1 * sin(Incl) + M_incl[3]*VZm1 * cos(Incl);

    // Assending Node last opartion 
    long double X3 = X2 * cos(AssNode) - Y2 * sin(AssNode);
    long double Y3 = X2 * sin(AssNode) + Y2 * cos(AssNode);
    long double Z3 = Z2;

    long double VXm3 = M_AsNode[0]*VXm2 * cos(AssNode) + M_AsNode[1]*VYm2 * sin(AssNode);
    long double VYm3 = M_AsNode[2]*VXm2 * sin(AssNode) + M_AsNode[3]*VYm2 * cos(AssNode);
    long double VZm3 = VZm2;

    Xm = X3;
    Ym = Y3;
    Zm = Z3;
	
    VX = VXm3;
    VY = VYm3;
    VZ = VZm3;
}
double ConvertDateTimeToTLEEpoch(int iDay, int iMonth, int iYear, int iHour, int iMin, int iSec, int iMills);
long double ConvertJulianDayToDateAndTime(double JulianDay, SYSTEMTIME *ThatTime)
{
    long daysfrom2000 = (long)(JulianDay - 2451544.5); // noon 1 jan 2000
    long double flInDay = (JulianDay - 2451544.5) - (long double)daysfrom2000; 
    long double RetTime = flInDay;
    flInDay += 1.0/(60.0*60.0*24.0*1000); // last one is for rounding milliseconds
    int iYear = 0;
    daysfrom2000 += 1; // 1Jan must be 1;
    while (daysfrom2000 > 366)
    {
        switch(iYear)
        {
        case 24:daysfrom2000-=366;break;
        case 23:daysfrom2000-=365;break;
        case 22:daysfrom2000-=365;break;
        case 21:daysfrom2000-=365;break;
        case 20:daysfrom2000-=366;break;
        case 19:daysfrom2000-=365;break;
        case 18:daysfrom2000-=365;break;
        case 17:daysfrom2000-=365;break;
        case 16:daysfrom2000-=366;break;
        case 15:daysfrom2000-=365;break;
        case 14:daysfrom2000-=365;break;
        case 13:daysfrom2000-=365;break;
        case 12:daysfrom2000-=366;break;
        case 11:daysfrom2000-=365;break;
        case 10:daysfrom2000-=365;break;
        case 9:daysfrom2000-=365;break;
        case 8:daysfrom2000-=366;break;
        case 7:daysfrom2000-=365;break;
        case 6:daysfrom2000-=365;break;
        case 5:daysfrom2000-=365;break;
        case 4:daysfrom2000-=366;break;
        case 3:daysfrom2000-=365;break;
        case 2:daysfrom2000-=365;break;
        case 1:daysfrom2000-=365;break;
        case 0:daysfrom2000-=366;break;
        }
        iYear++;
    }
    ThatTime->wYear = iYear+2000;
    int iMonth =1;
    int iComp, iDecr;
    int DaysFromTheBeginigOfTheYear= daysfrom2000;  // 1 Jan is 0 day == but in TLE 01/01/00 00:00:00 will be 00001.00000
    while(1)
    {
        switch(iMonth)
        {
        case 1: iComp = 31; iDecr = 31; break; // jan
        case 2: if (iYear%4 ==0) //leap year    //feb
                {
                    iComp = 29; iDecr = 29;
                }
                else
                {
                    iComp = 28; iDecr = 28;
                }
                break;
        case 3: iComp = 31; iDecr = 31; break; // mar
        case 4: iComp = 30; iDecr = 30; break; // apr
        case 5: iComp = 31; iDecr = 31; break; // may
        case 6: iComp = 30; iDecr = 30; break; // jun
        case 7: iComp = 31; iDecr = 31; break; //jul
        case 8: iComp = 31; iDecr = 31; break; // aug
        case 9: iComp = 30; iDecr = 30; break; //sep
        case 10: iComp = 31; iDecr = 31; break; // oct
        case 11: iComp = 30; iDecr = 30; break; // nov
        }
        if (daysfrom2000 < iComp)
                break;
        daysfrom2000 -=iDecr;
        if (++iMonth == 12) // what ?? getout!!!
            break;
    }
    int iDay  = daysfrom2000;//+1;
    
    int iHour = (int)(flInDay*24);
    int iMinutes = ((flInDay - ((double)iHour)/24.0))*(24.0*60.0);
    int iSec =  (int)( ((flInDay - ((double)iHour)/24.0) - ((double)iMinutes)/(24.0*60.0))*(24.0*60.0*60.0));
    int iMils = (int)((flInDay - ((double)iHour)/(24.0) - ((double)iMinutes)/(24.0*60.0) - ((double)iSec)/(24.0*60.0*60.0))*(24.0*60.0*60.0*1000.0));
    ThatTime->wMonth = iMonth;
    ThatTime->wDay = iDay;
    ThatTime->wHour = iHour;
    ThatTime->wMinute = iMinutes;
    ThatTime->wSecond = iSec;
    ThatTime->wMilliseconds = iMils;
    ThatTime->wDayOfWeek = 0;
    //RetTime += (long double)DaysFromTheBeginigOfTheYear + (long double)(iYear*1000);//-1.0/(60.0*60.0*24.0*1000);
    return ConvertDateTimeToTLEEpoch(ThatTime->wDay, ThatTime->wMonth, ThatTime->wYear, ThatTime->wHour, ThatTime->wMinute, ThatTime->wSecond, ThatTime->wMilliseconds);
}
long double ConverTLEEpochDate2JulianDay(long double KeplerDate)
{
    // TLE elements is 1 day based - needs to minus at the end one day
    int iYear = (int)(KeplerDate /1000);
    // date as it is = 2000/01/01     2451544.5, 2451910.5, 2452275.5, 2452640.5, 2453005.5, 2453371.5, 2453736.5, 2013-2456293.5
    // 
    double t2000_01_01_01 = 2451544.5;
    switch(iYear)
    {
        // add years = if you still alive !!! or just put formula if ((iYear-1)%4 == 0) t2000_01_01_01+=366; else t2000_01_01_01+=365;
    case 24:t2000_01_01_01+=365;
    case 23:t2000_01_01_01+=365;
    case 22:t2000_01_01_01+=365;
    case 21:t2000_01_01_01+=366;
    case 20:t2000_01_01_01+=365;
    case 19:t2000_01_01_01+=365;
    case 18:t2000_01_01_01+=365;
    case 17:t2000_01_01_01+=366;
    case 16:t2000_01_01_01+=365;
    case 15:t2000_01_01_01+=365;
    case 14:t2000_01_01_01+=365;
    case 13:t2000_01_01_01+=366;
    case 12:t2000_01_01_01+=365;
    case 11:t2000_01_01_01+=365;
    case 10:t2000_01_01_01+=365;
    case  9:t2000_01_01_01+=366;
    case  8:t2000_01_01_01+=365;
    case  7:t2000_01_01_01+=365;
    case  6:t2000_01_01_01+=365;
    case  5:t2000_01_01_01+=366;
    case  4:t2000_01_01_01+=365;
    case  3:t2000_01_01_01+=365;
    case  2:t2000_01_01_01+=365;
    case  1:t2000_01_01_01+=366;
    case  0:;
        // minus years = add if you interesting in anything from last century or use formala!!
    }
    //long it2000_01_01_01 = t2000_01_01_01;
    //double RestOfTheDay = t2000_01_01_01 - (double)it2000_01_01_01;
    return t2000_01_01_01// - RestOfTheDay 
            + KeplerDate - ((long double)(iYear*1000))
            -1; // epoch date is 1== 1 Jan - needs to adjust one day.
}


int iDayOfTheYearZeroBase(int iDay, int iMonth, int iYear)
{
	int iDays = iDay-1;
	switch(iMonth-1)
	{
	case 11:// november
		iDays+=30;
	case 10:// october
		iDays+=31;
	case 9:// september
		iDays+=30;
	case 8://august
		iDays+=31;
	case 7:// july
		iDays+=31;
	case 6:// june
		iDays+=30;
	case 5:// may
		iDays+=31;
	case 4:// april
		iDays+=30;
	case 3:// march
		iDays+=31;
	case 2:// february
		if ((iYear %4) ==0) // leap year
			iDays+=29;
		else
			iDays+=28;
	case 1:iDays+=31; // january
	case 0:iDays+=0;
		break;
	}
	return iDays;
}
double ConvertDateTimeToTLEEpoch(int iDay, int iMonth, int iYear, int iHour, int iMin, int iSec, int iMills)
{
    // An epoch of 98001.00000000 corresponds to 0000 UT on 1998 January 01in other words, 
    // midnight between 1997 December 31 and 1998 January 01. 
    // An epoch of 98000.00000000 would actually correspond to the beginning of 1997 December 31strange as that might seem. 
    // Note that the epoch day starts at UT midnight (not noon) and that all times are measured mean solar rather than sidereal time units.
    int mYear = iYear-2000;
    int mDays = iDayOfTheYearZeroBase(iDay, iMonth, iYear)+1;
	long mCurSec = iHour * 60*60;
    mCurSec += iMin *60;
    mCurSec += iSec;
	double dEpoch = mYear *1000.0 + mDays;
	dEpoch += (((double)mCurSec)+ ((double)iMills/1000.))/ (24.0*60.0*60.0);
    return dEpoch;
}

long double SubEpoch(long double One, long double Two)
{
    int Y1 = (int)(One /1000);
    int Y2 = (int)(Two /1000);
    if (Y1 < 20)
        Y1 +=100;
    if (Y2 < 20)
        Y2+=100;
    int N1=(Y1-69)/4;
	if (Y1 < 70) 
		N1=(Y1-72)/4;
    int N2=(Y2-69)/4;
	if (Y2 < 70) 
		N2=(Y2-72)/4;
    if (Y1-Y2 != 0) 
    {
        return ( (Y1-Y2-1)* 365.0 + (N1 - N2) + (One - Y1*1000.0) + (365 - Two + Y2*1000.0));
    }
    else
    {
        return One - Two;
    }
}



void ConvertDateFromXML(char *pszQuo, long double &ld_TotalDays, long double &ld_dStartJD, long double &ld_dStartTLEEpoch)
{
    ld_TotalDays = 0;
    ld_dStartJD = atof(pszQuo);    // format: <TRA:setting name="dStartJD0" value="2455625.1696833" />
    if (ld_dStartJD <=0) // negativge value set current date munis amount of the minutes (negative -3 mean = total time == 3 minutes starting from curent time)
    {                 // i.e. -60 = total 60 minutes starting from -57 min, and 3 minutes in a future
        SYSTEMTIME MyTime;
        TIME_ZONE_INFORMATION tmzone;
        //SYSTEMTIME ThatTime;

        int Iret = GetTimeZoneInformation(&tmzone); 
        GetSystemTime(&MyTime);
        //double dEpoch = ConvertDateTimeToTLEEpoch(1, 1, 2013, 0, 0, 0, 0);
        //dStartJD = ConverTLEEpochDate2JulianDay(dEpoch);
         double dEpoch = ConvertDateTimeToTLEEpoch(MyTime.wDay, MyTime.wMonth, MyTime.wYear, MyTime.wHour, MyTime.wMinute, MyTime.wSecond, MyTime.wMilliseconds);
         ld_dStartJD = ConverTLEEpochDate2JulianDay(dEpoch);
				
        ld_TotalDays = (60.0*atof(pszQuo))/(24.0*60.0*60);
        // negative value !!! + 3 minutes
        ld_dStartJD +=ld_TotalDays + (60.0*dMinFromNow)/(24.0*60.0*60);
    }
    else
    {
        int iYear = (int)(ld_dStartJD/1000);
        if ((iYear > 0) && (iYear < 24)) // this is a <TRA:setting name="dStartJD" value="11291.79166666" />
        {
            ld_dStartJD = ConverTLEEpochDate2JulianDay(ld_dStartJD);
        }
        else
        {                     // 012345678901234567890
            if (ld_dStartJD<=31) // DD/MM/YY HH:MM:SS:MLS format
            {
                int iDD = atoi(&pszQuo[0]);
                int iMO = atoi(&pszQuo[3]);
                int iYY = atoi(&pszQuo[6]);
                int iHH = atoi(&pszQuo[9]);
                int iMM = atoi(&pszQuo[12]);
                int iSS = atoi(&pszQuo[15]);
                int iMLS = atoi(&pszQuo[18]);
                double dTLEEpoch = ConvertDateTimeToTLEEpoch(iDD, iMO, iYY+2000, iHH, iMM, iSS,iMLS);
                //int iDays = iDayOfTheYearZeroBase(iDD, iMO, iYY+2000);
                //int iCurSec = iHH * 60*60;
                //iCurSec += iMM *60;
				//iCurSec += iSS;
				//dStartJD = iYY *1000.0 + iDays;
				//dStartJD += (((double)iCurSec)+ ((double)iMLS/1000.))/ (24.0*60.0*60.0);
				//dStartJD = ConverEpochDate2JulianDay(dStartJD);
                ld_dStartJD = ConverTLEEpochDate2JulianDay(dTLEEpoch);
            }
            else // in a normal format
            {
            }
        }
    }
    SYSTEMTIME ThatTime;
    ld_dStartTLEEpoch = ConvertJulianDayToDateAndTime(ld_dStartJD, &ThatTime);
}
// rotate any point around vector on a angle 
void RotationAngleVect(long double &X, long double &Y, long double &Z, long double Angle, long double VectX, long double VectY, long double VectZ)
{
	// see http://en.wikipedia.org/wiki/Rotation_matrix

	// first make sure that Vector around rotation is a unit vector
	long double dLength = sqrt(VectX*VectX + VectY*VectY + VectZ*VectZ);
	VectX /= dLength;
	VectY /= dLength;
	VectZ /= dLength;
	long double RotX = (cos(Angle) + VectX*VectX*(1-cos(Angle)))*X +
		          (VectX*VectY*(1-cos(Angle)) - VectZ*sin(Angle)) * Y +
				  (VectX*VectZ*(1-cos(Angle)) + VectY*sin(Angle)) *Z;

	long double RotY = (VectY*VectX*(1-cos(Angle)) + VectZ*sin(Angle))*X +
		          (cos(Angle) + VectY*VectY*(1-cos(Angle)))*Y +
				  (VectY*VectZ*(1-cos(Angle)) - VectX*sin(Angle))*Z;

	long double RotZ = (VectZ*VectX*(1-cos(Angle)) - VectY*sin(Angle))*X+
		          (VectZ*VectY*(1-cos(Angle)) + VectX*sin(Angle))*Y+
				  (cos(Angle) + VectZ*VectZ*(1-cos(Angle)))*Z;
	X = RotX;
	Y = RotY;
	Z = RotZ;
}
// calculates angle btw vectors
long double AngleBtw(long double X1,long double Y1,long double Z1,long double X2,long double Y2,long double Z2)
{
	long double v1Len = sqrt(X1*X1 + Y1*Y1 + Z1*Z1);
	long double v2Len = sqrt(X2*X2 + Y2*Y2 + Z2*Z2);
	long double Cosv1v2 = (X1*X2 + Y1*Y2 + Z1*Z2)/v1Len/v2Len;
	long double Angle = acos(Cosv1v2);
	return (Angle * 180 /M_PI);
}
long double AngleBtwNorm(long double X1,long double Y1,long double Z1,long double X2,long double Y2,long double Z2)
{
	long double v1Len = 1.0;
	long double v2Len = 1.0;
	long double Cosv1v2 = (X1*X2 + Y1*Y2 + Z1*Z2)/v1Len/v2Len;
	long double Angle = acos(Cosv1v2);
	return Angle;
}

// calculates ortogonal vector
void Ort(long double &Xpr, long double &Ypr, long double &Zpr, long double u1, long double u2, long double u3, long double v1, long double v2, long double v3)
{
    Xpr = u2*v3 - u3*v2;
    Ypr = u3*v1 - u1*v3;
    Zpr = u1*v2-u2*v1;
    double prMod = sqrt(Xpr*Xpr + Ypr*Ypr +Zpr*Zpr);
    Xpr/=prMod;Ypr/=prMod;Zpr/=prMod;
}
void SUN_08 (int IYEAR,int IDAY,int IHOUR,int MIN,int ISEC,
	long double &GST,long double &SLONG,long double &SRASN,long double &SDEC)
{
	//C*******************************************************************
	//c
	//      SUBROUTINE SUN_08 (IYEAR,IDAY,IHOUR,MIN,ISEC,GST,SLONG,SRASN,SDEC)
	//C
	//C  CALCULATES FOUR QUANTITIES NECESSARY FOR COORDINATE TRANSFORMATIONS
	//C  WHICH DEPEND ON SUN POSITION (AND, HENCE, ON UNIVERSAL TIME AND SEASON)
	//C
	//C-------  INPUT PARAMETERS:
	//C  IYR,IDAY,IHOUR,MIN,ISEC -  YEAR, DAY, AND UNIVERSAL TIME IN HOURS, MINUTES,
	//C    AND SECONDS  (IDAY=1 CORRESPONDS TO JANUARY 1).
	//C
	//C-------  OUTPUT PARAMETERS:
	//C  GST - GREENWICH MEAN SIDEREAL TIME, SLONG - LONGITUDE ALONG ECLIPTIC
	//C  SRASN - RIGHT ASCENSION,  SDEC - DECLINATION  OF THE SUN (RADIANS)
	//C  ORIGINAL VERSION OF THIS SUBROUTINE HAS BEEN COMPILED FROM:
	//C  RUSSELL, C.T., COSMIC ELECTRODYNAMICS, 1971, V.2, PP.184-196.
	//C
	//C  LAST MODIFICATION:  MARCH 31, 2003 (ONLY SOME NOTATION CHANGES)
	//C
	//C     ORIGINAL VERSION WRITTEN BY:    Gilbert D. Mead
	//C
    long double DJ,FDAY;
    long double RAD = 180.0/M_PI;//57.295779513;
	//C
    //IF(IYEAR.LT.1901.OR.IYEAR.GT.2099) RETURN
	if(IYEAR < 1901 || IYEAR>2099) 
		return;
    FDAY=(IHOUR*3600.0+MIN*60.0+ISEC)/86400.0;
    DJ=365*(IYEAR-1900)+(IYEAR-1901)/4+IDAY-0.5+FDAY;
    long double T=DJ/36525.0;
    long double VL=fmod((long double)279.696678+(long double)0.9856473354*(long double)DJ,(long double)360.0);
    GST=fmod((long double)279.690983+(long double)0.9856473354*(long double)DJ+(long double)360.0*FDAY+(long double)180.0,(long double)360.0)/RAD;
    long double G=fmod((long double)358.475845+(long double)0.985600267*(long double)DJ,(long double)360.0)/RAD;
    SLONG=(VL+(1.91946-0.004789*T)*sin(G)+0.020094*sin(2.0*G))/RAD;
    //IF(SLONG.GT.6.2831853) SLONG=SLONG-6.2831853
	if(SLONG > (M_PI*2))//6.2831853) 
		SLONG=SLONG-(M_PI*2);//6.2831853;
    //IF (SLONG.LT.0.) SLONG=SLONG+6.2831853
	if (SLONG < 0.0) 
		SLONG=SLONG+(M_PI*2);//6.2831853;
    long double OBLIQ=(23.45229-0.0130125*T)/RAD;
    long double SOB=sin(OBLIQ);
    long double SLP=SLONG-9.924E-5;
	//C
	//C   THE LAST CONSTANT IS A CORRECTION FOR THE ANGULAR ABERRATION DUE TO
	//C   EARTH'S ORBITAL MOTION
	//C
    long double SIND=SOB*sin(SLP);
    long double COSD=sqrt((long double)1.-SIND*SIND);
    long double SC=SIND/COSD;
    SDEC=atan(SC);
    SRASN=M_PI-atan2(cos(OBLIQ)/SOB*SC,-cos(SLP)/COSD);
    //RETURN
    //  END
}
/*
FUNCTION ACTAN(SINX,COSX)
COMMON/C2/DE2RA,PI,PIO2,TWOPI,X3PIO2
ACTAN=0.
IF (COSX.EQ.0. ) GO TO 5
IF (COSX.GT.0. ) GO TO 1
ACTAN=PI
GO TO 7
1 IF (SINX.EQ.0. ) GO TO 8
IF (SINX.GT.0. ) GO TO 7
ACTAN=TWOPI
GO TO 7
5 IF (SINX.EQ.0. ) GO TO 8
IF (SINX.GT.0. ) GO TO 6
ACTAN=X3PIO2
GO TO 8
6 ACTAN=PIO2
GO TO 8
7 TEMP=SINX/COSX
ACTAN=ACTAN+ATAN(TEMP)
8 RETURN
END
*/
/*
FUNCTION FMOD2P(X)
COMMON/C2/DE2RA,PI,PIO2,TWOPI,X3PIO2
FMOD2P=X
I=FMOD2P/TWOPI
FMOD2P=FMOD2P-I*TWOPI
IF(FMOD2P.LT.0) FMOD2P=FMOD2P+TWOPI
RETURN
END
*/
// The function subroutine THETAG is passed the epoch time exactly as it appears on the input element cards.
// The routine converts this time to days since 1950 Jan 0.0 UTC, stores this in the COMMON E1,
// and returns the right ascension of Greenwich at epoch (in radians).

// usefull: http://en.wikipedia.org/wiki/Equation_of_time
//          http://www2.arnes.si/~gljsentvid10/sidereal.htm
//          http://www.iausofa.org/2001_0331/sofa/eqeq94.for
//          http://www.iausofa.org/2001_0331/sofa/gmst82.for
//          http://misc.gis.tu-berlin.de/igg/htdocs-kw/fileadmin/Daten_MCA/EM1/bsp.pdf
//          http://misc.gis.tu-berlin.de/igg/htdocs-kw/fileadmin/Daten_MCA/EM1/a6.pdf

long double GreenwichAscensionFromTLEEpoch(long double EP, long double &preEps, long double &preTetta, long double &preZ, long double &nutEpsilon, long double &nutDFeta)
{
    
	//FUNCTION THETAG(EP)
	//COMMON /E1/XMO,XNODEO,OMEGAO,EO,XINCL,XNO,XNDT2O,XNDD6O,BSTAR,
	//1 X,Y,Z,XDOT,YDOT,ZDOT,EPOCH,DS50
	//DOUBLE PRECISION EPOCH,D,THETA,TWOPI,YR,TEMP,EP,DS50
	long double EPOCH,D,THETA,TWOPI,YR,TEMP,DS50;
    long double THETAG;
    long double DaysFromJ2000;
    long iDaysFromJ2000;
    long double PartOfTheDay;
    long double CenturyFromJ2000;

    long double Tstar;
    long double dFeta,dEpsilon;
    long double _Epsilon;
    long double H0;
    long double DeltaH;
    // J000 == 2451545,0 JD == 01/Jan/2000 12:00

	TWOPI=2.0*M_PI;//6.28318530717959D0
	YR=(EP+2.e-7)*1.e-3;
	int JY=(int)(YR);
    
	YR=JY;
	D=EP-YR*1.e3;
	//IF(JY.LT.10) JY=JY+80
    preEps = 0;
    preTetta = 0;
    preZ = 0;

#if 1    
    if (JY < 20) // just from J2000 == 
    {
        // from J2000:
        // 24110.54841sec / 12/60/60 * M_PI= 1.7533685592332655129130610478964 
        //8640184.812866
        // 
        int N;
        if (JY == 0)
            N = 0;
        else 
            N = (JY-1)/4+1;
        // tle epoch jan 1 (0 day of the year) is the day number 1 and noon is 0.5 day (has to be minused)
        // also it referce as d0
        DaysFromJ2000=365.0*(JY) +N + D-1.0-0.5;  
        // that is integer value of d0 the days
        iDaysFromJ2000= (long)(DaysFromJ2000);
        // that is also T0 == d0/36525
        CenturyFromJ2000 = DaysFromJ2000/36525.0;
        // that is Tstar==Deltat == (JD( at 0 hour of day ) - JD (J2000 at 12 hour UT))/36525
        Tstar =(((long double)iDaysFromJ2000)+0.5)/36525.0;
        PartOfTheDay = D - (double long)(long)D;
        // from https://www2.mps.mpg.de/homes/fraenz/systems/systems2art/node3.html
        dFeta = -0.0048*sin((125-0.05295*DaysFromJ2000)*M_PI/180) - 0.0004*cos((200.9 +1.97129*DaysFromJ2000)*M_PI/180);
        dEpsilon = 0.0026 * cos((125-0.05295*DaysFromJ2000)*M_PI/180) - 0.0002*sin((200.9 +1.97129*DaysFromJ2000)*M_PI/180);
        //dFeta = dFeta *M_PI / 180;
        // Epsilon = _Epsilon + dEpsilon (page 12 from http://www.scharmn.narod.ru/AVD/bookAES2nn.pdf) 
        _Epsilon = 23.43921111 + (-0.013004167 + (-0.000000164 - 0.000000504*Tstar)*Tstar)*Tstar;
        nutEpsilon = _Epsilon + dEpsilon;
        nutEpsilon = nutEpsilon *M_PI / 180;
        nutDFeta = dFeta *M_PI / 180;
        DeltaH = dFeta * cos(nutEpsilon)/360.0;
        //H0 = 24110.54841 + (8640184.812866 + (0.093104- 6.2e-10*Tstar)*Tstar)*Tstar +   (PartOfTheDay-DeltaH)*86401.84812866;//86636.555367908688 // wrong!!!
        //H0 = 24110.54841 + (8640184.812866 + (0.093104- 6.2e-10*Tstar)*Tstar)*Tstar +   (PartOfTheDay-DeltaH)*86636.555367908688;//
        //H0 = 24110.54841 + (8640184.812866 + (0.093104- 6.2e-10*Tstar)*Tstar)*Tstar +   (PartOfTheDay-DeltaH)*86636.555367908577283124054644656;
        H0 = 24110.54841 + (8640184.812866 + (0.093104- 6.2e-10*Tstar)*Tstar)*Tstar +   (1.002737909350795+(5.9006e-11 -5.9E-15*Tstar)*Tstar)*86400*(PartOfTheDay-DeltaH);//*86401.84812866;//86636.555367908688
        THETAG = H0/86400 * 2.0*M_PI;
        THETAG =fmod(THETAG, (long double)2.0*M_PI);
        preEps = (2306.2181 + (0.30188 + 0.017998*Tstar)*Tstar)*Tstar; // in seconds
        preTetta = (2004.3109  + (0.42665 - 0.041833*Tstar)* Tstar)*Tstar; // in seconds
        preZ = preEps + (0.79280 + 0.018203* Tstar)* Tstar*Tstar;  // in seconds
        // now in radians;
        preEps = preEps *M_PI / (180*60*60);
        preTetta = preTetta * M_PI / (180*60*60);
        preZ = preZ * M_PI*2 / (180*60*60);
        return THETAG;
    }
#endif
	if(JY < 20) 
		JY=JY+100;
	int N=(JY-69)/4;
	//IF(JY.LT.70) N=(JY-72)/4
	if (JY < 70) 
		N=(JY-72)/4;
	DS50=7305.0 + 365.0*(JY-70) +N + D;
    // 6.3003880987 = 1.0027379093054531539043156765359
    // 1.9801110581855904429828570117483 it is bigger then 1.72944494 (==in days = 0.27524971100626634345509703401275 in sec= 23781.575030941412074520383738702)
    // difference from J2000 is 328.9733790585879254796162612984 sec == 5min+28.9733790585879254796162612984sec
    // difference in 
    // i.e 8640184.812866*Tstar + 0.093104*Tstar*Tstar- 6.2e-10*Tstar*Tstar*Tstar ==1239946.4147585845
    // 
	THETA=1.72944494 + 6.3003880987*DS50;
    
	TEMP=THETA/TWOPI;
	int I=(int)(TEMP);
	TEMP=I;
	THETAG=THETA-TEMP*TWOPI;
	//IF(THETAG.LT.0.D0) THETAG=THETAG+TWOPI
	if(THETAG < 0.0) 
		THETAG=THETAG+TWOPI;
	return THETAG;
	//RETURN
	//END
}
// in FORTARN variable with a name begining with I is an integer variable 
// The function subroutine FMOD2P is
// passed an angle in radians and returns the angle in radians within the range of 0 to 2 PI.
long double FMOD2P(long double X)
{
	// COMMON/C2/DE2RA,PI,PIO2,TWOPI,X3PIO2
	//double DE2RA,PI,PIO2,TWOPI,X3PIO2;
	long double FMOD2P;
	int I;
	FMOD2P=X;
	//I=FMOD2P/TWOPI;
	I=(int)(FMOD2P/(2.0*M_PI));
	//FMOD2P=FMOD2P-I*TWOPI;
	FMOD2P=FMOD2P-I*(2.0*M_PI);
	//IF(FMOD2P.LT.0) FMOD2P=FMOD2P+TWOPI
	if (FMOD2P < 0.0) 
		FMOD2P=FMOD2P+2.0*M_PI;
	return FMOD2P;
//RETURN
//END
}
// strange function :The function subroutine ACTAN is passed the values of sine and cosine in that order and
// it returns the angle in radians within the range of 0 to 2 pi
long double ACTAN(long double SINX,long double COSX)
{
	long double ACTAN,TEMP;
	//COMMON/C2/DE2RA,PI,PIO2,TWOPI,X3PIO2
	long double X3PIO2 = 3.0*M_PI/2.0;
	long double PIO2 = M_PI/2.0;
	ACTAN=0.0;
	if (COSX == 0.0) goto M_5;
	if (COSX > 0.0) goto M_1;
	ACTAN=M_PI;
	goto M_7;
M_1:
	if (SINX == 0.0) goto M_8;
	if (SINX > 0.0) goto M_7;
	ACTAN=2.0*M_PI;
	goto M_7;
M_5:
	if (SINX == 0.0) goto M_8;
	if (SINX > 0.0) goto M_6;
	ACTAN=X3PIO2;
	goto M_8;
M_6:
	ACTAN=PIO2;
	goto M_8;
M_7:
	TEMP=SINX/COSX;
	ACTAN=ACTAN+atan(TEMP);
M_8:
	return ACTAN;
	//RETURN
	//END
}

// original and less acurate
void SGP(long double TS, long double XNDT2O,long double XNDD6O,/*double IEXP,*/long double nuBSTAR,/*double IBEXP,*/long double XINCL, long double XNODEO,long double EO, long double OMEGAO, long double XMO, long double XNO, 
	long double &X,long double &Y,long double &Z,long double &XDOT,long double &YDOT,long double &ZDOT)
{
	//* SGP 31 OCT 80
    //SUBROUTINE SGP(IFLAG,TSINCE)
	long double TSINCE = TS;
	//COMMON/E1/XMO,XNODEO,OMEGAO,EO,XINCL,XNO,XNDT2O,XNDD6O,BSTAR,
	//1 X,Y,Z,XDOT,YDOT,ZDOT,EPOCH,DS50
	//COMMON/C1/CK2,CK4,E6A,QOMS2T,S,TOTHRD,
	//1 XJ3,XKE,XKMPER,XMNPDA,AE
	//DATA DE2RA,E6A,PI,PIO2,QO,SO,TOTHRD,TWOPI,X3PIO2,XJ2,XJ3,
	//1 XJ4,XKE,XKMPER,XMNPDA,AE/.174532925E-1,1.E-6,
	//2 3.14159265,1.57079633,120.0,78.0,.66666667,
	//4 6.2831853,4.71238898,1.082616E-3,-.253881E-5,
	//5 -1.65597E-6,.743669161E-1,6378.135,1440.,1./
	//double DE2RA= .174532925E-1;
	// double E6A = 1.E-6;
	//double PI= 3.14159265;
	//double PIO2 = 1.57079633;
	//double QO= 120.0;
	//double SO= 78.0;
	//double TOTHRD= .66666667;
	//double TWOPI = 6.2831853;
	//double X3PIO2 = 4.71238898;
#if _USE_ORIGINAL
	long double XKE = BIG_XKE;//.743669161E-1;
	//long double XKMPER = 6378.1350;
	long double XJ2 = 1.082616E-3; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -.253881E-5; // the third gravitational zonal harmonic of the Earth
    double E6A = 1.E-6;
#else
	long double XKE = 7.43669161331734132e-2;
//	long double XKMPER = 6378.137;
	long double XJ2 = 0.10826360229840e-02; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -0.25325160653E-05; // the third gravitational zonal harmonic of the Earth
    double E6A = 1.E-12;
#endif

	//double XJ4 = -1.65597E-6;
	//double XKMPER = 6378.135;
	//double XMNPDA= 1440.;
	long double AE =1.;

	int IFLAG;
    //double XMO,XNODEO,OMEGAO,EO,XINCL,XNO,XNDT2O,XNDD6O,BSTAR,
    ///*X,Y,Z,XDOT,YDOT,ZDOT,*/EPOCH,DS50;
    //double CK2,CK4,E6A,QOMS2T,S,TOTHRD,
    //XJ3,XKE,XKMPER,XMNPDA,AE;
    //double EPOCH, DS50;
	long double C1,C2,C3,C4;
	long double COSIO,SINIO;
	long double A1,D1,AO,PO,QO,XLO,D1O,D2O,D3O,D4O,PO2NO,OMGDT,XNODOT,C5,C6,E,A,P,XNODES,OMGAS,XLS,AXNSL,AYNSL,XL,U;
	int ITEM3;
	long double EO1,TEM5;
	long double SINEO1,COSEO1,TEM2,ECOSE,ESINE,EL2,PL,PL2,R,RDOT,RVDOT,TEMP,SINU,COSU,SU,SIN2U,COS2U,RK,UK,XNODEK,XINCK,SINUK,COSUK,SINNOK,COSNOK;
	long double SINIK,COSIK,XMX,XMY,UX,UY,UZ,VX,VY,VZ;
	//CK2=.5*XJ2*AE**2
	long double CK2=.5*XJ2*AE*AE;
    //if (IFLAG == 0) goto M_19;
    // * INITIALIZATION
    C1= CK2*1.5;
    C2= CK2/4.0;
    C3= CK2/2.0;
    C4= XJ3*(AE*AE*AE)/(4.0*CK2);
    COSIO=cos(XINCL);
    SINIO=sin(XINCL);
    //A1=(XKE/XNO)**TOTHRD;
	A1 = pow((XKE/XNO),(long double)2.0/(long double)3.0);
	//D1= C1/A1/A1*(3.*COSIO*COSIO-1.)/(1.-EO*EO)**1.5;
	D1= C1/A1/A1*(3.*COSIO*COSIO-1.)/pow((1.-EO*EO),(long double)1.5);
	AO=A1*(1.-1./3.*D1-D1*D1-134./81.*D1*D1*D1);
    PO=AO*(1.-EO*EO);
	QO=AO*(1.-EO);
	XLO=XMO+OMEGAO+XNODEO;
	D1O= C3 *SINIO*SINIO;
	D2O= C2 *(7.*COSIO*COSIO-1.);
	D3O=C1*COSIO;
	D4O=D3O*SINIO;
	PO2NO=XNO/(PO*PO);
	OMGDT=C1*PO2NO*(5.*COSIO*COSIO-1.);
	XNODOT=-2.*D3O*PO2NO;
	C5=.5*C4*SINIO*(3.+5.*COSIO)/(1.+COSIO);
	C6=C4*SINIO;
	IFLAG=0;
	//* UPDATE FOR SECULAR GRAVITY AND ATMOSPHERIC DRAG
M_19: 
	A = XNO+(2.*XNDT2O+3.*XNDD6O*TSINCE)*TSINCE;
	//A=AO*(XNO/A)**TOTHRD;
	A=pow(AO*(XNO/A),(long double)2.0/(long double)3.0);
	E=1.0E-6;
	//IF(A.GT.QO) E=1.-QO/A
	if(A>QO) 
		E=1.-QO/A;
	P=A*(1.-E*E);
	XNODES= XNODEO+XNODOT*TSINCE;
	OMGAS= OMEGAO+OMGDT*TSINCE;
	XLS=FMOD2P(XLO+(XNO+OMGDT+XNODOT+(XNDT2O+XNDD6O*TSINCE)*TSINCE)*TSINCE);
   // LONG PERIOD PERIODICS
M_7:
	AXNSL=E*cos(OMGAS);
	AYNSL=E*sin(OMGAS)-C6/P;
	XL=FMOD2P(XLS-C5/P*AXNSL);
	//* SOLVE KEPLERS EQUATION
	U=FMOD2P(XL-XNODES);
	ITEM3=0;
	EO1=U;
	TEM5=1.0;
M_20:
	SINEO1=sin(EO1);
	COSEO1=cos(EO1);
	//IF(ABS(TEM5).LT.E6A) GO TO 30
	if(abs(TEM5)<1E-6) 
		goto M_30;
	//IF(ITEM3.GE.10) GO TO 30
	if(ITEM3 > 30) 
		goto M_30;
	ITEM3=ITEM3+1;
	TEM5=1.-COSEO1*AXNSL-SINEO1*AYNSL;
	TEM5=(U-AYNSL*COSEO1+AXNSL*SINEO1-EO1)/TEM5;
	TEM2=abs(TEM5);
	//IF(TEM2.GT.1.) TEM5=TEM2/TEM5
	if(TEM2>1.0) 
		TEM5=TEM2/TEM5;
	EO1=EO1+TEM5;

	goto M_20;
	//* SHORT PERIOD PRELIMINARY QUANTITIES
M_30:
	ECOSE=AXNSL*COSEO1+AYNSL*SINEO1;
	ESINE=AXNSL*SINEO1-AYNSL*COSEO1;
	EL2=AXNSL*AXNSL+AYNSL*AYNSL;
	PL=A*(1.-EL2);
	PL2=PL*PL;
	R=A*(1.-ECOSE);
	RDOT=XKE*sqrt(A)/R*ESINE;
	RVDOT=XKE*sqrt(PL)/R;
	TEMP=ESINE/(1.+sqrt(1.-EL2));
	SINU=A/R*(SINEO1-AYNSL-AXNSL*TEMP);
	COSU=A/R*(COSEO1-AXNSL+AYNSL*TEMP);
	//SU=ACTAN(SINU,COSU);
	SU=ACTAN(SINU,COSU);
	//* UPDATE FOR SHORT PERIODICS
	SIN2U=(COSU+COSU)*SINU;
	COS2U=1.-2.*SINU*SINU;
	RK=R+D1O/PL*COS2U;
	UK=SU-D2O/PL2*SIN2U;
	XNODEK=XNODES+D3O*SIN2U/PL2;
	XINCK =XINCL+D4O/PL2*COS2U;
	//* ORIENTATION VECTORS
M_8:
	SINUK=sin(UK);
	COSUK=cos(UK);
	SINNOK=sin(XNODEK);
	COSNOK=cos(XNODEK);
	SINIK=sin(XINCK);
	COSIK=cos(XINCK);
	XMX=-SINNOK*COSIK;
	XMY=COSNOK*COSIK;
	UX=XMX*SINUK+COSNOK*COSUK;
	UY=XMY*SINUK+SINNOK*COSUK;
	UZ=SINIK*SINUK;
	VX=XMX*COSUK-COSNOK*SINUK;
	VY=XMY*COSUK-SINNOK*SINUK;
	VZ=SINIK*COSUK;
	//* POSITION AND VELOCITY
	X=RK*UX;
	Y=RK*UY;
	Z=RK*UZ;
	XDOT=RDOT*UX;
	YDOT=RDOT*UY;
	ZDOT=RDOT*UZ;
	XDOT=RVDOT*VX+XDOT;
	YDOT=RVDOT*VY+YDOT;
	ZDOT=RVDOT*VZ+ZDOT;
//RETURN
//END
}
// original, more acurate, takes account about drag == according Aksenov needs to use exact formulas from SGP4 to correctly process
// data. Backwards formulas should applied before everything 
// Read comments: (do) RECOVER ORIGINAL MEAN MOTION (XNODP) AND SEMIMAJOR AXIS (AODP) FROM INPUT ELEMENTS
void SGP4(long double TSINCE,/*double EPOCH,*/ 
          long double nuXNDT2O, 
          long double nuXNDD6O,/*IEXP,*/
          long double BSTAR,/*IBEXP,*/
	      long double XINCL,  // the mean inclination at epoch
          long double XNODEO, //the mean longitude of ascending node at epoch
          long double EO,     // the mean eccentricity at epoch
          long double OMEGAO, // the mean argument of perigee at epoch
          long double XMO,   // (M0) the mean mean anomaly at epoch
          long double XNO,   // (k0) the SGP type mean mean motion at epoch
		  long double &X,long double &Y,long double &Z,long double &XDOT,long double &YDOT,long double &ZDOT)
{
//COMMON/E1/XMO,XNODEO,OMEGAO,EO,XINCL,XNO,XNDT2O,
//1 XNDD6O,BSTAR,X,Y,Z,XDOT,YDOT,ZDOT,EPOCH,DS50
//COMMON/C1/CK2,CK4,E6A,QOMS2T,S,TOTHRD,
//1 XJ3,XKE,XKMPER,XMNPDA,AE
	//long double /*EPOCH,*/ DS50;
#if _USE_ORIGINAL
	long double XKE = BIG_XKE;//.743669161E-1;
	long double XKMPER = 6378.1350;
	long double XJ2 = 1.082616E-3; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -.253881E-5; // the third gravitational zonal harmonic of the Earth
	long double XJ4 = -1.65597E-6; // the fourth gravitational zonal harmonic of the Earth
    double E6A = 1.E-6;
#else
	long double XKE = 7.43669161331734132e-2;
	long double XKMPER = 6378.137;
	long double XJ2 = 0.10826360229840e-02; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -0.25325160653E-05; // the third gravitational zonal harmonic of the Earth
	long double XJ4 = -0.16185636000E-05; // the fourth gravitational zonal harmonic of the Earth
    double E6A = 1.E-12;
#endif
	//IF (IFLAG .EQ. 0) GO TO 100
	//* RECOVER ORIGINAL MEAN MOTION (XNODP) AND SEMIMAJOR AXIS (AODP)
	//* FROM INPUT ELEMENTS
	//A1=(XKE/XNO)**TOTHRD;
	long double AE = 1.0;          // the equatorial radius of the Earth - actualy it is not true it is one == everything measuared in that radiuses
	long double QO =120.0;         // parameter for the SGP4/SGP8 density function
	long double SO = 78.0;         // parameter for the SGP4/SGP8 density function

	long double CK2=.5*XJ2*AE*AE;
	//CK4=-.375*XJ4*AE**4
	long double CK4=-.375*XJ4*AE*AE*AE*AE;
	long double QOMS2T=pow(((QO-SO)*AE/XKMPER),(long double)4.0);
	long double S=AE*(1.+SO/XKMPER);

    //The original mean motion (n0") and semimajor axis (a0") are first recovered from the input elements by the equations:
    //
    // a1 = (k0 /n0) ** (2/3)
    //
    // b1 = 3/2 * k2/a1 * (3 * (cos(i0))**2 -1)/(1-e0**2)**(3/2)
    //
    // a0 = a1 * (1 - 1/3 b1 - b1**2  - 134/81 b1**3)
    //
    // b0 - 3/2 * k2/(a0**2) * (3 * (cos(i0))**2 - 1)/(1- e9**2)3/2
    //
    // n0" = n0/ (1+b0)
    // a0" = a0/(1-b0)
    //
	//A1=(XKE/XNO)**TOTHRD;
	long double A1=pow((XKE/XNO),(long double)2.0/(long double)3.0);
	long double COSIO=cos(XINCL);
	long double THETA2=COSIO*COSIO;
	long double X3THM1=3.*THETA2-1.;
	long double EOSQ=EO*EO;
	long double BETAO2=1.-EOSQ;
	long double BETAO=sqrt(BETAO2);
	long double DEL1=1.5*CK2*X3THM1/(A1*A1*BETAO*BETAO2);
	//AO=A1*(1.-DEL1*(.5*TOTHRD+DEL1*(1.+134./81.*DEL1)))
	long double AO=A1*(1.-DEL1*(.5*(2.0/3.0)+DEL1*(1.+134./81.*DEL1)));
	long double DELO=1.5*CK2*X3THM1/(AO*AO*BETAO*BETAO2);
    // ProbMeanMotion = XNO / (2*pi) * 1440.0
	long double XNODP=XNO/(1.+DELO);
    // and this is a semimajor axis
	long double AODP=AO/(1.-DELO);
	//* INITIALIZATION
	//* FOR PERIGEE LESS THAN 220 KILOMETERS, THE ISIMP FLAG IS SET AND
	//* THE EQUATIONS ARE TRUNCATED TO LINEAR VARIATION IN SQRT A AND
	//* QUADRATIC VARIATION IN MEAN ANOMALY. ALSO, THE C3 TERM, THE
	//* DELTA OMEGA TERM, AND THE DELTA M TERM ARE DROPPED.
	int ISIMP=0;
	//IF((AODP*(1.-EO)/AE) .LT. (220./XKMPER+AE)) ISIMP=1
	if((AODP*(1.-EO)/AE) < (220./XKMPER+AE)) 
		ISIMP=1;
	//* FOR PERIGEE BELOW 156 KM, THE VALUES OF
	//* S AND QOMS2T ARE ALTERED
	long double S4=S;
	long double QOMS24=QOMS2T;
	long double PERIGE=(AODP*(1.-EO)-AE)*XKMPER;
	//IF(PERIGE .GE. 156.) GO TO 10
	if (PERIGE >= 156.) 
		goto M_10;
	S4=PERIGE-78.;
	//IF(PERIGE .GT. 98.) GO TO 9
	if (PERIGE >=98.) 
		goto M_9;
	S4=20.;
M_9:
	//QOMS24=((120.-S4)*AE/XKMPER)**4;
	QOMS24=pow(((120.-S4)*AE/XKMPER),4);
	S4=S4/XKMPER+AE;
M_16:
M_10:
	long double PINVSQ=1./(AODP*AODP*BETAO2*BETAO2);
	long double TSI=1./(AODP-S4);
	long double ETA=AODP*EO*TSI;
	long double ETASQ=ETA*ETA;
	long double EETA=EO*ETA;
	long double PSISQ=abs(1.-ETASQ);
	//COEF=QOMS24*TSI**4
	long double COEF=QOMS24*TSI*TSI*TSI*TSI;
	//COEF1=COEF/PSISQ**3.5;
	long double COEF1=COEF/pow(PSISQ,(long double)3.5);

	long double C2=COEF1*XNODP*(AODP*(1.+1.5*ETASQ+EETA*(4.+ETASQ))+.75* CK2*TSI/PSISQ*X3THM1*(8.+3.*ETASQ*(8.+ETASQ)));
	long double C1=BSTAR*C2;
	long double SINIO=sin(XINCL);
	//A3OVK2=-XJ3/CK2*AE**3;
	long double A3OVK2=-XJ3/CK2*(AE*AE*AE);
	long double C3=COEF*TSI*A3OVK2*XNODP*AE*SINIO/EO;
	long double X1MTH2=1.-THETA2;
	long double C4=2.*XNODP*COEF1*AODP*BETAO2*(ETA*(2.+.5*ETASQ)+EO*(.5+2.*ETASQ)-2.*CK2*TSI/
			(AODP*PSISQ)*(-3.*X3THM1*(1.-2.*EETA+ETASQ* (1.5-.5*EETA))+.75*X1MTH2*(2.*ETASQ-EETA* (1.+ETASQ))*cos(2.*OMEGAO)));
	long double C5=2.*COEF1*AODP*BETAO2*(1.+2.75*(ETASQ+EETA)+EETA*ETASQ);
	long double THETA4=THETA2*THETA2;
	long double TEMP1=3.*CK2*PINVSQ*XNODP;
	long double TEMP2=TEMP1*CK2*PINVSQ;
	long double TEMP3=1.25*CK4*PINVSQ*PINVSQ*XNODP;
	long double XMDOT=XNODP+.5*TEMP1*BETAO*X3THM1+.0625*TEMP2*BETAO* (13.-78.*THETA2+137.*THETA4);
	long double X1M5TH=1.-5.*THETA2;
	long double OMGDOT=-.5*TEMP1*X1M5TH+.0625*TEMP2*(7.-114.*THETA2+ 395.*THETA4)+TEMP3*(3.-36.*THETA2+49.*THETA4);
	long double XHDOT1=-TEMP1*COSIO;
	long double XNODOT=XHDOT1+(.5*TEMP2*(4.-19.*THETA2)+2.*TEMP3*(3.-7.*THETA2))*COSIO;
	long double OMGCOF=BSTAR*C3*cos(OMEGAO);
	long double XMCOF=-(2.0/3.0)*COEF*BSTAR*AE/EETA;
	long double XNODCF=3.5*BETAO2*XHDOT1*C1;
	long double T2COF=1.5*C1;
	long double XLCOF=.125*A3OVK2*SINIO*(3.+5.*COSIO)/(1.+COSIO);
	long double AYCOF=.25*A3OVK2*SINIO;
	//DELMO=(1.+ETA*COS(XMO))**3
	long double DELMO=pow((1.+ETA*cos(XMO)),3);
	long double SINMO=sin(XMO);
	long double X7THM1=7.*THETA2-1.;
	// IF(ISIMP .EQ. 1) GO TO 90
	if (ISIMP == 1) 
		goto M_90;
	long double C1SQ=C1*C1;
	long double D2=4.*AODP*TSI*C1SQ;
	long double TEMP=D2*TSI*C1/3.;
	long double D3=(17.*AODP+S4)*TEMP;
	long double D4=.5*TEMP*AODP*TSI*(221.*AODP+31.*S4)*C1;
M_17:
	long double T3COF=D2+2.*C1SQ;
	long double T4COF=.25*(3.*D3+C1*(12.*D2+10.*C1SQ));
	long double T5COF=.2*(3.*D4+12.*C1*D3+6.*D2*D2+15.*C1SQ*(2.*D2+C1SQ));
M_90:
	//IFLAG=0;
	//* UPDATE FOR SECULAR GRAVITY AND ATMOSPHERIC DRAG
M_100:
	long double XMDF=XMO+XMDOT*TSINCE;
	long double OMGADF=OMEGAO+OMGDOT*TSINCE;
	long double XNODDF=XNODEO+XNODOT*TSINCE;
	long double OMEGA=OMGADF;
	long double XMP=XMDF;
	long double TSQ=TSINCE*TSINCE;
	long double XNODE=XNODDF+XNODCF*TSQ;
	long double TEMPA=1.-C1*TSINCE;
	long double TEMPE=BSTAR*C4*TSINCE;
	long double TEMPL=T2COF*TSQ;
	// IF(ISIMP .EQ. 1) GO TO 110
	if (ISIMP == 1) 
		goto M_110;
	long double DELOMG=OMGCOF*TSINCE;
	// DELM=XMCOF*((1.+ETA*COS(XMDF))**3-DELMO)
	long double DELM=XMCOF*(pow((1.+ETA*cos(XMDF)),3)-DELMO);
	TEMP=DELOMG+DELM;
	XMP=XMDF+TEMP;
	OMEGA=OMGADF-TEMP;
	long double TCUBE=TSQ*TSINCE;
	long double TFOUR=TSINCE*TCUBE;
	TEMPA=TEMPA-D2*TSQ-D3*TCUBE-D4*TFOUR;
	TEMPE=TEMPE+BSTAR*C5*(sin(XMP)-SINMO);
	TEMPL=TEMPL+T3COF*TCUBE+TFOUR*(T4COF+TSINCE*T5COF);
M_110:
	//A=AODP*TEMPA**2;
	long double A=AODP*TEMPA*TEMPA;
	long double E=EO-TEMPE;
	long double XL=XMP+OMEGA+XNODE+XNODP*TEMPL;
	long double BETA=sqrt(1.-E*E);
	//XN=XKE/A**1.5
	long double XN=XKE/pow(A,(long double)1.5);
	//* LONG PERIOD PERIODICS
	long double AXN=E*cos(OMEGA);
	TEMP=1./(A*BETA*BETA);
	long double XLL=TEMP*XLCOF*AXN;
	long double AYNL=TEMP*AYCOF;
	long double XLT=XL+XLL;
	long double AYN=E*sin(OMEGA)+AYNL;
	//* SOLVE KEPLERS EQUATION
	long double CAPU=FMOD2P(XLT-XNODE);
M_18:
	TEMP2=CAPU;
	// DO 130 I=1,10
	long double SINEPW;
	long double COSEPW;
	long double TEMP4;
	long double TEMP5;
	long double TEMP6;
	long double EPW;
	for (int i =1; i <=30; i++)
	{
		SINEPW=sin(TEMP2);
		COSEPW=cos(TEMP2);
		TEMP3=AXN*SINEPW;
		TEMP4=AYN*COSEPW;
		TEMP5=AXN*COSEPW;
		TEMP6=AYN*SINEPW;
		EPW=(CAPU-TEMP4+TEMP3-TEMP2)/(1.-TEMP5-TEMP6)+TEMP2;
		//IF(ABS(EPW-TEMP2) .LE. E6A) GO TO 140
		if(abs(EPW-TEMP2) <= 1.e-15) 
			goto M_140;
M_130:	TEMP2=EPW;
	}

	//* SHORT PERIOD PRELIMINARY QUANTITIES
M_140:
	long double ECOSE=TEMP5+TEMP6;
	long double ESINE=TEMP3-TEMP4;
	long double ELSQ=AXN*AXN+AYN*AYN;
	TEMP=1.-ELSQ;
	long double PL=A*TEMP;
	long double R=A*(1.-ECOSE);
	TEMP1=1./R;
	long double RDOT=XKE*sqrt(A)*ESINE*TEMP1;
	long double RFDOT=XKE*sqrt(PL)*TEMP1;
	TEMP2=A*TEMP1;
	long double BETAL=sqrt(TEMP);
	TEMP3=1./(1.+BETAL);
	long double COSU=TEMP2*(COSEPW-AXN+AYN*ESINE*TEMP3);
	long double SINU=TEMP2*(SINEPW-AYN-AXN*ESINE*TEMP3);
	long double U=ACTAN(SINU,COSU);
	long double SIN2U=2.*SINU*COSU;
	long double COS2U=2.*COSU*COSU-1.;
	TEMP=1./PL;
	TEMP1=CK2*TEMP;
	TEMP2=TEMP1*TEMP;
	// * UPDATE FOR SHORT PERIODICS
	long double RK=R*(1.-1.5*TEMP2*BETAL*X3THM1)+.5*TEMP1*X1MTH2*COS2U;
	long double UK=U-.25*TEMP2*X7THM1*SIN2U;
	long double XNODEK=XNODE+1.5*TEMP2*COSIO*SIN2U;
	long double XINCK=XINCL+1.5*TEMP2*COSIO*SINIO*COS2U;
	long double RDOTK=RDOT-XN*TEMP1*X1MTH2*SIN2U;
	long double RFDOTK=RFDOT+XN*TEMP1*(X1MTH2*COS2U+1.5*X3THM1);
	//* ORIENTATION VECTORS
	long double SINUK=sin(UK);
	long double COSUK=cos(UK);
M_19:
	long double SINIK=sin(XINCK);
	long double COSIK=cos(XINCK);
	long double SINNOK=sin(XNODEK);
	long double COSNOK=cos(XNODEK);
	long double XMX=-SINNOK*COSIK;
	long double XMY=COSNOK*COSIK;
	long double UX=XMX*SINUK+COSNOK*COSUK;
	long double UY=XMY*SINUK+SINNOK*COSUK;
	long double UZ=SINIK*SINUK;
	long double VX=XMX*COSUK-COSNOK*SINUK;
	long double VY=XMY*COSUK-SINNOK*SINUK;
	long double VZ=SINIK*COSUK;
	//* POSITION AND VELOCITY
	X=RK*UX;
	Y=RK*UY;
	Z=RK*UZ;
	XDOT=RDOTK*UX+RFDOTK*VX;
	YDOT=RDOTK*UY+RFDOTK*VY;
	ZDOT=RDOTK*UZ+RFDOTK*VZ;
//RETURN
//END
}
// 8 THE SGP8 MODEL
// The NORAD mean element sets can be used for prediction with SGP8. All symbols not defned
// below are defned in the list of symbols in Section Twelve. The original mean motion (n00) and o
// semimajor axis (a00) are frst recovered from the input elements by the equations
// * SGP8 14 NOV 80
//SUBROUTINE SGP8(IFLAG,TSINCE)
void SGP8(long double TSINCE,/*double EPOCH,*/ 
          long double nuXNDT2O, 
          long double nuXNDD6O,/*IEXP,*/
          long double BSTAR,/*IBEXP,*/
	      long double XINCL,  // the mean inclination at epoch
          long double XNODEO, //the mean longitude of ascending node at epoch
          long double EO,     // the mean eccentricity at epoch
          long double OMEGAO, // the mean argument of perigee at epoch
          long double XMO,   // (M0) the mean mean anomaly at epoch
          long double XNO,   // (k0) the SGP type mean mean motion at epoch
		  long double &X,long double &Y,long double &Z,long double &XDOT,long double &YDOT,long double &ZDOT)
{
//COMMON/E1/XMO,XNODEO,OMEGAO,EO,XINCL,XNO,XNDT2O,
//1 XNDD6O,BSTAR,X,Y,Z,XDOT,YDOT,ZDOT,EPOCH,DS50
//COMMON/C1/CK2,CK4,E6A,QOMS2T,S,TOTHRD,
//1 XJ3,XKE,XKMPER,XMNPDA,AE
//DOUBLE PRECISION EPOCH, DS50
//DATA RHO/.15696615/
    long double TOTHRD= .6666666666666666666;
    long double RHO =.15696615;
#if _USE_ORIGINAL
	long double XKE = BIG_XKE;//.743669161E-1;
	long double XKMPER = 6378.1350;
	long double XJ2 = 1.082616E-3; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -.253881E-5; // the third gravitational zonal harmonic of the Earth
	long double XJ4 = -1.65597E-6; // the fourth gravitational zonal harmonic of the Earth
    double E6A = 1.E-6;
#else
	long double XKE = 7.43669161331734132e-2;
	long double XKMPER = 6378.137;
	long double XJ2 = 0.10826360229840e-02; //the second gravitational zonal harmonic of the Earth
	long double XJ3 = -0.25325160653E-05; // the third gravitational zonal harmonic of the Earth
	long double XJ4 = -0.16185636000E-05; // the fourth gravitational zonal harmonic of the Earth
    double E6A = 1.E-12;
#endif
	long double AE = 1.0;          // the equatorial radius of the Earth - actualy it is not true it is one == everything measuared in that radiuses
	long double QO =120.0;         // parameter for the SGP4/SGP8 density function
	long double SO = 78.0;         // parameter for the SGP4/SGP8 density function

     long double CK2=.5*XJ2*AE*AE;
     long double CK4=-.375*XJ4*AE*AE*AE*AE;
	long double QOMS2T=pow(((QO-SO)*AE/XKMPER),(long double)4.0);
	long double S=AE*(1.+SO/XKMPER);
    long double XMNPDA = 24.0*60.0;//1440.0; // XMNPDA time units(minutes) /day 1440.0

//IF (IFLAG .EQ. 0) GO TO 100
//* RECOVER ORIGINAL MEAN MOTION (XNODP) AND SEMIMAJOR AXIS (AODP)
//* FROM INPUT ELEMENTS --------- CALCULATE BALLISTIC COEFFICIENT
//* (B TERM) FROM INPUT B* DRAG TERM
long double A1=pow((XKE/XNO),TOTHRD);
long double COSI=cos(XINCL);
long double THETA2=COSI*COSI;
long double TTHMUN=3.*THETA2-1.;
long double EOSQ=EO*EO;
long double BETAO2=1.-EOSQ;
long double BETAO=sqrt(BETAO2);
long double DEL1=1.5*CK2*TTHMUN/(A1*A1*BETAO*BETAO2);
long double AO=A1*(1.-DEL1*(.5*TOTHRD+DEL1*(1.+134./81.*DEL1)));
long double  DELO=1.5*CK2*TTHMUN/(AO*AO*BETAO*BETAO2);
long double AODP=AO/(1.-DELO);
long double XNODP=XNO/(1.+DELO);
long double B=2.*BSTAR/RHO;
//* INITIALIZATION
int ISIMP=0;
long double PO=AODP*BETAO2;
long double POM2=1./(PO*PO);
long double SINI=sin(XINCL);
long double __SING=sin(OMEGAO);
long double COSG=cos(OMEGAO);
long double TEMP=.5*XINCL;
long double SINIO2=sin(TEMP);
long double COSIO2=cos(TEMP);
long double THETA4=THETA2*THETA2;
long double UNM5TH=1.-5.*THETA2;
long double UNMTH2=1.-THETA2;
long double A3COF=-XJ3/CK2*AE*AE*AE;
long double PARDT1=3.*CK2*POM2*XNODP;
long double PARDT2=PARDT1*CK2*POM2;
long double PARDT4=1.25*CK4*POM2*POM2*XNODP;
long double XMDT1=.5*PARDT1*BETAO*TTHMUN;
// page 41
long double XGDT1=-.5*PARDT1*UNM5TH;
long double XHDT1=-PARDT1*COSI;
long double XLLDOT=XNODP+XMDT1+.0625*PARDT2*BETAO*(13.-78.*THETA2+137.*THETA4);
long double OMGDT=XGDT1+.0625*PARDT2*(7.-114.*THETA2+395.*THETA4)+PARDT4*(3.-36.*THETA2+49.*THETA4);
long double XNODOT=XHDT1+(.5*PARDT2*(4.-19.*THETA2)+2.*PARDT4*(3.-7.*THETA2))*COSI;
long double TSI=1./(PO-S);
long double ETA=EO*S*TSI;
long double ETA2=ETA*ETA;
long double PSIM2=fabs(1./(1.-ETA2));
long double ALPHA2=1.+EOSQ;
long double EETA=EO*ETA;
long double COS2G=2.*COSG*COSG-1.0;
long double D5=TSI*PSIM2;
long double D1=D5/PO;
long double D2=12.+ETA2*(36.+4.5*ETA2);
long double D3=ETA2*(15.+2.5*ETA2);
long double D4=ETA*(5.+3.75*ETA2);
long double B1=CK2*TTHMUN;
long double B2=-CK2*UNMTH2;
long double B3=A3COF*SINI;
long double C0=.5*B*RHO*QOMS2T*XNODP*AODP*pow((long double)TSI,(long double)4.0)*pow((long double)PSIM2,(long double)3.5)/sqrt(ALPHA2);
long double C1=1.5*XNODP*ALPHA2*ALPHA2*C0;
long double C4=D1*D3*B2;
long double C5=D5*D4*B3;
long double XNDT=C1*((2.+ETA2*(3.+34.*EOSQ)+5.*EETA*(4.+ETA2)+8.5*EOSQ)+D1*D2*B1+ C4*COS2G+C5*__SING);
long double XNDTN=XNDT/XNODP;
//* IF DRAG IS VERY SMALL, THE ISIMP FLAG IS SET AND THE
//* EQUATIONS ARE TRUNCATED TO LINEAR VARIATION IN MEAN
//* MOTION AND QUADRATIC VARIATION IN MEAN ANOMALY
//IF(ABS(XNDTN*XMNPDA) .LT. 2.16E-3) GO TO 50
if (fabs(XNDTN*XMNPDA) < 2.16E-3) goto M_50;
long double D6=ETA*(30.+22.5*ETA2);
long double D7=ETA*(5.+12.5*ETA2);
long double D8=1.+ETA2*(6.75+ETA2);
long double C8=D1*D7*B2;
long double C9=D5*D8*B3;
long double EDOT=-C0*(ETA*(4.+ETA2+EOSQ*(15.5+7.*ETA2))+EO*(5.+15.*ETA2)+ D1*D6*B1 + C8*COS2G+C9*__SING);
long double D20=.5*TOTHRD*XNDTN;
// page 42
long double ALDTAL=EO*EDOT/ALPHA2;
long double TSDTTS=2.*AODP*TSI*(D20*BETAO2+EO*EDOT);
long double ETDT=(EDOT+EO*TSDTTS)*TSI*S;
long double PSDTPS=-ETA*ETDT*PSIM2;
long double SIN2G=2.*__SING*COSG;
long double C0DTC0=D20+4.*TSDTTS-ALDTAL-7.*PSDTPS;
long double C1DTC1=XNDTN+4.*ALDTAL+C0DTC0;
long double D9=ETA*(6.+68.*EOSQ)+EO*(20.+15.*ETA2);
long double D10=5.*ETA*(4.+ETA2)+EO*(17.+68.*ETA2);
long double D11=ETA*(72.+18.*ETA2);
long double D12=ETA*(30.+10.*ETA2);
long double D13=5.+11.25*ETA2;
long double D14=TSDTTS-2.*PSDTPS;
long double D15=2.*(D20+EO*EDOT/BETAO2);
long double D1DT=D1*(D14+D15);
long double D2DT=ETDT*D11;
long double D3DT=ETDT*D12;
long double D4DT=ETDT*D13;
long double D5DT=D5*D14;
long double C4DT=B2*(D1DT*D3+D1*D3DT);
long double C5DT=B3*(D5DT*D4+D5*D4DT);
long double D16= D9*ETDT+D10*EDOT + B1*(D1DT*D2+D1*D2DT) + C4DT*COS2G+C5DT*__SING+XGDT1*(C5*COSG-2.*C4*SIN2G);
long double XNDDT=C1DTC1*XNDT+C1*D16;
long double EDDOT=C0DTC0*EDOT-C0*( (4.+3.*ETA2+30.*EETA+EOSQ*(15.5+21.*ETA2))*ETDT+(5.+15.*ETA2 +EETA*(31.+14.*ETA2))*EDOT + B1*(D1DT*D6+D1*ETDT*(30.+67.5*ETA2)) + B2*(D1DT*D7+D1*ETDT*(5.+37.5*ETA2))*COS2G+ B3*(D5DT*D8+D5*ETDT*ETA*(13.5+4.*ETA2))*__SING+XGDT1*(C9* COSG-2.*C8*SIN2G));
long double D25=EDOT*EDOT;
long double D17=XNDDT/XNODP-XNDTN*XNDTN;
long double TSDDTS=2.*TSDTTS*(TSDTTS-D20)+AODP*TSI*(TOTHRD*BETAO2*D17-4.*D20* EO*EDOT+2.*(D25+EO*EDDOT));
long double ETDDT =(EDDOT+2.*EDOT*TSDTTS)*TSI*S+TSDDTS*ETA;
long double D18=TSDDTS-TSDTTS*TSDTTS;
long double D19=-PSDTPS*PSDTPS/ETA2-ETA*ETDDT*PSIM2-PSDTPS*PSDTPS;
long double D23=ETDT*ETDT;
long double D1DDT=D1DT*(D14+D15)+D1*(D18-2.*D19+TOTHRD*D17+2.*(ALPHA2*D25 /BETAO2+EO*EDDOT)/BETAO2);
long double XNTRDT=XNDT*(2.*TOTHRD*D17+3.* (D25+EO*EDDOT)/ALPHA2-6.*ALDTAL*ALDTAL + 4.*D18-7.*D19 ) + C1DTC1*XNDDT+C1*(C1DTC1*D16+ D9*ETDDT+D10*EDDOT+D23*(6.+30.*EETA+68.*EOSQ)+ ETDT*EDOT*(40.+30.* ETA2+272.*EETA)+D25*(17.+68.*ETA2) + B1*(D1DDT*D2+2.*D1DT*D2DT+D1*(ETDDT*D11+D23*(72.+54.*ETA2))) + B2*(D1DDT*D3+2.*D1DT*D3DT+D1*(ETDDT*D12+D23*(30.+30.*ETA2))) * COS2G+ B3*((D5DT*D14+D5*(D18-2.*D19)) * D4+2.*D4DT*D5DT+D5*(ETDDT*D13+22.5*ETA*D23)) *__SING+XGDT1* ((7.*D20+4.*EO*EDOT/BETAO2)* (C5*COSG-2.*C4*SIN2G) +((2.*C5DT*COSG-4.*C4DT*SIN2G)-XGDT1*(C5*SING+4.* C4*COS2G))));
long double TMNDDT=XNDDT*1.E9;
TEMP=TMNDDT*TMNDDT-XNDT*1.E18*XNTRDT;
long double PP=(TEMP+TMNDDT*TMNDDT)/TEMP;
long double GAMMA=-XNTRDT/(XNDDT*(PP-2.));
long double XND=XNDT/(PP*GAMMA);
long double QQ=1.-EDDOT/(EDOT*GAMMA);
long double ED=EDOT/(QQ*GAMMA);
long double OVGPP=1./(GAMMA*(PP+1.));
    goto M_70;
M_50:
    ISIMP=1;
EDOT=-TOTHRD*XNDTN*(1.-EO);
M_70:
//IFLAG=0;
//* UPDATE FOR SECULAR GRAVITY AND ATMOSPHERIC DRAG
M_100:
long double XMAM=FMOD2P(XMO+XLLDOT*TSINCE);
long double OMGASM=OMEGAO+OMGDT*TSINCE;
long double XNODES=XNODEO+XNODOT*TSINCE;
//IF(ISIMP .EQ. 1) GO TO 105
if(ISIMP == 1) goto M_105;
TEMP=1.-GAMMA*TSINCE;
//TEMP1=TEMP**PP
long double TEMP1=pow(TEMP,PP);
long double XN=XNODP+XND*(1.-TEMP1);
//EM=EO+ED*(1.-TEMP**QQ)
long double EM=EO+ED*(1.-pow(TEMP,QQ));
long double Z1=XND*(TSINCE+OVGPP*(TEMP*TEMP1-1.));
goto M_108;
M_105:
XN=XNODP+XNDT*TSINCE;
EM=EO+EDOT*TSINCE;
Z1=.5*XNDT*TSINCE*TSINCE;
M_108:
long double Z7=3.5*TOTHRD*Z1/XNODP;
XMAM=FMOD2P(XMAM+Z1+Z7*XMDT1);
OMGASM=OMGASM+Z7*XGDT1;
XNODES=XNODES+Z7*XHDT1;
//* SOLVE KEPLERS EQUATION
long double ZC2=XMAM+EM*sin(XMAM)*(1.+EM*cos(XMAM));
long double SINE;
long double COSE;
long double ZC5;
long double CAPE;

//DO 130 I=1,10
for (int i = 0; i< 10; i++)
{

    SINE=sin(ZC2);
    COSE=cos(ZC2);
    ZC5=1./(1.-EM*COSE);
    CAPE=(XMAM+EM*SINE-ZC2)* ZC5+ZC2;
    //IF(ABS(CAPE-ZC2) .LE. E6A) GO TO 140
    if (fabs(CAPE-ZC2) < E6A) break;//GO TO 140
M_130:
ZC2=CAPE;
}
//* SHORT PERIOD PRELIMINARY QUANTITIES
M_140:
long double AM=pow((XKE/XN),TOTHRD);
long double BETA2M=1.-EM*EM;
long double SINOS=sin(OMGASM);
long double COSOS=cos(OMGASM);
long double AXNM=EM*COSOS;
long double AYNM=EM*SINOS;
long double PM=AM*BETA2M;
long double G1=1./PM;
long double G2=.5*CK2*G1;
long double G3=G2*G1;
long double BETA=sqrt(BETA2M);
long double G4=.25*A3COF*SINI;
long double G5=.25*A3COF*G1;
long double SNF=BETA*SINE*ZC5;
long double CSF=(COSE-EM)*ZC5;
//FM=ACTAN(SNF,CSF)
long double FM=ACTAN(SNF,CSF);
long double SNFG=SNF*COSOS+CSF*SINOS;
long double CSFG=CSF*COSOS-SNF*SINOS;
long double SN2F2G=2.*SNFG*CSFG;
long double CS2F2G=2.*CSFG*CSFG-1.0;
long double ECOSF=EM*CSF;
long double G10=FM-XMAM+EM*SNF;
long double RM=PM/(1.+ECOSF);
long double AOVR=AM/RM;
long double G13=XN*AOVR;
long double G14=-G13*AOVR;
long double DR=G2*(UNMTH2*CS2F2G-3.*TTHMUN)-G4*SNFG;
long double DIWC=3.*G3*SINI*CS2F2G-G5*AYNM;
long double DI=DIWC*COSI;
//* UPDATE FOR SHORT PERIOD PERIODICS
long double SNI2DU=SINIO2*( G3*(.5*(1.-7.*THETA2)*SN2F2G-3.*UNM5TH*G10)-G5*SINI*CSFG*(2.+ ECOSF))-.5*G5*THETA2*AXNM/COSIO2;
long double XLAMB=FM+OMGASM+XNODES+G3*(.5*(1.+6.*COSI-7.*THETA2)*SN2F2G-3.* (UNM5TH+2.*COSI)*G10)+G5*SINI*(COSI*AXNM/(1.+COSI)-(2. +ECOSF)*CSFG);

long double Y4=SINIO2*SNFG+CSFG*SNI2DU+.5*SNFG*COSIO2*DI;
long double Y5=SINIO2*CSFG-SNFG*SNI2DU+.5*CSFG*COSIO2*DI;
long double R=RM+DR;
long double RDOT=XN*AM*EM*SNF/BETA+G14*(2.*G2*UNMTH2*SN2F2G+G4*CSFG);
long double RVDOT=XN*AM*AM*BETA/RM+ G14*DR+AM*G13*SINI*DIWC;
//* ORIENTATION VECTORS
long double SNLAMB=sin(XLAMB);
long double CSLAMB=cos(XLAMB);
TEMP=2.*(Y5*SNLAMB-Y4*CSLAMB);
long double UX=Y4*TEMP+CSLAMB;
long double VX=Y5*TEMP-SNLAMB;
TEMP=2.*(Y5*CSLAMB+Y4*SNLAMB);
long double UY=-Y4*TEMP+SNLAMB;
long double VY=-Y5*TEMP+CSLAMB;
TEMP=2.*sqrt(1.-Y4*Y4-Y5*Y5);
long double UZ=Y4*TEMP;
long double VZ=Y5*TEMP;
//* POSITION AND VELOCITY
X=R*UX;
Y=R*UY;
Z=R*UZ;
XDOT=RDOT*UX+RVDOT*VX;
YDOT=RDOT*UY+RVDOT*VY;
ZDOT=RDOT*UZ+RVDOT*VZ;
//RETURN
//END
}


void MoonXYZCalc(double &flX, double &flY, double &flZ, double tsec)
{
    flX = (383.0*sin( 8399.685*tsec + 5.381)+
            31.5*sin(   70.990*tsec + 6.169)+
            10.6*sin(16728.377*tsec + 1.453)+
             6.2*sin( 1185.622*tsec + 0.481)+
             3.2*sin( 7143.070*tsec + 5.017)+
             2.3*sin(15613.745*tsec + 0.857)+
             0.8*sin( 8467.263*tsec + 1.010))*1.0E6;
    
    flY = (351.0*sin( 8399.687*tsec + 3.811)+
            28.9*sin(   70.997*tsec + 4.596)+
            13.7*sin( 8433.466*tsec + 4.766)+
             9.7*sin(16728.380*tsec + 6.165)+
             5.7*sin( 1185.667*tsec + 5.164)+
             2.9*sin( 7143.058*tsec + 0.300)+
             2.1*sin(15613.755*tsec + 5.565))*1.0E6;

    flZ = (153.2*sin( 8399.672*tsec + 3.807)+
            31.5*sin( 8433.464*tsec + 1.629)+
            12.5*sin(   70.996*tsec + 4.595)+
             4.2*sin(16728.364*tsec + 6.162)+
             2.5*sin( 1185.645*tsec + 5.167)+
             3.0*sin(  104.881*tsec + 2.555)+
             1.8*sin( 8399.116*tsec + 6.248))*1.0E6;
}

void makeExplanationText(char*szText, int iCalc, int iTraj, int iBody)
{
    switch(iCalc)
    {
    case CALC_PERIGEE: strcpy(szText,"\n<!-- calculates perigee to the ");break;
    case CALC_APOGEE: strcpy(szText,"\n <!-- calculates apogee to the ");break;
    case CALC_TARGET_PRACTICE: strcpy(szText,"\n<!-- calculates error in target practice to the moon");iBody=-1;break;
    case CALC_TARGET_POINT: strcpy(szText,"\n<!-- calculates error in traget prective to the point on the moon");iBody=-1;break;
    case CALC_PERIOD: strcpy(szText,"\n<!-- calculates orbit`s period after engine firing");iTraj=-1;iBody=-1;break;
    case CALC_INIT_PERIOD: strcpy(szText,"\n<!-- calculates orbit`s period ");iTraj=-1;iBody=-1;break;
    case CALC_FIRE_FIRST_ENGINE_TIME: strcpy(szText,"\n<!-- calculates first engine firing time");iTraj=-1;iBody=-1;break;
    case CALC_FIRE_SECOND_ENGINE_TIME:strcpy(szText,"\n<!-- calculates second engine firing time");iTraj=-1;iBody=-1;break;
    case CALC_FIRE_THIRD_ENGINE_TIME_TRY_ONE:strcpy(szText,"\n<!-- calculates third engine firing time(first try)");iTraj=-1;iBody=-1;break;
    case CALC_AT_APOGEE_DIFF_TO_3_4_DIST:strcpy(szText,"\n<!-- calculates difference from 3/4 earth-moon distance and apogee");iBody=-1;break;
    }
    switch(iBody)
    {
    case EARTH:strcat(szText,"Earth");break;
    case MOON:strcat(szText,"Moon");break;
    default:break;
    }
    switch(iTraj)
    {
    case MINIMUM_BY_TIME:strcat(szText,", search for minimum by adjusting time -->");break;
    case MAXIMUM_BY_TIME:strcat(szText,", search for maximum by adjusting time -->");break;
    case MINIMUM_BY_ANGLE:strcat(szText,", search for minimum by adjusting angle -->");break;
    case MINIMUM_BY_WEIGHT:strcat(szText,", search for minimum by adjusting engines weight -->");break;
    default:strcat(szText,".-->");break;

    }

}

void PostXMLToServer(char* URLServer, int urlport, char* URLFileName, char* FileToTransfer)
{
    char szWebServerResp[8096];
    FILE *FileTransfer = fopen(FileToTransfer,"rb");
    if (FileTransfer)
    {
        fseek(FileTransfer, 0L, SEEK_END);
        long iSize = ftell( FileTransfer);
        fseek(FileTransfer, 0L, SEEK_SET);
        char * szFileContent = (char*)malloc((size_t)iSize);
        if (szFileContent)
        {
            fread(szFileContent,iSize,1,FileTransfer);
            fclose(FileTransfer);
            CHttpConnection* m_MainHttpServer = NULL;
            CInternetSession  *m_MainInternetConnection = NULL;

            if (m_MainHttpServer == NULL)
            {
                m_MainInternetConnection = new CInternetSession("SessionToControlServer",12,INTERNET_OPEN_TYPE_DIRECT,NULL, // proxi name
                            NULL, // proxi bypass
				            INTERNET_FLAG_DONT_CACHE|INTERNET_FLAG_TRANSFER_BINARY);
		        try
		        {
		            m_MainHttpServer = 	m_MainInternetConnection->GetHttpConnection( URLServer, 0, urlport, NULL, NULL );
                }
	            catch(CInternetException *e)
		        {
		            m_MainHttpServer = NULL;
		        }
            }
            if (m_MainHttpServer)
            {
                CHttpFile* myCHttpFile = NULL;
                try
                {
                    myCHttpFile = m_MainHttpServer->OpenRequest( CHttpConnection::HTTP_VERB_POST,URLFileName, NULL,NULL, NULL, NULL, INTERNET_FLAG_EXISTING_CONNECT|	INTERNET_FLAG_DONT_CACHE|INTERNET_FLAG_RELOAD );
			    }
			    catch(CInternetException *e)
			    {
				    myCHttpFile = NULL;
			    }

			    if (myCHttpFile !=NULL)
			    {
				    try
				    {
                        CString strHeader = "Accept: text/*\r\n";
                        strHeader += "User-Agent: HttpCall\r\n";
                        strHeader += "Accept-Language: en-us\r\n";

                        //    strHeader += "Content-type: application/x-www-form-urlencoded\r\n";
                        //    strHeader += "REMOTE_USER: "+strUser+"\r\n";
                        //    strHeader += "Accept-Language: en-us\r\n";

                        myCHttpFile->AddRequestHeaders((LPCSTR)strHeader);
                        myCHttpFile->SendRequestEx(iSize,HSR_INITIATE,1);
                        myCHttpFile->WriteString((LPCTSTR)szFileContent);
                        myCHttpFile->EndRequest();

					    memset(szWebServerResp, 0, sizeof(szWebServerResp));
						DWORD dwSize;
						CString strSize;
						myCHttpFile->QueryInfo(HTTP_QUERY_CONTENT_LENGTH,strSize);
						dwSize = atoi(strSize.GetString());
    				    if (dwSize > (sizeof(szWebServerResp)-1))
					    {
						    for (DWORD dwread=0; dwread < dwSize; dwread+= (sizeof(szWebServerResp)-1))
						    {
							    if ((dwSize - dwread) > (sizeof(szWebServerResp)-1))
                                {
	                                if (myCHttpFile->Read(&szWebServerResp,(sizeof(szWebServerResp)-1)))
                                    {
                                    }
                                }
								else
                                {
								    if (myCHttpFile->Read(&szWebServerResp,(dwSize - dwread)))
                                    {
                                    }
                                }
                            }
                        }
						else
                        {
                            if (myCHttpFile->Read(&szWebServerResp,dwSize))
                            {
                            }
                        }
                    }
    				catch(CInternetException *e)
	    			{
		    			//ptrApp->m_MainHttpServer = NULL;
			    	}
    				myCHttpFile->Close();
	    			delete myCHttpFile;
		    	}
                m_MainHttpServer->Close();
                m_MainInternetConnection->Close();
		    }
            free(szFileContent);
        }
    }
}
FILE *fInputReadUrlOrFile; 
int GetFileString(char *_szXMLFileName, char *_szLocalFileName, int FileStatusFlag, char *szString, int sizeof_szString)
{
    if (FileStatusFlag == 0) // that is OPEN operation
    {
        if (strstr(_szXMLFileName,"http://"))
        {
            // needs to copy original http file from server to a local with temporary name, than process temporary
            char szURLFileName[3*_MAX_PATH];
            char szURLServer[3*_MAX_PATH];
            char sztempFileName[3*_MAX_PATH];
            char szWebServerResp[8096];
            int UrlPort=80;
       	    CHttpConnection* m_MainHttpServer = NULL;
    	    CInternetSession  *m_MainInternetConnection = NULL;

            if (ParsURL(szURLServer, &UrlPort, szURLFileName, _szXMLFileName))
            {
                //strcpy(_szXMLFileName, _szLocalFileName);
            }
            else
            {
                printf("\n file %s was wrongly parsed",_szXMLFileName);
                return 3;
            }
            if (m_MainHttpServer == NULL)
	        {
                m_MainInternetConnection = new CInternetSession("SessionToControlServer",12,INTERNET_OPEN_TYPE_DIRECT,NULL, // proxi name
				            NULL, // proxi bypass
				            INTERNET_FLAG_DONT_CACHE|INTERNET_FLAG_TRANSFER_BINARY);
		        try
		        {
                    m_MainHttpServer = 	m_MainInternetConnection->GetHttpConnection( szURLServer, 0, UrlPort, NULL, NULL );
    		    }
	    	    catch(CInternetException *e)
		        {
                    m_MainHttpServer = NULL;
                    printf("\n file %s failure to open (no intenet connection)", _szXMLFileName);
                    return 1;
		        }
	        }
	        if (m_MainHttpServer)
	        {
                CHttpFile* myCHttpFile = NULL;
			    try
			    {
                    myCHttpFile = m_MainHttpServer->OpenRequest( CHttpConnection::HTTP_VERB_GET,
					    szURLFileName,
					    NULL,//((CGrStnApp*)AfxGetApp())->szLoginRQ,
					    NULL,//12345678,
					    NULL, 
					    NULL, 
					    INTERNET_FLAG_EXISTING_CONNECT|
					    INTERNET_FLAG_DONT_CACHE|
					    INTERNET_FLAG_RELOAD );
			    }
			    catch(CInternetException *e)
			    {
                    m_MainHttpServer->Close();
                    printf("\n file %s failure to open", _szXMLFileName);
                    return 1;
			    }

			    if (myCHttpFile !=NULL)
			    {
                    try
				    {
					    myCHttpFile->SendRequest();
					    memset(szWebServerResp, 0, sizeof(szWebServerResp));
                        DWORD dwSize;
                        CString strSize;
                        myCHttpFile->QueryInfo(HTTP_QUERY_CONTENT_LENGTH,strSize);
                        dwSize = atoi(strSize.GetString());
                        FILE *TempFile = fopen(_szLocalFileName, "wb");
                        if (TempFile)
                        {
                            if (dwSize > (sizeof(szWebServerResp)-1))
                            {
                                for (DWORD dwread=0; dwread < dwSize; dwread+= (sizeof(szWebServerResp)-1))
                                {
                                    if ((dwSize - dwread) > (sizeof(szWebServerResp)-1))
                                    {
                                        if (myCHttpFile->Read(&szWebServerResp,(sizeof(szWebServerResp)-1)))
                                        {
                                            fwrite(&szWebServerResp,(sizeof(szWebServerResp)-1),1,TempFile);
                                        }

                                    }
                                    else
                                    {
                                        if (myCHttpFile->Read(&szWebServerResp,(dwSize - dwread)))
                                        {
                                            fwrite(&szWebServerResp,(dwSize - dwread),1,TempFile);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (myCHttpFile->Read(&szWebServerResp,dwSize))
                                {
                                    fwrite(&szWebServerResp,dwSize,1,TempFile);
                                }
                            }
                            fclose(TempFile);
                        }
                        else
                        {
                            printf("\n file %s failure to write into %s", _szXMLFileName,_szLocalFileName);
                        }
                    }
                    catch(CInternetException *e)
                    {
                        myCHttpFile->Close();
                        m_MainHttpServer->Close();
                        m_MainInternetConnection->Close();
					    //ptrApp->m_MainHttpServer = NULL;
                        printf("\n file %s failure to read", _szXMLFileName);
                        return 3;
				    }
                    myCHttpFile->Close();
				    delete myCHttpFile;
                }
                else
                {
                    m_MainHttpServer->Close();
                    m_MainInternetConnection->Close();
                    //ptrApp->m_MainHttpServer = NULL;
                    printf("\n file %s failure to read", _szXMLFileName);
                    return 3;
                }
                m_MainHttpServer->Close();
                m_MainInternetConnection->Close();
            }
            else
            {
                m_MainInternetConnection->Close();
                //ptrApp->m_MainHttpServer = NULL;
                printf("\n file %s failure to open", _szXMLFileName);
                return 3;
            }
            fInputReadUrlOrFile = fopen(_szLocalFileName, "r");
            if (fInputReadUrlOrFile != NULL)
            {
                //fclose(fInputReadUrlOrFile);
                return 0;
            }
            else
            {
                printf("\n file %s missing", _szLocalFileName);
                return 3;
            }
        }
        else
        {
            fInputReadUrlOrFile = fopen(_szXMLFileName, "r");
            if (fInputReadUrlOrFile != NULL)
            {
                return 0;
            }
            else
            {
                printf("\n file %s missing", _szLocalFileName);
                return 3;
            }
        }
    }
    if (FileStatusFlag == 1) // that is READ/CLOSE operation
    {
        if (fInputReadUrlOrFile != NULL)
        {
            if (fgets(szString, sizeof_szString-1, fInputReadUrlOrFile) != NULL)
            {
                return 0;
            }
            else  // end of the file reached
            {
                fclose(fInputReadUrlOrFile);
                return 1;
            }

        }
        else
        {
            return 2;
        }
    }
}


FILE *VisualFile = NULL;

void dumpTRAvisual(long i)
{
    if (VisualFileSet == FALSE)
        return;
    if (VisualFile == NULL)
    {
		VisualFile = fopen(szTraVisualFileName, "w");
        if (VisualFile)
        {
		    fprintf(VisualFile,"<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n");
		    fprintf(VisualFile,"<Universe>\n");
        }
    }
	if (VisualFile)
    {

        for (int iSat = 0; iSat < Sat.Elem; iSat++)
        {
            fprintf(VisualFile,"	<Sat%d>\n",iSat);
            //fprintf(VisualFile,"		<ID>SatTra</ID>\n");
		    //fprintf(VisualFile,"		<time>%.18g</time>\n", dStartJD + ((double)i)/(24.0*60.0*60.0));
			fprintf(VisualFile,"		<X>%.18g</X>\n",Sat.X[iSat]-SolarSystem.X[EARTH]);
			fprintf(VisualFile,"		<Y>%.18g</Y>\n",Sat.Y[iSat]-SolarSystem.Y[EARTH]);
			fprintf(VisualFile,"		<Z>%.18g</Z>\n",Sat.Z[iSat]-SolarSystem.Z[EARTH]);
            if (iSat == 0) // only for a first satellite - check visibility from ground stations
            {
                // check is it from now time till end of the simulation
                if ((iTotalSec - i) <= dMinFromNow* 60)
                {
                    SYSTEMTIME ThatTime; 
                    TIME_ZONE_INFORMATION tmzone;
                    ConvertJulianDayToDateAndTime(dStartJD + ((double)(i))/(24.0*60.0*60.0), &ThatTime);
                    int Iret = GetTimeZoneInformation(&tmzone); 
                    double dTLEEpoch = ConvertDateTimeToTLEEpoch(ThatTime.wDay, ThatTime.wMonth, ThatTime.wYear, ThatTime.wHour, ThatTime.wMinute, ThatTime.wSecond, ThatTime.wMilliseconds);
                    double dGreenwichA = GreenwichAscensionFromTLEEpoch(dTLEEpoch,Sat.precEps,Sat.precTet,Sat.precZ,Sat.nutEpsilon,Sat.nutDFeta);
                    SUN_08 (ThatTime.wYear,
                                iDayOfTheYearZeroBase(ThatTime.wDay, ThatTime.wMonth, ThatTime.wYear)+1 ,// in that function specified that 1 day is january 1
                                ThatTime.wHour,ThatTime.wMinute,ThatTime.wSecond,
                                GST,SLONG,SRASN,SDEC);
                    // only for red line do the check
                    for (int jGr = 0; jGr < iGr; jGr++)
                    {
                        double PosX;double PosY;double PosZ;
                        GetXYZfromLatLong(GrLong[jGr]+GST*180.0/M_PI-90.0, GrLat[jGr],PosX,PosY,PosZ, EarthR);
                        // check: does Cubesat in proximity of a ground station : angle btw vactor-radius and vector cubesat-ground station > 90 degree
                        if (AngleBtw(-PosX,-PosY,-PosZ,
                            (Sat.X[iSat]-SolarSystem.X[EARTH])-PosX,(Sat.Y[iSat]-SolarSystem.Y[EARTH])-PosY,(Sat.Z[iSat]-SolarSystem.Z[EARTH])-PosZ) > 90.0)
                        {
                            fprintf(VisualFile,"		        <X%d>%.18g</X%d>\n",jGr,PosX,jGr);
                            fprintf(VisualFile,"		        <Y%d>%.18g</Y%d>\n",jGr,PosY,jGr);
                            fprintf(VisualFile,"		        <Z%d>%.18g</Z%d>\n",jGr,PosZ,jGr);
                        }
                    }
                }
            }
            fprintf(VisualFile,"	</Sat%d>\n",iSat);
        }
	    if (OutLast == TRUE)
	    {
            SYSTEMTIME ThatTime; 
            ConvertJulianDayToDateAndTime(dStartJD + ((double)i)/(24.0*60.0*60.0), &ThatTime);
            double dEpoch = ConvertDateTimeToTLEEpoch(ThatTime.wDay, ThatTime.wMonth, ThatTime.wYear, ThatTime.wHour, ThatTime.wMinute, ThatTime.wSecond, ThatTime.wMilliseconds);
            double long dGreenwichA = GreenwichAscensionFromTLEEpoch(dEpoch,Sat.precEps,Sat.precTet,Sat.precZ,Sat.nutEpsilon,Sat.nutDFeta);
            SUN_08 (ThatTime.wYear,
                iDayOfTheYearZeroBase(ThatTime.wDay, ThatTime.wMonth, ThatTime.wYear) + 1 , // in fucntion spec that 1 Jan == 1 
                ThatTime.wHour,ThatTime.wMinute,ThatTime.wSecond,
                GST,SLONG,SRASN,SDEC);
            // GST is a position Greenwich in rad 

            //for moon rotation - moon looks at earth each time
            // that is a angle btw vector (0,-1,0) and moon position vector in geocentrical coordinates
            double MoonRot = AngleBtw(0,-1,0,SolarSystem.X[MOON] - SolarSystem.X[EARTH],SolarSystem.Y[MOON] - SolarSystem.Y[EARTH],SolarSystem.Z[MOON] - SolarSystem.Z[EARTH]);

            fprintf(VisualFile,"	<Object>\n");
            fprintf(VisualFile,"		<type>Earth</type>\n");
			fprintf(VisualFile,"		<X>%.18g</X>\n",SolarSystem.X[EARTH]);
			fprintf(VisualFile,"		<Y>%.18g</Y>\n",SolarSystem.Y[EARTH]);
			fprintf(VisualFile,"		<Z>%.18g</Z>\n",SolarSystem.Z[EARTH]);
			fprintf(VisualFile,"		<R>%.18g</R>\n",EarthR);
            fprintf(VisualFile,"		<Rot>%.18g</Rot>\n",GST*180.0/M_PI - 90.0); // convert to degree
			fprintf(VisualFile,"	</Object>\n");
			fprintf(VisualFile,"	<Object>\n");
			fprintf(VisualFile,"		<type>Sun</type>\n");
			fprintf(VisualFile,"		<X>%.18g</X>\n",SolarSystem.X[SUN]);
			fprintf(VisualFile,"		<Y>%.18g</Y>\n",SolarSystem.Y[SUN]);
			fprintf(VisualFile,"		<Z>%.18g</Z>\n",SolarSystem.Z[SUN]);
			fprintf(VisualFile,"		<R>%.18g</R>\n",SunR);
            fprintf(VisualFile,"		<Rot>%.18g</Rot>\n",0);
			fprintf(VisualFile,"	</Object>\n");
			fprintf(VisualFile,"	<Object>\n");
			fprintf(VisualFile,"		<type>Moon</type>\n");
			fprintf(VisualFile,"		<X>%.18g</X>\n",SolarSystem.X[MOON]);
			fprintf(VisualFile,"		<Y>%.18g</Y>\n",SolarSystem.Y[MOON]);
			fprintf(VisualFile,"		<Z>%.18g</Z>\n",SolarSystem.Z[MOON]);
			fprintf(VisualFile,"		<R>%.18g</R>\n",MoonR);
            fprintf(VisualFile,"		<Rot>%.18g</Rot>\n",MoonRot);
			fprintf(VisualFile,"	</Object>\n");
            fprintf(VisualFile,"	<ObjectTime>\n");
		    fprintf(VisualFile,"		<timeJD>%.18g</timeJD>\n", dStartJD + ((double)i)/(24.0*60.0*60.0));
            
            fprintf(VisualFile,"		<timeYYDDMMHHMMSS>%02d/%02d/%02d %02d:%02d:%02d</timeYYDDMMHHMMSS>\n", ThatTime.wYear-2000,ThatTime.wMonth,ThatTime.wDay,ThatTime.wHour,ThatTime.wMinute,ThatTime.wSecond);
            fprintf(VisualFile,"		<ReloadInSec>00001</ReloadInSec>\n"); // for the best case it is 1 sec refresh == that value has to be  
            fprintf(VisualFile,"		<dMinFromNow>%d</dMinFromNow>\n",(int)dMinFromNow); // how many minutes from now to aproximate
            fprintf(VisualFile,"	</ObjectTime>\n");
            for (int i= 0; i <iGr; i++)
            {
                fprintf(VisualFile,"	<GrSt>\n");
                // now need to calculate coordinates based on latitude and longitude
                double PosX;double PosY;double PosZ;
                GetXYZfromLatLong(GrLong[i], GrLat[i],PosX,PosY,PosZ, EarthR);
                //fprintf(VisualFile,"		<type>GrStn</type>\n");
                fprintf(VisualFile,"		<X>%.18g</X>\n",PosX);
                fprintf(VisualFile,"		<Y>%.18g</Y>\n",PosY);
                fprintf(VisualFile,"		<Z>%.18g</Z>\n",PosZ);
                fprintf(VisualFile,"	</GrSt>\n");
            }
            fprintf(VisualFile,"</Universe>\n");
			fclose(VisualFile);
            VisualFile = NULL;
            if (szTraVisualFileName[0] == '@') // yes! it is agly - that is a case when visualization output must to be submit to some server
            {
                PostXMLToServer(szURLTraVisualServer, UrlTraVisualPort, szURLTraVisualFileName, szTraVisualFileName);
            }
		}
	}
}
// output the same copy of the TRA.XML file
void dumpXMLParam(TRAOBJ *Sat, TRAIMPLOBJ *MyEngine, int iNumbOfEng)
{
    char szText[1024];
    FILE *EnginesFile = fopen("tra_out.xml", "w");
    int i,j;
    if (EnginesFile)
    {
#define XML_DUMPF(XML_PARAM) fprintf(EnginesFile,"\n    <TRA:setting name=\"%s\" value=\"%.18g\" />",#XML_PARAM,XML_PARAM);
#define XML_DUMPI(XML_PARAM) fprintf(EnginesFile,"\n    <TRA:setting name=\"%s\" value=\"%d\" />",#XML_PARAM,XML_PARAM);
        fprintf(EnginesFile,"<?xml version=\"1.0\" encoding=\"UTF-8\" ?>");
        fprintf(EnginesFile,"\n<TRA:data version=\"1.00\" xmlns:CT=\"http://www.adobri.com/tra\">");
        fprintf(EnginesFile,"\n<TRA:section name=\"TraInfo\">\n");
        fprintf(EnginesFile,"\n<!-- starting date (1 jan 2000) = 2451544.5JD ");
        fprintf(EnginesFile,"\n     if this is not set then use keplers elements from a satelite 0 -->");
        XML_DUMPF(dStartJD);
#ifdef _DO_VISUALIZATION
        fprintf(EnginesFile,"\n\n    <TRA:setting name=\"RGBImageW\" value=\"%d\" />",bRGBImageW);
        fprintf(EnginesFile,"\n    <TRA:setting name=\"RGBImageH\" value=\"%d\" />",bRGBImageH);
#endif
        fprintf(EnginesFile,"\n<!-- int iProfile = 0; ");
        fprintf(EnginesFile,"\n              // 0 == XY , 1 == YZ, 2 == XZ 3 == -YZ 4 == -XZ 5==-XY");
        fprintf(EnginesFile,"\n              // 0 or XY is a view from North to south, 5 (- XY) is a view from south to north");
        fprintf(EnginesFile,"\n              // 1 or YZ is a view to easter -->");
#ifdef _DO_VISUALIZATION
        fprintf(EnginesFile,"\n    <TRA:setting name=\"RGBView\" value=\"%d\" />", iProfile);
#endif

        fprintf(EnginesFile,"\n<!--  EARTH 2 MOON  9 -->\n");
#ifdef _DO_VISUALIZATION
        XML_DUMPI(RGBReferenceBody);
#endif
        fprintf(EnginesFile,"\n<!-- max amount of pictures -->");
#ifdef _DO_VISUALIZATION
        fprintf(EnginesFile,"\n    <TRA:setting name=\"RGBMaxPictures\" value=\"%d\" />",iMaxSeq);
        fprintf(EnginesFile,"\n<!-- one picture per sec -->");
        fprintf(EnginesFile,"\n    <TRA:setting name=\"RGBSecPerPictures\" value=\"%d\" />", iMaxCounter);
        fprintf(EnginesFile,"\n<!-- scale in m -->");
        fprintf(EnginesFile,"\n    <TRA:setting name=\"RGBScale\" value=\"%.18g\" />\n",dRGBScale);
#endif
        XML_DUMPF(IterPerSec);
        XML_DUMPF(StartLandingIteraPerSec);

        fprintf(EnginesFile,"\n<!-- next vaue actualy just a reference it will be used in-->");
        fprintf(EnginesFile,"\n<!-- GMMoon = MoonM * GBig and GMEarth = EarthM*GBig      -->");
        fprintf(EnginesFile,"\n<!-- know GMMoon and GMEarth will give proper value for M -->");
        XML_DUMPF(Gbig);
        XML_DUMPF(TotalDays);
        XML_DUMPF(EarthCurTime);
        XML_DUMPF(AU); 
        for (i = 0; i < Sat->Elem; i++)
        {
            //XML_DUMPF(ProbM);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"ProbM\" value=\"%.18g\" />",Sat->M[i]);

            fprintf(EnginesFile,"\n    <TRA:setting name=\"ProbKeplerLine1\" value=\"%s",Sat->Kepler1);
            fprintf(EnginesFile,"    <TRA:setting name=\"ProbKeplerLine2\" value=\"%s",Sat->Kepler2);
            fprintf(EnginesFile,"    <TRA:setting name=\"ProbKeplerLine3\" value=\"%s",Sat->Kepler3);
        }
        fprintf(EnginesFile,"\n<!-- target point on the Moon -->");
        XML_DUMPF(Targetlongitude);
        XML_DUMPF(Targetlatitude);
        //XML_DUMPF(SunM);
        XML_DUMPF(EarthR);
        //XML_DUMPF(EarthRP);
        //XML_DUMPF(EarthRE);
        //XML_DUMPF(EarthM);
        //XML_DUMPF(MassRatioSunToEarthPlusMoon);
        XML_DUMPF(EarthTSolSec);
        XML_DUMPF(EarthSmAx);
        //XML_DUMPF(EarthSmAxAU);
        //XML_DUMPF(EarthTDays);

        XML_DUMPF(MoonR);
        //XML_DUMPF(MoonRP);
        //XML_DUMPF(MoonRE);
        //XML_DUMPF(MoonM);
        fprintf(EnginesFile,"\n\n<!--next line will force recalculation of SunM based on G constant -->");
        //XML_DUMPF(GMSun);
        //XML_DUMPF(GMEarthMoon);
        //XML_DUMPF(GMEarth);
        //XML_DUMPF(GMMoon);
        fprintf(EnginesFile,"\n\n<!-- next line will force calculation of a Earth and Moon mass -->");
        fprintf(EnginesFile,"\n<!-- it is not in use - value just for reference and fo trigger -->");
        //XML_DUMPF(MassRatioEarthToMoon);
        fprintf(EnginesFile,"\n    <TRA:setting name=\"MoonKeplerLine1\" value=\"%s",szMoonKeplerLine1);
        fprintf(EnginesFile,"    <TRA:setting name=\"MoonKeplerLine2\" value=\"%s",szMoonKeplerLine2);
        fprintf(EnginesFile,"    <TRA:setting name=\"MoonKeplerLine3\" value=\"%s",szMoonKeplerLine3);
        fprintf(EnginesFile,"\n\n<!-- next line (value == \"1.0\") will force calculation"); 
        fprintf(EnginesFile,"\n                         of a Earth kepler position -->");
        fprintf(EnginesFile,"\n    <TRA:setting name=\"EarthCalcKepler\" value=\"0.0\" />");
        fprintf(EnginesFile,"\n\n<!-- next line will force assigning velocities and positions ");
        fprintf(EnginesFile,"\n     based on JPL data -->\n");
        fprintf(EnginesFile,"\n    <TRA:setting name=\"UseJPLxyz\" value=\"1.0\" />");
        XML_DUMPI(StartOptim);
        XML_DUMPI(MaxOptim);

        //fprintf(EnginesFile,"\n    <TRA:setting name=\"UseJPLxyz\" value=\"1.0\" />");
        fprintf(EnginesFile,"\n\n<!-- last used engine (0,1,2,3..) in trajectory optimization or calculations ");
        fprintf(EnginesFile,"\n     setting lastengine == -1 disable optimization -->\n");
        XML_DUMPI(LastEngine);
        fprintf(EnginesFile,"\n\n<!-- do optimization of an engine N... (0,1,2,3...)");
        fprintf(EnginesFile,"\n     it is posible to use 4 engines but optimize engine 3-->\n");
        XML_DUMPI(EngineToOptimize);


        fprintf(EnginesFile,"\n\n<!-- Type of optimization");
        fprintf(EnginesFile,"\n      1 - search for a minimum by adjusting time of firing");
        fprintf(EnginesFile,"\n      2 - search for a maximum by adjusting time of firing");       
        fprintf(EnginesFile,"\n      4 - search fo maximum by adjusting angle of firing");
        fprintf(EnginesFile,"\n      6 - search fo minimum by adjusting weight of fuel");

        fprintf(EnginesFile,"\n  initial step and decrease steps for each search specified");
        fprintf(EnginesFile,"\n  individualy for each engine -->\n");

        XML_DUMPI(TrajectoryOptimizationType);

        fprintf(EnginesFile,"\n</TRA:section>\n\n            <!--     now all engines    -->");

        for (i = 0; i < iNumbOfEng; i++)
        {
            fprintf(EnginesFile,"\n<TRA:section name=\"Engine\" value=\"%d\" />", i);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"EngineNumber\" value=\"%d\" />", i);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"EngineOnSatellite\" value=\"%d\" />",MyEngine[i].iEngineOnSatellite);
            fprintf(EnginesFile,"\n    <!-- convinent coeff - instead of entry real values just assume scaled version-->");
            fprintf(EnginesFile,"\n    <TRA:setting name=\"PropCoeff\" value=\"1.0\" />");
            fprintf(EnginesFile,"\n\n    <TRA:setting name=\"Weight\" value=\"%.18g\" />",MyEngine[i].Weight);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"TotalWeight\" value=\"%.18g\" />",MyEngine[i].TotalWeight);
            fprintf(EnginesFile,"\n\n    <!-- iteration per sec from engine's plot -->");
            fprintf(EnginesFile,"\n    <TRA:setting name=\"DeltaT\" value=\"%.18g\" />",1.0/MyEngine[i].DeltaTime);

            fprintf(EnginesFile,"\n\n     <!-- 2- EARTH 9-MOON for calculation distanses-->");
            fprintf(EnginesFile,"\n           <TRA:setting name=\"NearBody\" value=\"%d\" />",MyEngine[i].NearBody);

            fprintf(EnginesFile,"\n\n     <!-- AngleType 0 - tangent line to orbit (elipse) oposit velocity");
            fprintf(EnginesFile,"\n                    1 - two angles set with reference to NearBody centre direction");
            fprintf(EnginesFile,"\n                    2 - 3 angles set vector fire (constant all fire) ");
            fprintf(EnginesFile,"\n                    3 - oposit vector of velocity");
            fprintf(EnginesFile,"\n                    4 - same direction as vector of velocity -->");
            fprintf(EnginesFile,"\n     <TRA:setting name=\"AngleType\" value=\"%d\" />",MyEngine[i].AngleType);
            fprintf(EnginesFile,"\n\n     <!-- 2- EARTH 9-MOON for firing angle -->");
            fprintf(EnginesFile,"\n     <TRA:setting name=\"AngleOnBody\" value=\"%d\" />",MyEngine[i].AngleOnBody);
            fprintf(EnginesFile,"\n\n    <!-- first angle: in a plane over vector from the center of NearBody and Sat"); 
            fprintf(EnginesFile,"\n         and vector of velocity. Angle: Centre,Sat,Direction ");
            fprintf(EnginesFile,"\n         (aggle == 90 degr is a Tangent line to elipse) -->");
            fprintf(EnginesFile,"\n         <TRA:setting name=\"FireAng1\" value=\"%.18g\" />",MyEngine[i].Ang1);
            fprintf(EnginesFile,"\n\n     <!-- second angle from projection of a velocity vector to a  ");
            fprintf(EnginesFile,"\n         plane perpendicular to direction to centre of nearbody -->");
            fprintf(EnginesFile,"\n    <TRA:setting name=\"FireAng2\" value=\"%.18g\" />",MyEngine[i].Ang2);
            fprintf(EnginesFile,"\n\n    <TRA:setting name=\"XVector\" value=\"%.18g\" />",MyEngine[i].XVec);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"YVector\" value=\"%.18g\" />",MyEngine[i].YVec);
            fprintf(EnginesFile,"\n    <TRA:setting name=\"ZVector\" value=\"%.18g\" />\n",MyEngine[i].ZVec);
            fprintf(EnginesFile,"\n\n     <TRA:setting name=\"OptimizationInitialStep\" value=\"%.18g\" />",MyEngine[i].OptimizationInitialStepCopy);
            fprintf(EnginesFile,"\n     <TRA:setting name=\"OptimizationDecCoef\" value=\"%.18g\" />" ,MyEngine[i].OptimizationDecCoefCopy);
            fprintf(EnginesFile,"\n     <TRA:setting name=\"OptimizationStop\" value=\"%.18g\" />\n",MyEngine[i].OptimizationStop);
            //fprintf(EnginesFile,"\n        <TRA:setting name=\"Period\" value=\"%f\" />",MyEngine[i].Period);
            
            //if (MyEngine[i].iNumberOfTryValues)
            //{
            //    for (j = 0; j < MyEngine[i].iNumberOfTryValues; j++)
            //    {
            //        fprintf(EnginesFile,"\n        <TRA:setting name=\"TryVal\" value=\"%.24g\" /> <!-- %f -->",MyEngine[i].dValTry[j],MyEngine[i].dValTryMaxMin);
            //    }
            //}

            fprintf(EnginesFile,"\n\n    <!-- set impulses in a time -->");
            fprintf(EnginesFile,"\n        <TRA:setting name=\"FireTime\" value=\"%.18g\" />",MyEngine[i].FireTime);

            for (j = 0; j < MyEngine[i].iLine; j++)
            {
                fprintf(EnginesFile,"\n        <TRA:setting name=\"ImplVal\" value=\"%.24g\" /> <!-- %f -->",MyEngine[i].ValImpl[j], j*MyEngine[i].DeltaTime );
            }
            fprintf(EnginesFile,"\n</TRA:section>");
            fprintf(EnginesFile,"\n\n");
        }
        for (j=0; j < iOptPtr; j++)
        {
            fprintf(EnginesFile,"\n<TRA:section name=\"Optim\" value=\"%d\" />", j);
            makeExplanationText(szText, Opt[j].Calculate,
                    Opt[j].TrajectoryOptimizationType, 
                    Opt[j].NearBody);
            fprintf(EnginesFile,szText);
            fprintf(EnginesFile,"\n         <TRA:setting name=\"EngineToOptimize\" value=\"%d\" />",Opt[j].EngineToOptimize);
            if (j == 0)
            {
                fprintf(EnginesFile,"\n\n<!-- Type of optimization");
                fprintf(EnginesFile,"\n      1 - search for a minimum by adjusting time of firing");
                fprintf(EnginesFile,"\n      2 - search for a maximum by adjusting time of firing");       
                fprintf(EnginesFile,"\n      4 - search fo maximum by adjusting angle of firing");
                fprintf(EnginesFile,"\n      6 - search fo minimum by adjusting weight of fuel");

                fprintf(EnginesFile,"\n  initial step and decrease steps for each search specified");
                fprintf(EnginesFile,"\n  individualy for each engine -->\n");
            }

            fprintf(EnginesFile,"\n           <TRA:setting name=\"TrajectoryOptimizationType\" value=\"%d\" />",Opt[j].TrajectoryOptimizationType);
            if (j == 0)
                fprintf(EnginesFile,"\n\n     <!-- 2- EARTH 9-MOON for calculation distanses-->");
            fprintf(EnginesFile,"\n           <TRA:setting name=\"NearBody\" value=\"%d\" />",Opt[j].NearBody);
            if (j == 0)
            {
                fprintf(EnginesFile,"\n\n     <!-- calculates ");
                fprintf(EnginesFile,"\n          (0) Perigee to a center of NearBody");
                fprintf(EnginesFile,"\n          (1) Apogee to a center of NearBody");
                fprintf(EnginesFile,"\n          (3) taget practice not far than distance earth-moon");
                fprintf(EnginesFile,"\n          (5) target practice to apoint on a moon's surface");
                fprintf(EnginesFile,"\n          (6) orbit period around near body");
                fprintf(EnginesFile,"\n          (8) orbit period before engine firing");
                fprintf(EnginesFile,"\n          (9) first engine firing time");
                fprintf(EnginesFile,"\n          (10) second engine firing time");
                fprintf(EnginesFile,"\n          (11) third engine firing time (first try)");
                fprintf(EnginesFile,"\n          (12) at apogee difference from 3/4 of a earth-moon distance");
                fprintf(EnginesFile,"\n               --> ");
            }
            fprintf(EnginesFile,"\n           <TRA:setting name=\"Calculate\" value=\"%d\" />",Opt[j].Calculate);
            fprintf(EnginesFile,"\n           <TRA:setting name=\"OptimizationInitialStep\" value=\"%.18g\" />",Opt[j].OptimizationInitialStep);
            fprintf(EnginesFile,"\n           <TRA:setting name=\"OptimizationDecCoef\" value=\"%.18g\" />",Opt[j].OptimizationDecCoef);
            fprintf(EnginesFile,"\n           <TRA:setting name=\"OptimizationStop\" value=\"%.18g\" />",Opt[j].OptimizationStop);
            fprintf(EnginesFile,"\n           <TRA:setting name=\"LastEngine\" value=\"%d\" />\n",Opt[j].LastEngine);
            fprintf(EnginesFile,"\n        <TRA:setting name=\"Period\" value=\"%f\" />",Opt[j].Period);
            fprintf(EnginesFile,"\n</TRA:section>");
            fprintf(EnginesFile,"\n\n");
        }

        fprintf(EnginesFile,"\n</TRA:section>\n\n");

        fprintf(EnginesFile,"\n</TRA:data>");
        fclose(EnginesFile);
    }
}


// this will be a check doe it need to optimize next engine base on a results of a prev one
int CheckWhatnext(TRAOPTIMOBJ* Opt, TRAOBJ *Sat, TRAIMPLOBJ *Eng, TRAIMPLOBJ *EngStore, 
                  int &CurentEngine, int &CurentEngineOptimizationType,int &WhatWillBeLastEngine, 
                  int iNumbOfEngines, double dCurTime)
{
    int iret = 0;
    int i;
    int iOld;
    int iNewCalculate;
    int iNewNearBody;
    char szText[1024];
    
    //if (Eng[CurentEngine].NextEngineToOptimize[Eng[CurentEngine].iNextStepNow] != -1)
    if (++iOptimizationStep <= MaxOptim)
    {
        //iOptimizationStep++;
        //CurentEngineOptimizationType = Eng[CurentEngine].NextEngineToOptimizationType[Eng[CurentEngine].iNextStepNow];
        CurentEngineOptimizationType = Opt[iOptimizationStep].TrajectoryOptimizationType;
        //WhatWillBeLastEngine = Eng[CurentEngine].WhatWillBeLastEngine[Eng[CurentEngine].iNextStepNow];
        WhatWillBeLastEngine = Opt[iOptimizationStep].LastEngine;
        //iNewCalculate = Eng[CurentEngine].NextEngineToOptimizeCalculate[Eng[CurentEngine].iNextStepNow];
        iNewCalculate = Opt[iOptimizationStep].Calculate;
        //iNewNearBody = Eng[CurentEngine].NextEngineToOptimizationNearBody[Eng[CurentEngine].iNextStepNow];
        iNewNearBody = Opt[iOptimizationStep].NearBody;
        iOld = CurentEngine;
        //CurentEngine = Eng[CurentEngine].NextEngineToOptimize[Eng[CurentEngine].iNextStepNow];
        CurentEngine = Opt[iOptimizationStep].EngineToOptimize;
        Eng[CurentEngine].iCalculate = iNewCalculate;
        Eng[CurentEngine].NearBody = iNewNearBody;
        if (Opt[iOptimizationStep].OptimizationInitialStep != 0.0)
        {
            Eng[CurentEngine].OptimizationInitialStep = Opt[iOptimizationStep].OptimizationInitialStep;
            Eng[CurentEngine].OptimizationStop = Opt[iOptimizationStep].OptimizationStop;
            Eng[CurentEngine].OptimizationDecCoef = Opt[iOptimizationStep].OptimizationDecCoef;
        }
        // for the same engine adjust next step counter
        //if (iOld == CurentEngine)
        //{
        //    Eng[CurentEngine].iNextStepNow++;
        //}
        makeExplanationText(szText, iNewCalculate, CurentEngineOptimizationType,iNewNearBody);
        printf("\n next: %s", szText);

        // chek is it posible to do next step now?
        if (iNewCalculate == CALC_FIRE_FIRST_ENGINE_TIME || iNewCalculate == CALC_FIRE_SECOND_ENGINE_TIME ||
            iNewCalculate == CALC_FIRE_THIRD_ENGINE_TIME_TRY_ONE)
        {
            //Eng[CurentEngine].FireTime = dCurTime + Eng[CurentEngine].Period;
            Eng[CurentEngine].FireTime = dCurTime + Opt[iOptimizationStep-1].Period;
            printf("\n firing time set=%f ",Eng[CurentEngine].FireTime);
            iret = CheckWhatnext(Opt, Sat, Eng, EngStore, CurentEngine, CurentEngineOptimizationType, WhatWillBeLastEngine, iNumbOfEngines, dCurTime);

        }
        else
            iret = 1;
        // may be need to update value in storage for optimization?
        if (EngStore)
        {
            
            for (i = 0; i < MAX_ENGINES; i++)
            {
                EngStore[i].iCalculate = Eng[i].iCalculate;
                EngStore[i].FireTime = Eng[i].FireTime;
                //EngStore[i].iNextStepNow = Eng[i].iNextStepNow;
                EngStore[i].NearBody = Eng[i].NearBody;
                //EngStore[i].Period = Eng[i].Period;
                EngStore[i].OptimizationInitialStep = Eng[i].OptimizationInitialStep;
                EngStore[i].OptimizationStop = Eng[i].OptimizationStop;
                EngStore[i].OptimizationDecCoef = Eng[i].OptimizationDecCoef;

            }
        }
    }
    else
    {
        // that mean it will be exit - just dump curent satelite and engines status
        dumpXMLParam(Sat, Eng, iNumbOfEngines);
    }
    return iret;
}

void PrintPV(TRAOBJ *SlS, TRAOBJ *Sat, int iCheck, long double ldFrom, long double Time_SecondsFromStart);
#define TEST_RUN_CALC_YEAR 1
#define TEST_RUN_ERROR 1
#define TEST_RUN_EARTH_ERROR 1
void FindImpulses(void)
{
#ifdef FIND_IMPULSE_TIME
        for (int itry = 0 ; itry < 10000; itry++)
        {
        MyTry = SolarSystem;
        MyTrySat = Sat;
		MyEngine[0]= Engine[0];MyEngine[1]= Engine[1];MyEngine[2]= Engine[2];MyEngine[3]= Engine[3];MyEngine[4]= Engine[4];MyEngine[5]= Engine[5];
        SCH_Per = 10000000000000.0;
        SCH_Apg = 0.0;
        iSCH_Apg = 0;
        iSCH_Per = 0;
        SCH_ApgPerTime = 0;


        iApog = 0;
        Apog = 0.0;
        iPerig = 0;
        Perig = 0.0;
        ApogPergTime = 0;
        PerigMoon = 100000000000.0;
        iStartLandingIteraPerSec = 0;
        idRMDelta = 0;
#endif

#ifdef FIND_IMPULSE_TIME
                    // apogee and prerigee search each time
                    if (Apog < (dRE - EarthR))
                    {
                        Apog = (dRE - EarthR);
                        iApog = 1;
                    }
                    else
                    {
                        if (iApog)
                        {
                            if (i + j*SlS->TimeSl - ApogPergTime >100)
                            {
                                printf("\n Apog = %f km DT = %f at=%d sec", Apog/1000.0, i + j*SlS->TimeSl - ApogPergTime, i);
                                if ((EngineToOptimize == 0) || 
                                    (EngineToOptimize > 0 && EngineToOptimize < MAX_ENGINES && (Engine[EngineToOptimize].EngineDone==0) && (Engine[EngineToOptimize-1].EngineDone!=0))
                                   )
                                //if (EngineToOptimize >=0 && EngineToOptimize < MAX_ENGINES)
                                {
                                    if (Engine[EngineToOptimize].iCountApogPerig ==0) // frist apogee skip
                                        Engine[EngineToOptimize].iCountApogPerig = 1;
                                    else
                                    {
                                        // on second apogee store value
                                        Engine[EngineToOptimize].SeartchForPeriod = i + j*SlS->TimeSl - ApogPergTime;
                                        Engine[EngineToOptimize].iCountApogPerig = 2;
                                    }
                                }
                                iApog = 0;
                                Perig = (dRE - EarthR);
                                ApogPergTime = i + j*SlS->TimeSl;
                                printf(", Disatnce from a Moon %f km",dRM/1000.0);
                            }
                        }
                    }
                    if (Perig > (dRE - EarthR))
                    {
                        Perig = (dRE - EarthR);
                        iPerig = 1;

                    }
                    else
                    {
                        if (iPerig)
                        {
                            if (i + j*SlS->TimeSl - ApogPergTime >100)
                            {
                                printf("\n Perig = %f km DT = %f", Perig/1000.0, i + j*SlS->TimeSl - ApogPergTime);
                                if ((EngineToOptimize == 0) || 
                                    (EngineToOptimize > 0 && EngineToOptimize < MAX_ENGINES && (Engine[EngineToOptimize].EngineDone==0) && (Engine[EngineToOptimize-1].EngineDone!=0))
                                   )
                                //if (EngineToOptimize >=0 && EngineToOptimize < MAX_ENGINES)
                                {

                                    if (Engine[EngineToOptimize].iCountApogPerig == 2) // this will be second perigee
                                    {
                                        Engine[EngineToOptimize].SeartchForPeriod += i + j*SlS->TimeSl - ApogPergTime;
                                        //Engine[EngineToOptimize].Period = Engine[EngineToOptimize].SeartchForPeriod;
                                        Opt[iOptimizationStep].Period = Engine[EngineToOptimize].SeartchForPeriod;
                                        Engine[EngineToOptimize].iCountApogPerig = 3;
                                        if (Engine[EngineToOptimize].iCalculate == CALC_INIT_PERIOD)
                                        {
                                            if (CheckWhatnext(&Opt[0],&Sat, &Engine[0], &MyEngine[0], EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*SlS->TimeSl) == 0)
                                            {
                                                exit(0);
                                            }
                                        }
                                    }
                                }
                                iPerig = 0;
                                Apog = (dRE - EarthR);
                                ApogPergTime = i + j*SlS->TimeSl;
                            }
                        }
                    }
                    if ((LastEngine >= 0) && (LastEngine <= MAX_ENGINES) && (Engine[LastEngine].EngineDone))
                    {
                        SCH_Dist = sqrt(
                            (ProbX - SolarSystem.X[Engine[LastEngine].NearBody])*(ProbX - SolarSystem.X[Engine[LastEngine].NearBody])+
                            (ProbY - SolarSystem.Y[Engine[LastEngine].NearBody])*(ProbY - SolarSystem.Y[Engine[LastEngine].NearBody])+
                            (ProbZ - SolarSystem.Z[Engine[LastEngine].NearBody])*(ProbZ - SolarSystem.Z[Engine[LastEngine].NearBody])
                            );
                        dREMV = sqrt((SolarSystem.VX[Engine[LastEngine].NearBody]-Sat.VX[0])*(SolarSystem.VX[Engine[LastEngine].NearBody]-Sat.VX[0])+
                                     (SolarSystem.VY[Engine[LastEngine].NearBody]-Sat.VY[0])*(SolarSystem.VY[Engine[LastEngine].NearBody]-Sat.VY[0])+
                                     (SolarSystem.VZ[Engine[LastEngine].NearBody]-Sat.VZ[0])*(SolarSystem.VZ[Engine[LastEngine].NearBody]-Sat.VZ[0]));
                        if (Engine[LastEngine].iCalculate == CALC_APOGEE) // value 1
                        {
                            if (SCH_Apg < SCH_Dist)
                            {
                                SCH_Apg = SCH_Dist;
                                iSCH_Apg = 1;
                            }
                            else
                            {
                                if (iSCH_Apg)
                                {
                                    printf("\n SCHApogee = %f km (%f) DT = %f at=%d sec", SCH_Apg/1000.0,
                                        (SCH_Apg - GetRadius(&SolarSystem, Engine[LastEngine].NearBody, &Sat, 0))/1000.0,
                                        i + j*SlS->TimeSl - SCH_ApgPerTime, i);
                                    iSCH_Apg = 0;
                                    SCH_Per = SCH_Apg;
                                    SCH_ApgPerTime = (int)(i + j*SlS->TimeSl);
                                    printf("====engine==i=%d====<fire at=%f=>===",i,Engine[EngineToOptimize].FireTime);
                                    // SCH_Per is a parameter for that "call"
                                    goto NextTry;
                                }
                            }
                        }
                        else if (Engine[LastEngine].iCalculate == CALC_PERIGEE) // value 0
                        {
                            if (SCH_Per > SCH_Dist)
                            {
                                SCH_Per = SCH_Dist;
                                iSCH_Per = 1;
                            }
                            else
                            {
                                if (iSCH_Per)
                                {
                                    if (SCH_Per < 300000000.0)
                                    {
                                        printf("\n SCHPerigee = %f km (%f)DT = %f at=%d sec", SCH_Per/1000.0, 
                                        (SCH_Per-GetRadius(&SolarSystem, Engine[LastEngine].NearBody, &Sat, 0))/1000.0, 
                                        i + j*SlS->TimeSl - SCH_ApgPerTime, i);
                                        iSCH_Apg = 0;
                                        SCH_Apg = SCH_Per;
                                        SCH_ApgPerTime = (int)(i + j*SlS->TimeSl);
                                        printf("====engine==i=%d====<fire at=%f=>===",i,Engine[EngineToOptimize].FireTime);
                                        // SCH_Per is a parameter for that "call"
                                        goto NextTry;
                                    }
                                }
                            }
                        }
                        else if (Engine[LastEngine].iCalculate == CALC_TARGET_PRACTICE) // value 3
                        {
                            double dREM = sqrt((MoonX - EarthX)*(MoonX - EarthX)+
                                                (MoonY - EarthY)*(MoonY - EarthY)+
                                                (MoonZ - EarthZ)*(MoonZ - EarthZ));
                            // for target practice next check is fly out of moon-earth distance anyway this is a missing target
                            if (dREM < dRE)
						    {
							    printf("\n Target practice get to Moon = %f km ", PerigMoon/1000.0);
                                printf("===i=%d===========<==%f=>==v=%f=",i,Engine[EngineToOptimize].FireTime-dRMDelta,dREMV);
                                SCH_Per = SCH_Dist;
                                // SCH_Per is a parameter for that "call"
                                goto NextTry;
						    }
                            if (SCH_Per > SCH_Dist )
                            {
                                SCH_Per = SCH_Dist;
                            }
                            else
                            {
                                if (SCH_Per < 300000000.0)
                                {
                                    printf("\n Traget practice Perigee Moon = %f km ", SCH_Per/1000.0);
                                    printf("===i==%d===========<==%f=>==v=%f=",i,Engine[EngineToOptimize].FireTime-dRMDelta,dREMV);
                                    // SCH_Per is a parameter for that "call"
                                    goto NextTry;
                                }
                            }
                        }
                        else if (Engine[LastEngine].iCalculate == CALC_TARGET_POINT)  // value 5
                        {
							
							double dREM = sqrt((MoonX - EarthX)*(MoonX - EarthX)+
                                                (MoonY - EarthY)*(MoonY - EarthY)+
                                                (MoonZ - EarthZ)*(MoonZ - EarthZ))+20.0*MoonR;
                            // for target practice next check is fly out of moon-earth distance anyway this is a missing target
                            if (dREM < dRE)
						    {
							    printf("\n Target practice get to Moon = %f km ", PerigMoon/1000.0);
                                printf("===i=%d===========<==%f=>==v=%f=",i,Engine[EngineToOptimize].FireTime-dRMDelta,dREMV);
                                SCH_Per = SCH_Dist;
                                // SCH_Per is a parameter for that "call"
                                goto NextTry;
						    }
							if (SCH_Dist < MoonR*2)
							{
								double PosXMoon = 0;
								double PosYMoon = 0;
								double PosZMoon = 0;

                                // first Longitude second latitute
                                 // dolgota,  shirota

		                        getXYZMoon(Targetlongitude,Targetlatitude,PosXMoon,PosYMoon,PosZMoon,&SolarSystem,MOON,EARTH,MoonR);
								if (SCH_Dist < MoonR)
								{
									SCH_Dist = sqrt(
				                    (ProbX - PosXMoon)*(ProbX - PosXMoon)+
						            (ProbY - PosYMoon)*(ProbY - PosYMoon)+
								    (ProbZ - PosZMoon)*(ProbZ - PosZMoon)
									);
									SCH_Per = SCH_Dist;
									printf("\n Traget practice Point on a Moon = %f km ", SCH_Per/1000.0);
									printf("===i==%d===========<==%f=>==v=%f=",i,Engine[EngineToOptimize].FireTime-dRMDelta,dREMV);
										// SCH_Per is a parameter for that "call"
										goto NextTry;
								}
		                        SCH_Dist = sqrt(
				                    (ProbX - PosXMoon)*(ProbX - PosXMoon)+
						            (ProbY - PosYMoon)*(ProbY - PosYMoon)+
								    (ProbZ - PosZMoon)*(ProbZ - PosZMoon)
									);
							}
                            if (SCH_Per > SCH_Dist )
                            {
                                SCH_Per = SCH_Dist;
								iSCH_Per = 1;
                            }
                            else
                            {
								if (iSCH_Per)
								{
									if (SCH_Per < 300000000.0)
									{
										printf("\n Traget practice Point on a Moon = %f km ", SCH_Per/1000.0);
										printf("===i==%d===========<==%f=>==v=%f=",i,Engine[EngineToOptimize].FireTime-dRMDelta,dREMV);
										// SCH_Per is a parameter for that "call"
										goto NextTry;
									}
                                }
                            }
                        }
                        else if (Engine[LastEngine].iCalculate == CALC_PERIOD) // value 6
                        {
                            if (Engine[LastEngine].iCountApogPerig == 3)
                            {
                                if (CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*SlS->TimeSl) == 0)
                                {
                                    exit(0);
                                }
                            }
                        }
                        else if (Engine[LastEngine].iCalculate == CALC_AT_APOGEE_DIFF_TO_3_4_DIST) // 12
                        {
                            if (SCH_Dist > 400000000*1.25)
                                SCH_Dist = 400000000*1.25;
                            if (SCH_Apg < SCH_Dist)
                            {
                                SCH_Apg = SCH_Dist;
                                iSCH_Apg = 1;
                            }
                            else
                            {
                                if (iSCH_Apg)
                                {
                                    printf("\n SCHApogee = %f km (%f) DT = %f at=%d sec", SCH_Apg/1000.0,
                                        (SCH_Apg - GetRadius(&SolarSystem, Engine[LastEngine].NearBody, &Sat, 0))/1000.0,
                                        i + j*SlS->TimeSl - SCH_ApgPerTime, i);
                                    iSCH_Apg = 0;
                                    SCH_Per = SCH_Apg;
                                    SCH_ApgPerTime = (int)(i + j*SlS->TimeSl);
                                    SCH_Per = abs(SCH_Per - 400000000*0.75);
                                    printf("====engine==i=%d====<weight at=%f=>===",i,Engine[EngineToOptimize].Weight);
                                    // SCH_Per is a parameter for that "call"
                                    goto NextTry;
                                }
                            }
                        }
                    }
#endif
#ifdef FIND_IMPULSE_TIME
NextTry:
            SolarSystem = MyTry;
            Sat = MyTrySat;
            Engine[0] = MyEngine[0];Engine[1] = MyEngine[1];Engine[2] = MyEngine[2];Engine[3] = MyEngine[3];Engine[4] = MyEngine[4];Engine[5] = MyEngine[5]; 
            if ((LastEngine >=0) && (LastEngine < MAX_ENGINES))
            {

                switch(TrajectoryOptimizationType)
                {
                case MAXIMUM_BY_TIME: // value 2
                    // first assign intial values
                    if (idRM == 0)
                    {
                        dRM2 = dRM1;
                        dRM1 = SCH_Per; // this is a parameter for optimization (has to be maximized)
                        Engine[EngineToOptimize].FireTime += Engine[EngineToOptimize].OptimizationInitialStep;
                        idRM = 1;
                        idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                    }
                    else if (idRM == 1)
                    {
                        dRM2 = dRM1;
                        dRM1 = SCH_Per;
                        if (dRM2 < dRM1)
                        {
                            printf("\n Maximum at %d %f ", itry,dRM2);
                            Engine[EngineToOptimize].FireTime += Engine[EngineToOptimize].OptimizationInitialStep;
                            idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                        }
                        else
                        {
                            if (Engine[EngineToOptimize].OptimizationFirstDirectionSwitch++)
                            {
                                Engine[EngineToOptimize].OptimizationInitialStep = Engine[EngineToOptimize].OptimizationInitialStep/Engine[EngineToOptimize].OptimizationDecCoef;
                                if (abs(Engine[EngineToOptimize].OptimizationInitialStep) < Engine[EngineToOptimize].OptimizationStop)
                                {
                                    printf("\n optimization reached max delta value");
                                    if (CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*TimeSl) == 0)
                                    {
                                        exit(0);
                                    }
                                    idRM = 0;
                                    break;
                                }
                            }
                            Engine[EngineToOptimize].OptimizationInitialStep = -Engine[EngineToOptimize].OptimizationInitialStep;
                            idRM = 0;
                        }

                    }
                    break;
                case MINIMUM_BY_TIME: // value 1
                    if (idRM == 0)
                    {
                        dRM2 = dRM1;
                        dRM1 = SCH_Per; // this is a parameter for optimization (has to be minimized)
                        Engine[EngineToOptimize].FireTime += Engine[EngineToOptimize].OptimizationInitialStep;
                        idRM = 1;
                        idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                    }
                    
                    else
                    {
                        dRM2 = dRM1;
                        dRM1 = SCH_Per;
                        if (dRM2 > dRM1)
                        {
                            Engine[EngineToOptimize].FireTime += Engine[EngineToOptimize].OptimizationInitialStep;
                            idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                        }
                        else
                        {
                            if (Engine[EngineToOptimize].OptimizationFirstDirectionSwitch++)
                            {
                                Engine[EngineToOptimize].OptimizationInitialStep = Engine[EngineToOptimize].OptimizationInitialStep/Engine[EngineToOptimize].OptimizationDecCoef;
                                if (abs(Engine[EngineToOptimize].OptimizationInitialStep) < Engine[EngineToOptimize].OptimizationStop)
                                {
                                    printf("\n optimization reached min delta value");
                                    if (CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*TimeSl) == 0)
                                    {
                                        exit(0);
                                    }
                                    idRM = 0;
                                    break;
                                }
                            }
                            Engine[EngineToOptimize].OptimizationInitialStep = -Engine[EngineToOptimize].OptimizationInitialStep;
							idRM = 0;
                            printf("\n Minimum at %d %f ", itry,dRM2);
                        }
                    }
                    break;
                case MINIMUM_BY_WEIGHT: //  value 6
                    // first assign intial values
                    if (idRM == 0)
                    {
                        int iIm = 0;
                        dRM2 = dRM1;
                        dRM1 = SCH_Per; // this is a parameter for optimization (has to be minimized)
                        for (iIm = 0; iIm <Engine[EngineToOptimize].iLine; iIm++)
                        {
                            Engine[EngineToOptimize].ValImpl[iIm] += Engine[EngineToOptimize].OptimizationInitialStep*
                                Engine[EngineToOptimize].ValImpl[iIm];
                        }
                        Engine[EngineToOptimize].Weight += Engine[EngineToOptimize].OptimizationInitialStep*
                            Engine[EngineToOptimize].Weight;
                        Engine[EngineToOptimize].TotalWeight += Engine[EngineToOptimize].OptimizationInitialStep*
                            Engine[EngineToOptimize].TotalWeight;
                        Engine[EngineToOptimize].TotalImpulse += Engine[EngineToOptimize].OptimizationInitialStep*
                            Engine[EngineToOptimize].TotalImpulse;
                        
                        idRM = 1;
                        idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                    }
                    else if (idRM == 1)
                    {
                        dRM2 = dRM1;
                        dRM1 = SCH_Per;
                        if (dRM2 > dRM1)
                        {
                            int iIm = 0;
                            printf("\n Minimum at %d %f ", itry,dRM2);
                            for (iIm = 0; iIm <Engine[EngineToOptimize].iLine; iIm++)
                            {
                                Engine[EngineToOptimize].ValImpl[iIm] += Engine[EngineToOptimize].OptimizationInitialStep*
                                    Engine[EngineToOptimize].ValImpl[iIm];
                            }
                            Engine[EngineToOptimize].Weight += Engine[EngineToOptimize].OptimizationInitialStep*
                                Engine[EngineToOptimize].Weight;
                            Engine[EngineToOptimize].TotalWeight += Engine[EngineToOptimize].OptimizationInitialStep*
                                Engine[EngineToOptimize].TotalWeight;

                            Engine[EngineToOptimize].TotalImpulse += Engine[EngineToOptimize].OptimizationInitialStep*
                            Engine[EngineToOptimize].TotalImpulse;
                        
                            idRMDelta += (int)Engine[EngineToOptimize].OptimizationInitialStep;
                        }
                        else
                        {
                            if (Engine[EngineToOptimize].OptimizationFirstDirectionSwitch++)
                            {
                                Engine[EngineToOptimize].OptimizationInitialStep = Engine[EngineToOptimize].OptimizationInitialStep/Engine[EngineToOptimize].OptimizationDecCoef;
                                if (abs(Engine[EngineToOptimize].OptimizationInitialStep) < Engine[EngineToOptimize].OptimizationStop)
                                {
                                    printf("\n optimization reached max delta value");
                                    if (CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*TimeSl) == 0)
                                    {
                                        exit(0);
                                    }
                                    idRM = 0;
                                    break;
                                }
                            }
                            Engine[EngineToOptimize].OptimizationInitialStep = -Engine[EngineToOptimize].OptimizationInitialStep;
                            idRM = 0;
                        }

                    }
                    break;
                case MINIMUM_BY_ANGLE: //  value 4
					// find closest point to but by adjusting angle
                    if (iFirstAngleDone == 0)
                    {
                        LastStepTryAnglesDirValuesX = Engine[EngineToOptimize].XVec;
                        LastStepTryAnglesDirValuesY = Engine[EngineToOptimize].YVec;
                        LastStepTryAnglesDirValuesZ = Engine[EngineToOptimize].ZVec;
						LastStepHistX[0] = LastStepTryAnglesDirValuesX;
                        LastStepHistY[0] = LastStepTryAnglesDirValuesY;
                        LastStepHistZ[0] = LastStepTryAnglesDirValuesZ;
						//TryAnglesDirValues[0] = dRM;
                        iFirstAngleDone = 1;
                        TryAnglesDirDelta = Engine[EngineToOptimize].OptimizationInitialStep;
                    }
                    else
                    {
                        
                        TryAnglesDirValues[iTryAnglesDir] = SCH_Per; // this is a parameter for optimization (has to be minimized)
                        // attempt to check: may be next step is not nesesary- vector is (0,0,0)!? which is bad!
                        while(iTryAnglesDir + 1 <= iMaxTryAnglesDir)
                        {
                            if ((abs(LastStepTryAnglesDirValuesX + TryAnglesDir[iTryAnglesDir+1][0]*TryAnglesDirDelta) <= 0.0000001) &&
                                (abs(LastStepTryAnglesDirValuesY + TryAnglesDir[iTryAnglesDir+1][1]*TryAnglesDirDelta) <= 0.0000001) &&
                                (abs(LastStepTryAnglesDirValuesZ + TryAnglesDir[iTryAnglesDir+1][2]*TryAnglesDirDelta) <= 0.0000001))
                            {
                                // make it garante big
                                TryAnglesDirValues[iTryAnglesDir+1] = SCH_Per*1000;
                                iTryAnglesDir++;
                                continue;
                            }
                            break;
                        }
                        if (++iTryAnglesDir > iMaxTryAnglesDir)
                        {
                            // find minimum
							iFindMin = 0;
                            FindMin = TryAnglesDirValues[iFindMin];
                            
                            newTryAnglesDirDelta=TryAnglesDirDelta;
                            for(int iSe = iFindMin+1; iSe <= iMaxTryAnglesDir; iSe++)
                            {
                                if (FindMin > TryAnglesDirValues[iSe])
                                {
                                    FindMin = TryAnglesDirValues[iSe];
                                    iFindMin = iSe;
                                }
                            }
							// check to adjust TryAnglesDirDelta to be smaller
							if (iFindMin == 0)
							{
                                newTryAnglesDirDelta = TryAnglesDirDelta/Engine[EngineToOptimize].OptimizationDecCoef;
                                printf("\n<TRA:setting name=\"FireAng1\" value=\"0.0\" />");
                                printf("\n<TRA:setting name=\"FireAng2\" value=\"0.0\" />");
                                printf("\n    <TRA:setting name=\"XVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesX+ TryAnglesDir[iFindMin][0]*TryAnglesDirDelta));
                                printf("\n    <TRA:setting name=\"YVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesY+ TryAnglesDir[iFindMin][1]*TryAnglesDirDelta));
                                printf("\n    <TRA:setting name=\"ZVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesZ+ TryAnglesDir[iFindMin][2]*TryAnglesDirDelta));

                                if (newTryAnglesDirDelta < Engine[EngineToOptimize].OptimizationStop)
                                {
                                    printf("\n optimization minimum by angle done");
                                    if (CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*TimeSl) == 0)
                                    {
                                        exit(0);
                                    }
                                    idRM = 0;
                                    break;
                                }
							}
							else
							{
                                int iTemp = 1;
								// check to adjust TryAnglesDirDelta to be smaller
								for (int iHistS = 0; iHistS < 10; iHistS++)
								{
									if ((LastStepHistX[iHistS] == (LastStepTryAnglesDirValuesX+ TryAnglesDir[iFindMin][0]*TryAnglesDirDelta)) &&
										(LastStepHistY[iHistS] == (LastStepTryAnglesDirValuesY+ TryAnglesDir[iFindMin][1]*TryAnglesDirDelta)) &&
										(LastStepHistZ[iHistS] == (LastStepTryAnglesDirValuesZ+ TryAnglesDir[iFindMin][2]*TryAnglesDirDelta)))
									{
                                        newTryAnglesDirDelta = TryAnglesDirDelta/Engine[EngineToOptimize].OptimizationDecCoef;
										printf("\n<TRA:setting name=\"FireAng1\" value=\"0.0\" />");
										printf("\n<TRA:setting name=\"FireAng2\" value=\"0.0\" />");
										printf("\n    <TRA:setting name=\"XVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesX+ TryAnglesDir[iFindMin][0]*TryAnglesDirDelta));
										printf("\n    <TRA:setting name=\"YVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesY+ TryAnglesDir[iFindMin][1]*TryAnglesDirDelta));
										printf("\n    <TRA:setting name=\"ZVector\" value=\"%f\" />",(LastStepTryAnglesDirValuesZ+ TryAnglesDir[iFindMin][2]*TryAnglesDirDelta));

										if (newTryAnglesDirDelta < Engine[EngineToOptimize].OptimizationStop)
										{
                                            printf("\n optimization minimum by angle done");
                                            if (iTemp = CheckWhatnext(&Opt[0], &Sat, &Engine[0], NULL, EngineToOptimize, TrajectoryOptimizationType, LastEngine, EnginesCount,i + j*TimeSl) == 0)
                                            {
                                                exit(0);
                                            }
                                            idRM = 0;
	                                    }
		                                break;
			                        }
				                }
                                if (iTemp)
                                    break;
							}
                            // adjust next step try
                            Engine[EngineToOptimize].XVec = LastStepTryAnglesDirValuesX + TryAnglesDir[iFindMin][0]*TryAnglesDirDelta;
                            Engine[EngineToOptimize].YVec = LastStepTryAnglesDirValuesY + TryAnglesDir[iFindMin][1]*TryAnglesDirDelta;
                            Engine[EngineToOptimize].ZVec = LastStepTryAnglesDirValuesZ + TryAnglesDir[iFindMin][2]*TryAnglesDirDelta;
							TryAnglesDirValues[0] = TryAnglesDirValues[iFindMin];

                            for (int iHist = 10 - 1; iHist > 0; iHist --)
                            {
                                LastStepHistX[iHist] = LastStepHistX[iHist-1];
                                LastStepHistY[iHist] = LastStepHistY[iHist-1];
                                LastStepHistZ[iHist] = LastStepHistZ[iHist-1];
                            }
                            LastStepHistX[0] = LastStepTryAnglesDirValuesX;
                            LastStepHistY[0] = LastStepTryAnglesDirValuesY;
                            LastStepHistZ[0] = LastStepTryAnglesDirValuesZ;

                            iTryAnglesDir = 1;
                                
                            LastStepTryAnglesDirValuesX = Engine[EngineToOptimize].XVec;
                            LastStepTryAnglesDirValuesY = Engine[EngineToOptimize].YVec;
                            LastStepTryAnglesDirValuesZ = Engine[EngineToOptimize].ZVec;

                            TryAnglesDirDelta = newTryAnglesDirDelta;

                            if ((abs(LastStepTryAnglesDirValuesX + TryAnglesDir[iTryAnglesDir][0]*TryAnglesDirDelta) <= 0.0000001) &&
                                (abs(LastStepTryAnglesDirValuesY + TryAnglesDir[iTryAnglesDir][1]*TryAnglesDirDelta) <= 0.0000001) &&
                                (abs(LastStepTryAnglesDirValuesZ + TryAnglesDir[iTryAnglesDir][2]*TryAnglesDirDelta) <= 0.0000001))
                            {
                                // make it garante big
                                TryAnglesDirValues[iTryAnglesDir] = SCH_Per*1000;
                                iTryAnglesDir++;
                                //continue;
                            }
                        }
                        Engine[EngineToOptimize].XVec = LastStepTryAnglesDirValuesX + TryAnglesDir[iTryAnglesDir][0]*TryAnglesDirDelta;
                        Engine[EngineToOptimize].YVec = LastStepTryAnglesDirValuesY + TryAnglesDir[iTryAnglesDir][1]*TryAnglesDirDelta;
                        Engine[EngineToOptimize].ZVec = LastStepTryAnglesDirValuesZ + TryAnglesDir[iTryAnglesDir][2]*TryAnglesDirDelta;
                    
                    }
                    break;
                }
            }

        } // end of attempts to calculate optimum time of impulse to achive min distance from Moon
#endif

}



int JustRunApogee = 0;
int JustRunPerigee = 10000000;
int JustRunApPerStatus = 0; // search for apogee
int JustRuniCountDelay= 0;

void JustRun(TRAOBJ *SlS, TRAOBJ *Sat,TRAIMPLOBJ *Eng, long double ldFrom,long double ldFromTLEEpoch, long long iAllSec, int iItPerS, int irestRun, long double tSl, BOOL ShowData)
{
    SlS->TimeSl = tSl;
    SlS->TimeSl_2 = tSl*tSl;

    long long iSec;
    int iPortionSec;
    int iDistance =0;
    long double Time_SecondsFromStart=0;

    for (iSec = 0; iSec < iAllSec; iSec++)
    {
        for (iPortionSec = 0; iPortionSec < iItPerS; iPortionSec++)
        {
            IteraSat(1, SlS, Sat,ldFromTLEEpoch + (iSec +   (long double)iPortionSec/(long double)iItPerS) /86400.0) ;
            IteraSolarSystem(TRUE, SlS);
        }
        if (ShowData)
        {
            if (JustRunApPerStatus == 0)
            {
                if (JustRunApogee <= (int)Sat->Distance[0][EARTH])
                    JustRunApogee = Sat->Distance[0][EARTH];
                else
                {
                    JustRunApPerStatus = 1; // delay
                    JustRuniCountDelay = 100;
                    Time_SecondsFromStart = (iSec +   (long double)(iPortionSec+1)/(long double)iItPerS);
                    PrintPV(SlS, Sat, 0, ldFrom, Time_SecondsFromStart);
                }

            } else if (JustRunApPerStatus == 1)
            {
                if (--JustRuniCountDelay == 0)
                {
                    JustRunApPerStatus = 2; // search for perigee
                    JustRunPerigee = 1000000000;
                }
            } else if (JustRunApPerStatus == 2)
            {
                if (JustRunPerigee >= (int)Sat->Distance[0][EARTH])
                    JustRunPerigee = Sat->Distance[0][EARTH];
                else
                {
                    JustRunApPerStatus = 3; // delay
                    JustRuniCountDelay = 100;
                }
            } else if (JustRunApPerStatus == 3)
            {
                if (--JustRuniCountDelay == 0)
                {
                    JustRunApPerStatus = 0; // search for apogee
                    JustRunApogee  = 0;
                }
            }
        }
    }
    for (iPortionSec = 0; iPortionSec < irestRun; iPortionSec++)
    {
        IteraSat(1, SlS, Sat,ldFromTLEEpoch + (iSec +   (long double)iPortionSec/(long double)iItPerS) /86400.0) ;
        IteraSolarSystem(TRUE, SlS);
    }
}
unsigned char bRandBuffer[2048000];
int iRa=sizeof(bRandBuffer)/sizeof(unsigned long);
HCRYPTPROV hCryptProv = 0;
void Ra(unsigned char *bBuffer, int iBufferSize)
{
    if (hCryptProv == 0)
    {
        if (!CryptAcquireContextW(&hCryptProv,0, 0, PROV_RSA_FULL, 0))
        {
            hCryptProv = NULL;
            if (CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, CRYPT_NEWKEYSET))
            {
            }
        }
        if (hCryptProv)
            CryptGenRandom(hCryptProv, iBufferSize, bRandBuffer);
        //if (hCryptProv)
        //    CryptReleaseContext(hCryptProv, 0);
    }
    else
        CryptGenRandom(hCryptProv, iBufferSize, bRandBuffer);
}
unsigned long ra(void)
{
    if (iRa >= (sizeof(bRandBuffer)/sizeof(unsigned long)))
    {
        Ra(bRandBuffer, sizeof(bRandBuffer));
        iRa =0;
    }
    return ((unsigned long*)&bRandBuffer[0])[iRa++];
}
void GetRandomNVector(long double &Xn, long double &Yn, long double&Zn)
{
    Xn = -(long double)ra();
    Yn = -(long double)ra();
    Zn = -(long double)ra();
    Xn += (long double)ra();
    Yn += (long double)ra();
    Zn += (long double)ra();
    long double Rn = sqrt(Xn*Xn + Yn*Yn + Zn*Zn);
    Xn = Xn/Rn; Yn = Yn/Rn; Zn = Zn/Rn;
}
void SetCalcSat(TRAOBJ *Sat, TRAOBJ *SlS, int iSat, long double X, long double Y, long double Z, long double VX, long double VY, long double VZ)
{
    Sat->X[iSat] += X; Sat->Y[iSat] += Y; Sat->Z[iSat] += Z;
    Sat->VX[iSat] += VX; Sat->VY[iSat] += VY; Sat->VZ[iSat] += VZ;
    Sat->X0divDt2[iSat]=Sat->X[iSat] /SlS->TimeSl_2;
    Sat->Y0divDt2[iSat]=Sat->Y[iSat] /SlS->TimeSl_2;
    Sat->Z0divDt2[iSat]=Sat->Z[iSat] /SlS->TimeSl_2;
    Sat->VX0divDt[iSat]=Sat->VX[iSat] /SlS->TimeSl;
    Sat->VY0divDt[iSat]=Sat->VY[iSat] /SlS->TimeSl;
    Sat->VZ0divDt[iSat]=Sat->VZ[iSat] /SlS->TimeSl;
    Sat->iAtm[iSat] = 1;
    Sat->CountNx = 0; Sat->CountNy = 0; Sat->CountNz = 0;
    Sat->RunOne = TRUE;
}
void RunCalc(TRAOBJ *SlS, TRAOBJ *Sat,TRAIMPLOBJ *Eng, long double ldFrom,long double ldFromTLEEpoch, long long iAllSec, int iItPerS, long double tSl)
{
    int i;
    SlS->TimeSl = tSl;
    SlS->TimeSl_2 = tSl*tSl;

    if (memcmp(Mode,"CALC_ON_EARTH",12)==0) // one point on earth
    {
        int ListM[MAX_MEASURES];
        int iListM = 0;

        long double tErrorTime = measures[0].Err;
        tErrorTime /= 2.0;
        long double tErrorTimeD = tErrorTime / (24.0*60.0*60.0);
        AssignFromNASAData(SlS, measures[0].T - tErrorTimeD- 1.0/86400.0); // starting time
        AssignAllSatelites(SlS, EARTH, Sat, measures[0].T- tErrorTimeD- 1.0/86400.0);

        SYSTEMTIME ThatTime;
        long double ldRunFromTLEEpoch = ConvertJulianDayToDateAndTime(measures[0].T- tErrorTimeD - 1.0/86400.0, &ThatTime);
        long long iRunSec = ((measures[iMaxMeasures-1].T - measures[0].T)*(24.0*60.0*60.0))+tErrorTime*2.0 + 1;
        long double ldRunFrom = measures[0].T- tErrorTimeD - 1.0/86400.0 ;
        long long iSec;
        int iDistance =0;
        int iPortionSec;
        long double Time_SecondsFromStart=0;
        BOOL ShowData = TRUE;
        int iPt = 0;
        long double ldCT_TLE;
        long double ldCT_jd;
        BOOL StartPresize = FALSE;
        for (iSec = 0; iSec < iRunSec; iSec++)
        {
            ldCT_TLE = ldRunFromTLEEpoch + (iSec) /86400.0;
            ldCT_jd = ldRunFrom+ (iSec) /86400.0;
            if (StartPresize == FALSE)
            {
                // check that any measurements is in a reach of mesurement time
                for (int k = 0; k < iMaxMeasures; k++)
                {
                    long double SecondsPerD = (measures[k].P1+measures[k].P2+measures[k].P3-tErrorTime)/86400.0;
                    if ((ldCT_jd >= (measures[k].T-tErrorTimeD)) &&  (ldCT_jd <= (measures[k].T+SecondsPerD)))// measuremt was started
                    {
                        StartPresize = TRUE;
                        ListM[iListM] = k;
                        if (++iListM >= iMaxMeasures)
                            iListM = iMaxMeasures-1;
                    }
                }
                if (StartPresize == TRUE)
                {
#define PRECISE_TIME_PERIOD_DIVIDER 100
                    SwitchCalcTimePeriod(SlS, Sat, PRECISE_TIME_PERIOD_DIVIDER);
                    iItPerS = iItPerS*PRECISE_TIME_PERIOD_DIVIDER;
                }
            }
            else
            {
                // add any measurements if it is in a reach of measurement time
                for (int k = 0; k < iMaxMeasures; k++)
                {
                    long double SecondsPerD = (measures[k].P1+measures[k].P2+measures[k].P3-tErrorTime)/86400.0;
                    if ((ldCT_jd >= (measures[k].T-tErrorTimeD)) &&  (ldCT_jd <= (measures[k].T+SecondsPerD)))// measuremt was started
                    {
                        // check - is it already in the list?
                        BOOL FindInList = FALSE;
                        for (int m=0; m < iListM; m++)
                        {
                            if (ListM[m] == k)
                            {
                                FindInList = TRUE;
                                break;
                            }
                        }
                        // if not in the list then add
                        if (FindInList == FALSE)
                        {
                            ListM[iListM] = k;
                            if (++iListM >= iMaxMeasures)
                                iListM = iMaxMeasures-1;
                        }
                    }
                }
                // check that measurement is out of measurement time of any measurement record
                for (int k = 0; k < iListM; k++)
                {
                    long double SecondsPerD = (measures[ListM[k]].P1+measures[ListM[k]].P2+measures[ListM[k]].P3-tErrorTime)/86400.0;
                    if (ldCT_jd >= (measures[ListM[k]].T+SecondsPerD)) // measuremt was started and passed max time
                    {
                        // now needs to detele record from the list
                        for (int m = k+1; m < iListM; m++)
                        {
                            ListM[m-1] = ListM[m];
                        }
                        iListM--;
                        k--;
                        if (iListM == 0)
                        {
                            StartPresize = FALSE;
                        }
                    }
                }
                if (StartPresize == FALSE)
                {
                    SwitchBackCalcTimePeriod(SlS, Sat);
                    iItPerS /=PRECISE_TIME_PERIOD_DIVIDER;
                }
            }
            for (iPortionSec = 0; iPortionSec < iItPerS; iPortionSec++)
            {
                ldCT_TLE = ldRunFromTLEEpoch + (iSec +   (long double)iPortionSec/(long double)iItPerS) /86400.0;
                ldCT_jd = ldRunFrom + (iSec +   (long double)iPortionSec/(long double)iItPerS) /86400.0;
                IteraSat(1, SlS, Sat,ldCT_TLE) ;
                IteraSolarSystem(TRUE, SlS);
            }
            if (ShowData)
            {
                if (JustRunApPerStatus == 0)
                {
                    if (JustRunApogee <= (int)Sat->Distance[0][EARTH])
                        JustRunApogee = Sat->Distance[0][EARTH];
                    else
                    {
                        JustRunApPerStatus = 1; // delay
                        JustRuniCountDelay = 100;
                        Time_SecondsFromStart = (iSec +   (long double)(iPortionSec+1)/(long double)iItPerS);
                        PrintPV(SlS, Sat, 0, ldRunFrom, Time_SecondsFromStart);
                    }

                } else if (JustRunApPerStatus == 1)
                {
                    if (--JustRuniCountDelay == 0)
                    {
                        JustRunApPerStatus = 2; // search for perigee
                        JustRunPerigee = 1000000000;
                    }
                } else if (JustRunApPerStatus == 2)
                {
                    if (JustRunPerigee >= (int)Sat->Distance[0][EARTH])
                        JustRunPerigee = Sat->Distance[0][EARTH];
                    else
                    {
                        JustRunApPerStatus = 3; // delay
                        JustRuniCountDelay = 100;
                    }
                } else if (JustRunApPerStatus == 3)
                {
                    if (--JustRuniCountDelay == 0)
                    {
                        JustRunApPerStatus = 0; // search for apogee
                        JustRunApogee  = 0;
                    }
                }
            }
        }
        //for (i =0; i< iMaxMeasures; i++)
        //{
        //    iRunSec = ( measures[i].P1 + measures[i].P2 + measures[i].P3 + measures[i].Err ) + 1;
        //    SwitchCalcTimePeriod(SlS, sat, 10000);
        //    JustRun(SlS, Sat,Eng, ldRunFrom,ldRunFromTLEEpoch, iRunSec, iItPerS*10000, 0, tSl, TRUE);
        //    SwitchBackCalcTimePeriod(SlS, sat);
        //    iRunSec = ((measures[iMaxMeasures-1].T - measures[0].T)*(24.0*60.0*60.0));
        //    JustRun(SlS, Sat,Eng, ldRunFrom,ldRunFromTLEEpoch, iRunSec, iItPerS, 0, tSl, TRUE);
        //}

        //SwitchBackCalcTimePeriod(SlS, sat);
        //SwitchCalcTimePeriod(SlS, sat, 10000);

        return;
    }

    if (memcmp(Mode,"CALC_ON_MOON",12)==0) // one point on moon
    {

        return;
    }
    // calculation of the orbit.
    // adjust 
    for (i =0; i< iMaxMeasures; i++)
    {
        if (measures[i].NearBody >0) //gCRSmeasure -> hCRSmeasure
        {
            stateType  StateEarth;
            stateType  StateMoon;
            double dEMRAT = Find_DataInHeader("EMRAT ");
            double dAU = Find_DataInHeader("AU    ")*1000.0;

            Interpolate_State( measures[i].T, EARTH , &StateEarth );
            Interpolate_State( measures[i].T, MOON , &StateMoon );
            double BSX = StateEarth.Position[0]*1000.0 ;
            double BSY = StateEarth.Position[1]*1000.0 ;
            double BSZ = StateEarth.Position[2]*1000.0 ;
            SlS->X[EARTH] = BSX - (StateMoon.Position[0]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
            SlS->Y[EARTH] = BSY - (StateMoon.Position[1]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
            SlS->Z[EARTH] = BSZ - (StateMoon.Position[2]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
            measures[i].X += SlS->X[EARTH];
            measures[i].Y += SlS->Y[EARTH];
            measures[i].Z += SlS->Z[EARTH];
            if (i==0) // for the first measure on first sat set initial velocity
            {
                //Sat->VX[0] = StateEarth.Velocity[0] * 1000.0; Sat->VY[0] = StateEarth.Velocity[1] * 1000.0; Sat->VZ[0] = StateEarth.Velocity[3] * 1000.0;
            }
        }
    }
    // set ininials velositi is equal EARTH velocity
    long double PError = measures[0].Err;
    long double VelError = 0.010704334375;//10.0;//0.07;
    //for (int m = 0; m < iMaxMeasures; m++)
    printf("\n (init) PError =%.12f VelErr=%.12f",PError,VelError);
    int m0 = 0;
    int nextm = 1;
    long double dlIX, dlIY, dlIZ, dlIVX, dlIVY, dlIVZ;
    dlIX = Sat->X[0]; dlIY = Sat->Y[0]; dlIZ = Sat->Z[0];
    dlIVX = Sat->VX[0]; dlIVY = Sat->VY[0]; dlIVZ = Sat->VZ[0];
    //Sat->X[0] += -958.445037841797;   Sat->Y[0] += 629.093017578125;   Sat->Z[0] += -273.815940856934;
    //Sat->VX[0] += 0.001135664937; Sat->VY[0] += 0.000285064067; Sat->VZ[0] += -0.000475006107;
    for (m0= 1;m0 <iMaxMeasures; m0++)
    {
        long double Xn[9], Yn[9], Zn[9], Rn[9];
        int iCmin = 0;
DO_MATHC_AGAIN:
        for (int m = nextm; m <=m0; m++)
        {
            for (int n=0; n <13; n++)
            {
                TRAOBJ SolS1=*SlS;
                TRAOBJ Sat11= *Sat; // 1 error by position 1 error by velocity

                long double ldRunFrom =ldFrom;
                SYSTEMTIME ThatTime;
                long double ldRunFromTLEEpoch = ConvertJulianDayToDateAndTime(ldRunFrom, &ThatTime);
                long long iRunSec = (measures[m].T - measures[0].T)*(24*60*60);

                int irestRun = (((measures[m].T - measures[0].T) - (long double)(iRunSec/(24.0*60.0*60.0))))*24.0*60.0*60.0* iItPerS*10;
                irestRun +=1;
                irestRun/=10;

                long double XYZ_err = PError;
                long double VXYZerr = VelError;
                long double VXn[9], VYn[9], VZn[9];
                long double Xe[9], Ye[9], Ze[9];
                LONG_DOUBLE_INT_VAR _position_[9];
                LONG_DOUBLE_INT_VAR _velosity_[9];
                int iC = 0;
                iCmin = 0;
                long double rmin;
                long double RnSumm = 0;
                stateType  StateEarth;
                Interpolate_State( ldRunFrom, EARTH , &StateEarth );
                for (iC=0; iC < 9; iC++)
                {
                    XYZ_err = PError * (long double)(0xffffff & ra())/((long double)(0xffffff));
                    VXYZerr = VelError * (long double)(0xffffff & ra())/((long double)(0xffffff));

                    if (iC)
                    {
                        GetRandomNVector(Xn[iC], Yn[iC], Zn[iC]);
                        Xn[iC]*= XYZ_err; Yn[iC]*= XYZ_err; Zn[iC]*= XYZ_err;

                        GetRandomNVector(VXn[iC], VYn[iC], VZn[iC]);
                        VXn[iC]*= VXYZerr; VYn[iC]*= VXYZerr; VZn[iC]*= VXYZerr;
                    }
                    else
                    {
                        Xn[iC] =0; Yn[iC] =0; Zn[iC] =0; VXn[iC] =0; VYn[iC] =0; VZn[iC] =0;
                    }
                    SolS1=*SlS; Sat11= *Sat;
                    SetCalcSat(&Sat11, &SolS1, 0, Xn[iC], Yn[iC], Zn[iC], VXn[iC], VYn[iC], VZn[iC]);
                    JustRun(&SolS1, &Sat11,Eng, ldRunFrom,ldRunFromTLEEpoch, iRunSec, iItPerS, irestRun, tSl, FALSE);
                    Xe[iC] = Sat11.X[0]; Ye[iC] = Sat11.Y[0]; Ze[iC] = Sat11.Z[0];
                    _position_[iC] = Sat11._position_[0];_velosity_[iC] = Sat11._velosity_[0];
                    long double vrmin = sqrt((Xe[iC]-measures[m].X)*(Xe[iC]-measures[m].X)+(Ye[iC]-measures[m].Y)*(Ye[iC]-measures[m].Y)+(Ze[iC]-measures[m].Z)*(Ze[iC]-measures[m].Z));
                    Rn[iC] = vrmin;
                    RnSumm += vrmin;
                
                    if (iC==0)
                    {
                        rmin = vrmin;
                        nextm = m0+1; // if error will match on iC =0 (X=0,0,0, V=0,0,0) than on next measurement all prev measurements can be skipped
                    }
                    else
                    {
                        if (vrmin < rmin)
                        {
                            iCmin = iC; rmin = vrmin;printf("\n min: %.5f",rmin);
                            nextm=1; // value changed needs to start from measurement 1
                        }
                    }
                
                    printf("\n% dE=,%.5f,%.5f,%.5f,%.5f", n, Xe[iC]-measures[m].X, Ye[iC]-measures[m].Y,Ze[iC]-measures[m].Z,sqrt((Xe[iC]-measures[m].X)*(Xe[iC]-measures[m].X)+(Ye[iC]-measures[m].Y)*(Ye[iC]-measures[m].Y)+(Ze[iC]-measures[m].Z)*(Ze[iC]-measures[m].Z))
                        );
                    printf("\n  X=%.12f,%.12f,%.12f,V=%.12f,%.12f,%.12f", Xn[iC],Yn[iC],Zn[iC], VXn[iC],VYn[iC],VZn[iC]);
                    if (vrmin < measures[m].Err)
                    {
                        Sat->X[0] += Xn[iCmin];   Sat->Y[0] += Yn[iCmin];   Sat->Z[0] += Zn[iCmin];
                        Sat->VX[0] += VXn[iCmin]; Sat->VY[0] += VYn[iCmin]; Sat->VZ[0] += VZn[iCmin];
                        printf("\n M0= %d m=%d measuements matched error => next measurement",m0, m);
                        goto NEXT_MEASURE;
                    }
                }
                Sat->X[0] += Xn[iCmin];   Sat->Y[0] += Yn[iCmin];   Sat->Z[0] += Zn[iCmin];
                Sat->VX[0] += VXn[iCmin]; Sat->VY[0] += VYn[iCmin]; Sat->VZ[0] += VZn[iCmin];
                if (iCmin)
                {
                    VelError /=2;
                    printf("\n (2.0) VelErr=%.12f",VelError);
                }
                else
                {
                    if (n == 0)
                    {
                
                        //VelError *= Rn[0]*9.0/ RnSumm;
                        //printf("\n (main) VelErr=%.12f",VelError);
                        VelError /=1.5;
                        printf("\n (1.5) VelErr=%.12f",VelError);
                    }
                    else
                    {
                        VelError /=1.5;
                        printf("\n (1.5) VelErr=%.12f",VelError);
                    }
                }
            }
            printf("\nbest  X=%.12f,%.12f,%.12f,V=%.12f,%.12f,%.12f", Sat->X[0] - dlIX, Sat->Y[0] - dlIY, Sat->Z[0] - dlIZ, Sat->VX[0] - dlIVX, Sat->VY[0] - dlIVY, Sat->VZ[0] - dlIVZ);
            //if (m < m0)
            {
                if (Rn[iCmin] > measures[m].Err) // intermedian measurement did not match error needs to repeat steps
                {
                    printf("\n M0= %d m=%d erro is bigger %.12f=> repeat match ",m0, m,Rn[iCmin]);
                    nextm=1;
                    goto DO_MATHC_AGAIN;
                }
            }
NEXT_MEASURE:;
            printf("\ngood  X=%.12f,%.12f,%.12f,V=%.12f,%.12f,%.12f", Sat->X[0] - dlIX, Sat->Y[0] - dlIY, Sat->Z[0] - dlIZ, Sat->VX[0] - dlIVX, Sat->VY[0] - dlIVY, Sat->VZ[0] - dlIVZ);
        }
    }
    printf("\nfinal  X=%.12f,%.12f,%.12f,V=%.12f,%.12f,%.12f", Sat->X[0] - dlIX, Sat->Y[0] - dlIY, Sat->Z[0] - dlIZ, Sat->VX[0] - dlIVX, Sat->VY[0] - dlIVY, Sat->VZ[0] - dlIVZ);
    
}
void RunSim(TRAOBJ *SlS, TRAOBJ *Sat,TRAIMPLOBJ *Eng, long double ldFrom,long double ldFromTLEEpoch, long long iAllSec, int iItPerS, long double tSl)
{
    int iCheck = 0;
    long double AE = 1.0;
#if _USE_ORIGINAL
    long double XKMPER = 6378.1350;//XKMPER kilometers/Earth radii 6378.135
#else
    long double XKMPER = 6378.137;
#endif
	//long double XKE = BIG_XKE;//.743669161E-1;
    //long double XJ2 = 1.082616E-3;
    //long double CK2=.5*XJ2*AE*AE;
    long double XMNPDA = 1440.0; // XMNPDA time units(minutes) /day 1440.0
    long double TEMP=2*M_PI/XMNPDA/XMNPDA; // 2*pi / (1440 **2)
    long double ProbMeanMotion = Sat->ProbMeanMotion[iCheck];
    long double XNO=ProbMeanMotion*TEMP*XMNPDA; // rotation per day * 2*pi /1440 == rotation per day on 1 unit (1 min)
    long double XNDT2O=Sat->ProbFirstDervMeanMotion[iCheck]*TEMP;
    long double XNDD6O=Sat->ProbSecondDervmeanMotion[iCheck]*TEMP/XMNPDA;
    long double BSTAR=Sat->ProbDragterm[iCheck]/AE;
    long double tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ;
    int i,j,k;
    stateType  StateBS;
    stateType  StateMoon;
    double dEMRAT = Find_DataInHeader("EMRAT ");
    double dAU = Find_DataInHeader("AU    ")*1000.0;
    double BSX;
    double BSY;
    double BSZ;
    long double Lat;
    long double Long;
    long double Height;
    long double PosX;
    long double PosY;
    long double PosZ;
    SYSTEMTIME ThatTime;
    long double dTLEtime;


    FILE *FileOut = fopen(SimulationTempOutputFile,"w");
    if (FileOut)
    {
        if (memcmp(SimulationType,"TLE",3) == 0)
        {
            for (i = 0; i < SimulationOutputCount; i++)
            {
                if (memcmp(UseSatData, "SGP",3)==0) 
                {
                    if (memcmp(UseSatData, "SGP4",4)==0)
                    {
			            SGP4((SimulationOutputTime[i] - Sat->ProbJD[iCheck])*XMNPDA, 
                            XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				            tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                    }
                    else if (memcmp(UseSatData, "SGP8",4)==0)
                    {
			            SGP8((SimulationOutputTime[i] - Sat->ProbJD[iCheck])*XMNPDA, 
                            XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				            tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                    }
                    else if  (memcmp(UseSatData, "SGP",3)==0)
                    {
			            SGP((SimulationOutputTime[i] - Sat->ProbJD[iCheck])*XMNPDA, 
                            XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                    }
                    tProbX=tProbX*XKMPER/AE*1000.0;                 tProbY=tProbY*XKMPER/AE*1000.0;                 tProbZ=tProbZ*XKMPER/AE*1000.0;
			        tProbVX=tProbVX*XKMPER/AE*XMNPDA/86400.*1000.0;	tProbVY=tProbVY*XKMPER/AE*XMNPDA/86400.*1000.0;	tProbVZ=tProbVZ*XKMPER/AE*XMNPDA/86400.*1000.0;
                }
                else    
                {
                    KeplerPosition(Sat->ProbJD[iCheck],SimulationOutputTime[i],      // prob epoch, and curent time
	    			    Sat->ProbTSec[iCheck], Sat->ProbEcc[iCheck], Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],  Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck], BSTAR,
                        Gbig *SolarSystem.M[EARTH],1, tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ, Sat->ProbMeanMotion[iCheck]);

                }

                if (strcmp(SimulationType,"TLE_G_CRS")==0) // it was request to generate position data with reference to geocentric CRS 
                {
                    fprintf(FileOut,"\n\t<gCRSmeasure>");
                    fprintf(FileOut,"\n\t <M>%d</M>",EARTH);
                    fprintf(FileOut,"\n\t\t<T>%.11f</T>\n\t\t<X>%.5f</X>\n\t\t<Y>%.5f</Y>\n\t\t<Z>%.5f</Z>", SimulationOutputTime[i],tProbX, tProbY, tProbZ);
                    fprintf(FileOut,"\n\t\t<E>1000</E>\n\t\t<D1>0.0</D1>\n\t\t<E1>0.0</E1>\n\t\t<T2>0.0</T2>\n\t\t<E2>0.0</E2>");
                    fprintf(FileOut,"\n\t</gCRSmeasure>");

                }
                else if (strcmp(SimulationType,"TLE_G_TRS")==0) // it was request to generate position data with reference to geocentric TRS 
                {
#if 1
                    printf("\n TBD");
#else
                    SYSTEMTIME ThatTime;
                    long double dSimTLEEpoch = ConvertJulianDayToDateAndTime(SimulationOutputTime[i], &ThatTime);
                    Sat->Lambda = GreenwichAscensionFromTLEEpoch(dSimTLEEpoch,Sat->precEps,Sat->precTet,Sat->precZ,Sat->nutEpsilon,Sat->nutDFeta);
                    Sat->gcrs_2_trs(tProbX, tProbY, tProbZ);
                    long double dlLAT, dlLON;
                    // LON == negative it is east; positive is west
                    long double H = Sat->GetH(tProbX, tProbY, tProbZ, 6378245.000, 6356863.019,dlLAT, dlLON);

                    fprintf(FileOut,"\n\t<gTRSmeasure>");
                    fprintf(FileOut,"\n\t <M>%d</M>",EARTH);
                    fprintf(FileOut,"\n\t\t<T>%.11f</T>\n\t\t<X>%.5f</X>\n\t\t<Y>%.5f</Y>\n\t\t<Z>%.5f</Z>", SimulationOutputTime[i],tProbX, tProbY, tProbZ);
                    fprintf(FileOut,"\n\t\t<H>%.5f</H>\n\t\t<LAT>%.11f</LAT>\n\t\t<LON>%.11f</LON>", H,dlLAT, dlLON);
                    fprintf(FileOut,"\n\t\t<E>1000</E>\n\t\t<D1>0.0</D1>\n\t\t<E1>0.0</E1>\n\t\t<T2>0.0</T2>\n\t\t<E2>0.0</E2>");
                    fprintf(FileOut,"\n\t</gTRSmeasure>");
#endif
                }
                else if (strcmp(SimulationType,"TLE_H_CRS")==0) // it was request to generate position data with reference to solar system CRS
                {

                    Interpolate_State( SimulationOutputTime[i], EARTH , &StateBS );
                    Interpolate_State( SimulationOutputTime[i], MOON , &StateMoon );

                    BSX = StateBS.Position[0]*1000.0 ;
                    BSY = StateBS.Position[1]*1000.0 ;
                    BSZ = StateBS.Position[2]*1000.0 ;
                    SlS->X[EARTH] = BSX - (StateMoon.Position[0]*1000.0/(dEMRAT+1));
                    SlS->Y[EARTH] = BSY - (StateMoon.Position[1]*1000.0/(dEMRAT+1));
                    SlS->Z[EARTH] = BSZ - (StateMoon.Position[2]*1000.0/(dEMRAT+1));
                    fprintf(FileOut,"\n\t<hCRSmeasure>");
                    fprintf(FileOut,"\n\t <M>-1</M>");
                    fprintf(FileOut,"\n\t\t<T>%.11f</T>\n\t\t<X>%.5f</X>\n\t\t<Y>%.5f</Y>\n\t\t<Z>%.5f</Z>", SimulationOutputTime[i],tProbX+SlS->X[EARTH], tProbY+SlS->Y[EARTH], tProbZ+SlS->Z[EARTH]);
                    fprintf(FileOut,"\n\t\t<E>1000</E>\n\t\t<D1>0.0</D1>\n\t\t<E1>0.0</E1>\n\t\t<T2>0.0</T2>\n\t\t<E2>0.0</E2>");
                    fprintf(FileOut,"\n\t</hCRSmeasure>");
                }
            }
        }
        else if (memcmp(SimulationType,"PING", 4) ==0) // simulate ping messages from ground station to satellite (at spesific time from all ground stations)
        {

        }
        else if (memcmp(SimulationType,"GPS",3) ==0) // simulate GPS's raw data from GPS satellites at specific time from GPS satellites
        {

        }
        else if (memcmp(SimulationType,"PULSAR",6) ==0) //simulate PULSAR receving signal from all pulsars at specific time
        {
            for (i = 0; i < SimulationOutputCount; i++)
            {
                for (j = 0; j <iSimTotalLocations; j++)
                {
                    //(SimNAME[iSimTotalLocations], pszQuo);
                    //SimLat[iSimTotalLocations]=  atof(pszQuo);
                    //SimLong[iSimTotalLocations]=  atof(pszQuo);
                    //SimH[iSimTotalLocations++]=  atof(pszQuo);
                    
                    Interpolate_State( SimulationOutputTime[i], EARTH , &StateBS );
                    Interpolate_State( SimulationOutputTime[i], MOON , &StateMoon );
                    BSX = StateBS.Position[0]*1000.0 ;
                    BSY = StateBS.Position[1]*1000.0 ;
                    BSZ = StateBS.Position[2]*1000.0 ;
                    SlS->X[EARTH] = BSX - (StateMoon.Position[0]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                    SlS->Y[EARTH] = BSY - (StateMoon.Position[1]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                    SlS->Z[EARTH] = BSZ - (StateMoon.Position[2]*1000.0/(dEMRAT+1));//*SlS->M[MOON]/(SlS->M[EARTH]+SlS->M[MOON]));
                    SlS->X[MOON] = BSX + StateMoon.Position[0]*1000.0;
                    SlS->Y[MOON] = BSY + StateMoon.Position[1]*1000.0;
                    SlS->Z[MOON] = BSZ + StateMoon.Position[2]*1000.0;
                    if ((memcmp(SimNAME[j], "EARTH",5)==0) || (memcmp(SimNAME[j], "MOON",4)==0))
                    {
                        long double AXBig   = 6378245.000;
                        long double AXSmall = 6356863.019;
                        long double ErrorTime = 1.0;
                        long double X_ME;
                        long double Y_ME;
                        long double XY_ME;
                        int iEM = EARTH;
                        
                        if (i == 0) // that is the initial error
                        {
                            ErrorTime = 1.0;
                        }
                        else
                        {
                            ErrorTime = 1.0 + fabs((SimulationOutputTime[i] - SimulationOutputTime[0])/60.0); // 1 sec error in 60 days == crystal 32Mhz precision
                        }
                        
                        Lat = SimLat[j];
                        Long = SimLong[j];
                        Height = SimH[j];
                        if (memcmp(SimNAME[j], "EARTH",5)==0)
                        {
                            AXBig   = 6378245.000;
                            AXSmall = 6356863.019;
                            dTLEtime = ConvertJulianDayToDateAndTime(SimulationOutputTime[i], &ThatTime);
                            SlS->LatLongToCRS(Long,Lat,Height, AXBig, AXSmall, dTLEtime, PosX,PosY,PosZ);
                            iEM = EARTH;
                        }
                        else
                        {
                            AXBig = 1738140.0;
                            AXSmall = 1735970.0;
                            SlS->LatLongToTRS(Long,Lat,Height, AXBig, AXSmall, PosX, PosY, PosZ);
                            // moon is lookin by 0 meridian to the earth
                            X_ME = SlS->X[MOON] - SlS->X[EARTH];
                            Y_ME = SlS->Y[MOON] - SlS->Y[EARTH];
                            XY_ME = sqrt(X_ME*X_ME + Y_ME*Y_ME);
                            
                            X_ME /= XY_ME; Y_ME /= XY_ME;
                            if ((X_ME > 0) && (Y_ME > 0))
                                SlS->Lambda = asin(Y_ME);
                            else if ((X_ME <= 0) && (Y_ME > 0))
                                SlS->Lambda = M_PI - asin(Y_ME);
                            else if ((X_ME <= 0) && (Y_ME <= 0))
                                SlS->Lambda = M_PI - asin(Y_ME);
                            else
                                SlS->Lambda = 2*M_PI + asin(Y_ME);
                            SlS->precEps=0; SlS->precTet = 0; SlS->precZ = 0; SlS->nutEpsilon = 0; SlS->nutDFeta = 0;
                            SlS->calc_tr_matrix();
                            SlS->trs_2_gcrs(PosX, PosY, PosZ);
                            iEM = MOON;
                        }
                        
                        long double Dnorm = sqrt(PosX*PosX + PosY*PosY + PosZ*PosZ);
                        long double Xnorm = PosX / Dnorm;
                        long double Ynorm = PosY / Dnorm;
                        long double Znorm = PosZ / Dnorm;

                        for (k =0; k < nPulsars; k++)
                        {
                            long double Xpulsar, Ypulsar, Zpulsar;
                            SlS->LatLongToTRS(Pulsars[k].ELONG,Pulsars[k].ELAT,0.0, 1.0, 1.0, Xpulsar,Ypulsar,Zpulsar);
                            long double AngleFromNormal = AngleBtwNorm(Xnorm,Ynorm,Znorm,Xpulsar,Ypulsar,Zpulsar) * 180/ M_PI;
                            if (fabs(AngleFromNormal) < 45.0)
                            {
                                // now needs to find the point for the time
                                long double tperiod = Pulsars[k].P0;
                                long double stepP = 0.001;
                                long double AngleFromNormal2;
                                long double realD;
                                long double dTLEtime2;
                                long double PosX2,PosY2,PosZ2, norm2;
                                long double realT = 0;
                                long double RealT[3];
                                long double DIfEX;
                                long double DifEY;
                                long double DifEZ;
                                for (int n = 0; n < 3; n++)
                                {
                                    tperiod = (n+1)*Pulsars[k].P0;
                                    BOOL directionPlus = TRUE;
                                    stepP = 0.001;
                                    realT = 0;
                                    while(fabs(realT - (n+1)*Pulsars[k].P0) > 1.0e-12)
                                    {
                                        dTLEtime2 = ConvertJulianDayToDateAndTime(SimulationOutputTime[i]+tperiod/(24.0*60.0*60.0), &ThatTime);
                                        if (iEM == EARTH)
                                        {
                                            SlS->LatLongToCRS(Long,Lat,Height, AXBig, AXSmall, dTLEtime2, PosX2,PosY2,PosZ2);
                                        }
                                        else
                                        {
                                            SlS->LatLongToTRS(Long,Lat,Height, AXBig, AXSmall, PosX2, PosY2, PosZ2);
                                            // moon is lookin by 0 meridian to the earth
                                            X_ME = SlS->X[MOON] - SlS->X[EARTH];
                                            Y_ME = SlS->Y[MOON] - SlS->Y[EARTH];
                                            XY_ME = sqrt(X_ME*X_ME + Y_ME*Y_ME);
                            
                                            X_ME /= XY_ME; Y_ME /= XY_ME;
                                            if ((X_ME > 0) && (Y_ME > 0))
                                                SlS->Lambda = asin(Y_ME);
                                            else if ((X_ME <= 0) && (Y_ME > 0))
                                                SlS->Lambda = M_PI - asin(Y_ME);
                                            else if ((X_ME <= 0) && (Y_ME <= 0))
                                                SlS->Lambda = M_PI - asin(Y_ME);
                                            else
                                                SlS->Lambda = 2*M_PI + asin(Y_ME);
                                            SlS->precEps=0; SlS->precTet = 0; SlS->precZ = 0; SlS->nutEpsilon = 0; SlS->nutDFeta = 0;
                                            SlS->calc_tr_matrix();
                                            SlS->trs_2_gcrs(PosX, PosY, PosZ);
                                            iEM = MOON;
                                        }
                                        Interpolate_State( SimulationOutputTime[i]+tperiod/(24.0*60.0*60.0), EARTH , &StateBS );
                                        Interpolate_State( SimulationOutputTime[i]+tperiod/(24.0*60.0*60.0), MOON , &StateMoon );
                                        BSX = StateBS.Position[0]*1000.0 ;
                                        BSY = StateBS.Position[1]*1000.0 ;
                                        BSZ = StateBS.Position[2]*1000.0 ;
                                        if (iEM == EARTH)
                                        {
                                            DIfEX = BSX - (StateMoon.Position[0]*1000.0/(dEMRAT+1)) - SlS->X[iEM];
                                            DifEY = BSY - (StateMoon.Position[1]*1000.0/(dEMRAT+1)) - SlS->Y[iEM];
                                            DifEZ = BSZ - (StateMoon.Position[2]*1000.0/(dEMRAT+1)) - SlS->Z[iEM];
                                        }
                                        else
                                        {
                                            DIfEX = BSX + StateMoon.Position[0]*1000.0 - SlS->X[iEM];
                                            DifEY = BSY + StateMoon.Position[1]*1000.0 - SlS->Y[iEM];
                                            DifEZ = BSZ + StateMoon.Position[2]*1000.0 - SlS->Z[iEM];
                                        }

                                        // vector from XYZ2 to XYZ
                                        PosX2 = PosX -(PosX2+DIfEX); PosY2 = PosY -(PosY2+DifEY); PosZ2 = PosZ -(PosZ2+DifEZ);
                                        norm2 = sqrt(PosX2*PosX2 +PosY2*PosY2 +PosZ2*PosZ2);
                                        PosX2 = PosX2/norm2; PosY2 = PosY2/norm2; PosZ2 = PosZ2/norm2;
                                        AngleFromNormal2 = AngleBtwNorm(PosX2,PosZ2,PosZ2,Xpulsar,Ypulsar,Zpulsar);
                                        realD = norm2*cos(AngleFromNormal2);
                                        realT = tperiod+ realD/299792458.0;
                                        if (realT < (n+1)*Pulsars[k].P0)
                                        {
                                            if (directionPlus)
                                                ;
                                            else
                                            {
                                                directionPlus = TRUE;
                                                stepP = - stepP/2;
                                            }
                                        }
                                        else
                                        {
                                            if (directionPlus)
                                            {
                                                directionPlus = FALSE;
                                                stepP = - stepP/2;
                                            }
                                            else
                                                ;
                                        }
                                        tperiod +=stepP;
                                    }
                                    RealT[n] = realT;
                                }


                                fprintf(FileOut,"\n\t<hPULSARmeasure>");
                                fprintf(FileOut,"\n\t <M>%d</M>",iEM); // for earth
                                
                                fprintf(FileOut,"\n\t\t<T>%+25.17Le</T>\n\t\t<P1>%+25.17Le</P1>\n\t\t<P2>%+25.17Le</P2>\n\t\t<P3>%+25.17Le</P3>", SimulationOutputTime[i],RealT[0],RealT[1]-RealT[0], RealT[2]-RealT[1]);
                                fprintf(FileOut,"\n\t <E>%+25.17Le</E>",ErrorTime); // for earth
                                fprintf(FileOut,"\n\t</hPULSARmeasure>");
                            }
                        }
                    }
                    else if (memcmp(SimNAME[j], "MOON",4)==0)
                    {
                    }
                    else if (memcmp(SimNAME[j], "ORBIT",5)==0)
                    {
                        if (memcmp(UseSatData, "SGP",3)==0) 
                        {
                            if (memcmp(UseSatData, "SGP4",4)==0)
                            {
			                    SGP4((SimulationOutputTime[i] - Sat->ProbJD[iCheck])*XMNPDA, 
                                    XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				                    tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                            }
                            else if (memcmp(UseSatData, "SGP8",4)==0)
                            {
			                    SGP8((SimulationOutputTime[i] - Sat->ProbJD[iCheck])*XMNPDA, 
                                    XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
	        			            tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                            }
                            else if  (memcmp(UseSatData, "SGP",3)==0)
                            {
			                    SGP((SimulationOutputTime[i] - Sat->ProbJD[iCheck])*XMNPDA, 
                                    XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				                    tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                            }
                            tProbX=tProbX*XKMPER/AE*1000.0;                 tProbY=tProbY*XKMPER/AE*1000.0;                 tProbZ=tProbZ*XKMPER/AE*1000.0;
			                tProbVX=tProbVX*XKMPER/AE*XMNPDA/86400.*1000.0;	tProbVY=tProbVY*XKMPER/AE*XMNPDA/86400.*1000.0;	tProbVZ=tProbVZ*XKMPER/AE*XMNPDA/86400.*1000.0;
                        }
                        else    
                        {
                            KeplerPosition(Sat->ProbJD[iCheck],SimulationOutputTime[i],      // prob epoch, and curent time
	    			            Sat->ProbTSec[iCheck], Sat->ProbEcc[iCheck], Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],  Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck], BSTAR,
                            Gbig *SolarSystem.M[EARTH],1, tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ, Sat->ProbMeanMotion[iCheck]);
                        }
                    }
                }
            }
        }
        fclose(FileOut);
        FileOut = NULL;
        if (UrlTraSimPort!= 0) // yes! it is ugly - that is a case when visualization output must to be submit to some server
        {
            PostXMLToServer(szURLServerSimulationOutputFile, UrlTraSimPort, szURLTraSimFileName, szTraSimFileName);
        }
    }
}
void PrintPV(TRAOBJ *SlS, TRAOBJ *Sat, int iCheck, long double ldFrom, long double Time_SecondsFromStart)
{
            long iSec = Time_SecondsFromStart;
            long double AE = 1.0;
#if _USE_ORIGINAL
            long double XKMPER = 6378.1350;//XKMPER kilometers/Earth radii 6378.135
#else
            long double XKMPER = 6378.137;
#endif
		    //long double XKE = BIG_XKE;//.743669161E-1;

            //long double XJ2 = 1.082616E-3;
            //long double CK2=.5*XJ2*AE*AE;

            long double XMNPDA = 1440.0; // XMNPDA time units(minutes) /day 1440.0
            long double TEMP=2*M_PI/XMNPDA/XMNPDA; // 2*pi / (1440 **2)
            long double ProbMeanMotion = Sat->ProbMeanMotion[iCheck];
            long double XNO=ProbMeanMotion*TEMP*XMNPDA; // rotation per day * 2*pi /1440 == rotation per day on 1 unit (1 min)
            long double XNDT2O=Sat->ProbFirstDervMeanMotion[iCheck]*TEMP;
            long double XNDD6O=Sat->ProbSecondDervmeanMotion[iCheck]*TEMP/XMNPDA;
            long double BSTAR=Sat->ProbDragterm[iCheck]/AE;
            long double tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ;
            // next lines has to be removed ==> today they are included only to avoid drag effect

            //long double TimeFromEpochOfSatInDays = fmod(Sat.ProbEpochOnStart[iCheck] + Time_SecondsFromStart/24.0/60.0/60.0, 1.0/Sat.ProbMeanMotion[iCheck]);
            // first parameter in in minutes from epoch
            if (memcmp(UseSatData, "SGP",3)==0) 
            {
                if (memcmp(UseSatData, "SGP4",4)==0)
                {
			        SGP4((ldFrom - Sat->ProbJD[iCheck]+Time_SecondsFromStart/24.0/60.0/60.0)*XMNPDA, 
                        XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                }
                else if (memcmp(UseSatData, "SGP8",4)==0)
                {
    			    SGP8((ldFrom - Sat->ProbJD[iCheck]+Time_SecondsFromStart/24.0/60.0/60.0)*XMNPDA, 
                        XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
				        tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                }
                else if  (memcmp(UseSatData, "SGP",3)==0)
                {
			        SGP((ldFrom - Sat->ProbJD[iCheck]+Time_SecondsFromStart/24.0/60.0/60.0)*XMNPDA, 
                        XNDT2O,XNDD6O,BSTAR,Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],Sat->ProbEcc[iCheck], Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck],XNO, 
	    			    tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ);
                }
                tProbX=tProbX*XKMPER/AE*1000.0;                 tProbY=tProbY*XKMPER/AE*1000.0;                 tProbZ=tProbZ*XKMPER/AE*1000.0;
			    tProbVX=tProbVX*XKMPER/AE*XMNPDA/86400.*1000.0;	tProbVY=tProbVY*XKMPER/AE*XMNPDA/86400.*1000.0;	tProbVZ=tProbVZ*XKMPER/AE*XMNPDA/86400.*1000.0;
            }
            else
            {
                KeplerPosition(Sat->ProbJD[iCheck],ldFrom+Time_SecondsFromStart/24.0/60.0/60.0,      // prob epoch, and curent time
	    			    Sat->ProbTSec[iCheck], Sat->ProbEcc[iCheck], Sat->ProbIncl[iCheck], Sat->ProbAscNode[iCheck],  Sat->ProbArgPer[iCheck], Sat->ProbMeanAnom[iCheck], BSTAR,
                        Gbig *SolarSystem.M[EARTH],1, tProbX,tProbY,tProbZ,tProbVX,tProbVY,tProbVZ, Sat->ProbMeanMotion[iCheck]);
            }
            long double tX, tY, tZ, tVX, tVY, tVZ;
            tX = Sat->X[iCheck] - SlS->X[EARTH];      tY = Sat->Y[iCheck] - SlS->Y[EARTH];      tZ = Sat->Z[iCheck] - SlS->Z[EARTH];
		    tVX = Sat->VX[iCheck] - SlS->VX[EARTH];   tVY = Sat->VY[iCheck] - SlS->VY[EARTH];   tVZ = Sat->VZ[iCheck] - SlS->VZ[EARTH];
            long double ttProbX, ttProbY, ttProbZ, ttProbVX, ttProbVY, ttProbVZ;
            ttProbX	= tX - tProbX;ttProbY= tY - tProbY; ttProbZ	= tZ - tProbZ;
            ttProbVX = tVX - tProbVX; ttProbVY = tVY - tProbVY; ttProbVZ = tVZ - tProbVZ;
            long double tttX, tttVX;
            tttX = sqrt(ttProbX*ttProbX + ttProbY*ttProbY + ttProbZ*ttProbZ);
            tttVX = sqrt(ttProbVX*ttProbVX + ttProbVY*ttProbVY + ttProbVZ*ttProbVZ);
            double errorCos = (tVX*tProbVX + tVY*tProbVY + tVZ*tProbVZ)/ (sqrt(tVX*tVX +tVY*tVY + tVZ*tVZ)* sqrt(tProbVX*tProbVX + tProbVY*tProbVY + tProbVZ*tProbVZ));
            //double errAngle =  acos(errorCos);
            double errorD = sqrt(tVX*tVX + tVY*tVY + tVZ*tVZ)/sqrt(tProbVX*tProbVX + tProbVY*tProbVY + tProbVZ*tProbVZ);
            double SinAngle = tZ / sqrt(tX*tX + tY*tY + tZ*tZ);
            double SinAngle2 = tX / sqrt(tX*tX + tY*tY);

            double ErrorDD = sqrt(tVX*tVX + tVY*tVY + tVZ*tVZ) - sqrt(tProbVX*tProbVX + tProbVY*tProbVY + tProbVZ*tProbVZ);
            //  printf("\n%f err(X=%f V=%f pr=%f lv=%f) min=%d ",(asin(SinAngle)*180/M_PI),tttX,tttVX, errorD, ErrorDD,iCurSec/60);
            printf("\n%8.4f %8.4f X=%13.5f,%13.5f,%13.5f V=%13.5f,%13.5f,%13.5f e= %f %f  %d",(asin(SinAngle)*180/M_PI),(asin(SinAngle2)*180/M_PI),
            tProbX - tX, tProbY - tY, tProbZ - tZ,
            tProbVX - tVX,tProbVY - tVY,tProbVZ - tVZ,
            tttX,tttVX,iSec/60);

}
void RunProp(TRAOBJ *SlS, TRAOBJ *Sat,TRAIMPLOBJ *Eng, long double ldFrom,long double ldFromTLEEpoch, long long iAllSec, int iItPerS, long double tSl)
{
    SlS->TimeSl = tSl;
    SlS->TimeSl_2 = tSl*tSl;
    long long iSec;
    int iPortionSec;
    int StartSequence = 0;
    int iDay =0;
    long double MinMaxX = .0;
    long double MinMaxY = .0;
    long double MinMaxZ = .0;
    int flFindFirst1KmError = 1;
    stateType  StateEarth;
    stateType  StateMoon;
    double dErrorValue = 10.0; // 1km error == 1km*1km
    long double Time_SecondsFromStart=0;
    int iDistance =0;
    int Apogee = 0;
    int Perigee = 10000000;
    int ApPerStatus = 0; // search for apogee
    int iCountDelay= 0;
	
    for (iSec = 0; iSec < iAllSec; iSec++)
    {
        for (iPortionSec = 0; iPortionSec < iItPerS; iPortionSec++)
        {
            if (JustFlySimulation == 0)
            {
                if (RunOrVoidEngine(1, Eng, SlS, Sat, iSec, iPortionSec, iItPerS, ldFrom))
                {
                        // engine is running
                }
                else
                {
                }
            }
            IteraSat(1, SlS, Sat,ldFromTLEEpoch + (iSec +   (long double)iPortionSec/(long double)iItPerS) /86400.0) ;
            IteraSolarSystem(TRUE, SlS);

            EarthX = SlS->X[EARTH];     EarthY = SlS->Y[EARTH];       EarthZ = SlS->Z[EARTH];
            MoonX = SlS->X[MOON];       MoonY = SlS->Y[MOON];         MoonZ = SlS->Z[MOON];
            if (Sat->h[0] < 0)
            {
                //printf("\n Landed on Earth at sec = %d", iCurSec);
                Sat->flInUse[0] = 0;
            }
            if (iDistance != (int)Sat->Distance[0][EARTH])
            {
                iDistance = (int)Sat->Distance[0][EARTH];
                Sat->iAtm[0] = 1;

            }
            if (ApPerStatus == 0)
            {
                if (Apogee <= (int)Sat->Distance[0][EARTH])
                    Apogee = Sat->Distance[0][EARTH];
                else
                {
                    ApPerStatus = 1; // delay
                    iCountDelay = 100;
                    Time_SecondsFromStart = (iSec +   (long double)(iPortionSec+1)/(long double)iItPerS);
                    PrintPV(SlS, Sat, 0, ldFrom, Time_SecondsFromStart);
                }

            } else if (ApPerStatus == 1)
            {
                if (--iCountDelay == 0)
                {
                    ApPerStatus = 2; // search for perigee
                    Perigee = 1000000000;
                }
            } else if (ApPerStatus == 2)
            {
                if (Perigee >= (int)Sat->Distance[0][EARTH])
                    Perigee = Sat->Distance[0][EARTH];
                else
                {
                    ApPerStatus = 3; // delay
                    iCountDelay = 100;
                }
            } else if (ApPerStatus == 3)
            {
                if (--iCountDelay == 0)
                {
                    ApPerStatus = 0; // search for apogee
                    Apogee  = 0;
                }
            }

            /*if (Apogee <= (int)Sat->Distance[0][EARTH])
            {
                Apogee = Sat->Distance[0][EARTH];
                wasPlus = 1;
            }
            else
            {
                if (wasPlus == 1) // was apogee
                {
                    Time_SecondsFromStart = (iSec +   (long double)(iPortionSec+1)/(long double)iItPerS);
                    PrintPV(SlS, Sat, 0, ldFrom, Time_SecondsFromStart);
                }
                wasPlus = 0;
                Apogee = 0;
            }*/


            double ProbX = Sat->X[0]; double ProbY = Sat->Y[0];      double ProbZ = Sat->Z[0];
            long double dRM, dRM0,dREMV;
            {
                dRM = sqrt( (ProbX - MoonX)*(ProbX - MoonX)+ (ProbY - MoonY)*(ProbY - MoonY)+ (ProbZ - MoonZ)*(ProbZ - MoonZ) );
                dRM0 = dRM;

                if (dRM < MoonR) // TBD Moon is not round!!!
                {
                    double LongOnMoon = 0.0; // dolgota
                    double LatiOnMoon = 0.0; // shirota
                    double PosXMoon = 0;
                    double PosYMoon = 0;
                    double PosZMoon = 0;
                    getLongLatiMoon(LongOnMoon,LatiOnMoon,SlS,MOON,EARTH,Sat,0);
                    getXYZMoon(LongOnMoon,LatiOnMoon,PosXMoon,PosYMoon,PosZMoon,SlS,MOON,EARTH,dRM);
                    dREMV = sqrt((SlS->VX[MOON]-Sat->VX[0])*(SlS->VX[MOON]-Sat->VX[0])+(SlS->VY[MOON]-Sat->VY[0])*(SlS->VY[MOON]-Sat->VY[0])+(SlS->VZ[MOON]-Sat->VZ[0])*(SlS->VZ[MOON]-Sat->VZ[0]));
                    printf("\n Landed on Moon at sec = %f x=%f Y=%f z=%f V=%f", 
                            ((double)iSec) + SlS->TimeSl*((double)iPortionSec), Sat->X[0] -SolarSystem.X[MOON], Sat->Y[0] -SolarSystem.Y[MOON], Sat->Z[0] -SolarSystem.Z[MOON],dREMV);
                    printf("\n Longitute = %f Latitute %f", LongOnMoon, LatiOnMoon);
                    //printf("\n Landed weight = %f from initial = %f (%f percent)", Sat->M[0], MyTrySat.M[0],Sat->M[0]/MyTrySat.M[0]);
#ifdef _DO_VISUALIZATION
                    // store last image 
                    //DrawAnimationSequence(&SolarSystem,&Sat, i,"TRA",&SolarSystem, RGBReferenceBody, dRGBScale, StartSequence, 1);
                    DrawFinalBody(SlS, MOON, Sat, iSec,"TRA", SlS, RGBReferenceBody, dRGBScale, StartSequence);
#endif
                    //dumpXMLParam(&MyTrySat, &Engine[0],EnginesCount);
                    Sat->flInUse[0] = 0;
                    exit(0);
                }
            }
        }

        // this is 1 day position 
        if (iSec%(60*60*24) ==0)
        {
            iDay++;
            printf("\nd=%d x=%f y=%f z=%f \tMx=%f y=%f z= %f", iDay, MinMaxX, MinMaxY, MinMaxZ, 
                        SlS->X[MOON] - SlS->X[EARTH], SlS->Y[MOON] - SlS->Y[EARTH], SlS->Z[MOON] - SlS->X[EARTH]);
        }
        // this flag switch on/off comparation of calculated data against JPL 410
        if (flFindFirst1KmError)
        {
            Interpolate_State( ldFrom+((double)(iSec+1))/(24.0*60.0*60.0) , EARTH , &StateEarth );
            Interpolate_State( ldFrom+((double)(iSec+1))/(24.0*60.0*60.0) , MOON , &StateMoon );
            MoonX = SolarSystem.X[MOON];    MoonY = SolarSystem.Y[MOON];    MoonZ = SolarSystem.Z[MOON];

            EarthX = SolarSystem.X[EARTH];  EarthY = SolarSystem.Y[EARTH];  EarthZ = SolarSystem.Z[EARTH];
#ifdef  TEST_RUN_EARTH_ERROR
            // this error checks position of earth-moon
            // barycentre against JPL
            double EarthBSX = (EarthX*SlS->M[EARTH] + MoonX*SlS->M[MOON])/(SlS->M[EARTH]+SlS->M[MOON]);
            double EarthBSY = (EarthY*SlS->M[EARTH] + MoonY*SlS->M[MOON])/(SlS->M[EARTH]+SlS->M[MOON]);
            double EarthBSZ = (EarthZ*SlS->M[EARTH] + MoonZ*SlS->M[MOON])/(SlS->M[EARTH]+SlS->M[MOON]);

            double EarthBSNX =  StateEarth.Position[0]*1000.0 ;
            double EarthBSNY =  StateEarth.Position[1]*1000.0 ;
            double EarthBSNZ =  StateEarth.Position[2]*1000.0 ;

#else
            // otherwise it will be Moon position
            double EarthBSX = ( MoonX - EarthX); 
            double EarthBSY = ( MoonY - EarthY);
            double EarthBSZ = ( MoonZ - EarthZ);

            double EarthBSNX =  StateMoon.Position[0]*1000.0 ;
            double EarthBSNY =  StateMoon.Position[1]*1000.0 ;
            double EarthBSNZ =  StateMoon.Position[2]*1000.0 ;

#endif
            double tDeltaEarthJPL = (( EarthBSX - EarthBSNX)*( EarthBSX - EarthBSNX) +
                                     ( EarthBSY - EarthBSNY)*( EarthBSY - EarthBSNY) +
                                     ( EarthBSZ - EarthBSNZ)*( EarthBSZ - EarthBSNZ)
                                    );
            if (tDeltaEarthJPL> dErrorValue)
            {
                // error bigger then 1000 M
                double flX;
                double flY;
                double flZ;
                MoonVX = SlS->VX_[MOON]*SlS->TimeSl / SlS->M[MOON];
                MoonVY = SlS->VY_[MOON]*SlS->TimeSl / SlS->M[MOON];
                MoonVZ = SlS->VZ_[MOON]*SlS->TimeSl / SlS->M[MOON];

                EarthVX = SlS->VX_[EARTH]*SlS->TimeSl / SlS->M[EARTH];
                EarthVY = SlS->VY_[EARTH]*SlS->TimeSl / SlS->M[EARTH];
                EarthVZ = SlS->VZ_[EARTH]*SlS->TimeSl / SlS->M[EARTH];
#ifdef TEST_RUN_EARTH_ERROR
                double EarthBSVX = EarthVX;
                double EarthBSVY = EarthVY;
                double EarthBSVZ = EarthVZ;
                double EarthBSNVX =  StateEarth.Velocity[0]*1000.0 ;
                double EarthBSNVY =  StateEarth.Velocity[1]*1000.0 ;
                double EarthBSNVZ =  StateEarth.Velocity[2]*1000.0 ;
                printf("\n Error in Earth position bigger then %f M", sqrt(tDeltaEarthJPL));
#else
                double EarthBSVX = ( MoonVX - EarthVX);
                double EarthBSVY = ( MoonVY - EarthVY);
                double EarthBSVZ = ( MoonVZ - EarthVZ);
                double EarthBSNVX =  StateMoon.Velocity[0]*1000.0 ;
                double EarthBSNVY =  StateMoon.Velocity[1]*1000.0 ;
                double EarthBSNVZ =  StateMoon.Velocity[2]*1000.0 ;
                printf("\n Error in Moon position bigger then %f M", sqrt(dErrorValue));
#endif
                dErrorValue*=2.0;
                printf("\n=%f \nx=%f y=%f z=%f ; JPL EPHEMERIDES:\nx=%f y=%f z=%f %ld sec + %f - %f sec ", 
                                    sqrt(tDeltaEarthJPL), EarthBSX, EarthBSY, EarthBSZ, EarthBSNX, EarthBSNY, EarthBSNZ,
                                    iSec, SlS->TimeSl*iPortionSec, SlS->TimeSl*(iPortionSec+1));
                MoonXYZCalc(flX, flY, flZ, (ldFrom+((double)(iSec+1))/(24.0*60.0*60.0) - 2451544.0)/36525.0);
                printf("\nMoon position by sin/cos approximation\n x=%f  y=%f  z=%f\nvx=%f vy=%f vz=%f ; JPL EPHEMERIDES:\nvx=%f vy=%f vz=%f ", 
                                    flX,flY,flZ, EarthBSVX, EarthBSVY, EarthBSVZ, EarthBSNVX, EarthBSNVY, EarthBSNVZ );
            }
            else
            {
            }

        }
#ifdef _DO_VISUALIZATION
        DrawAnimationSequence(SlS,Sat, iSec,"TRA",SlS, RGBReferenceBody, dRGBScale, StartSequence, 0); 
#endif
        
        if (iSec%(60*60*24) == 0)
        {
            // on first sattelite do compare of the calculated position and SGP4 
            int iCheck = 0;
            Time_SecondsFromStart = (long double) (iSec+1);
            PrintPV(SlS, Sat, 0, ldFrom, Time_SecondsFromStart);
        }
        //Sat.X[0] = tProbX + SolarSystem.X[EARTH]; Sat.Y[0] = tProbY + SolarSystem.Y[EARTH]; Sat.Z[0] = tProbZ + SolarSystem.Z[EARTH];
        //Sat.VX[0] = tProbVX + SolarSystem.VX[EARTH]; Sat.VY[0] = tProbVY + SolarSystem.VY[EARTH]; Sat.VZ[0] = tProbVZ + SolarSystem.VZ[EARTH];

        // needs to dump data for visualization each XX sec
        if (iSec%(60) == 0) // each min output data to XML file
			    dumpTRAvisual(iSec);
		}
		OutLast = TRUE;
		dumpTRAvisual(iSec);
		printf("\n iteration done");
#ifdef _DO_VISUALIZATION
        // store last image 
        //DrawAnimationSequence(&SolarSystem,&Sat, i,"TRA",&SolarSystem, RGBReferenceBody, dRGBScale, StartSequence, 1);
        DrawFinalBody(SlS, MOON, Sat, iSec,"TRA", SlS, RGBReferenceBody, dRGBScale, StartSequence);
#endif
}

void CalcForcesPoly(long double ldUseOne, TRAOBJ *Sat, long double XdivR, long double YdivR, long double sinTetta, long double Height,
                    long double &Fx, long double &Fy, long double &Fz,
                    int iDoList[10][4], int nDoList, int iSkipList[10][4], int nSkipList)
{
    long double Xk[TOTAL_COEF+3];
    long double Yk[TOTAL_COEF+3];
    long double X,Y,Z, Xadd, Yadd, Zadd;
    long double X_,Y_,Z_, Xadd_, Yadd_, Zadd_;
    Sat->R0divR[0] = 1;
    Sat->R0divR[1] = R0_MODEL/Height;
    Sat->iLeg = iDoList[0][1];
    Sat->FillXkYk(XdivR, YdivR, Xk, Yk);
    Sat->PowerR(Sat->R0divR);
    Sat->PartSummXYZ (Xk,Yk, sinTetta,  X, Xadd, Yadd, Zadd, iDoList[0][0], iDoList[0][1], iDoList[0][2], iDoList[0][3]);
                           Y=X;            Z=X;
    // if skiplist present then 1 can be skipped
    if (nSkipList)
    {
        X=-X;         Y=-Y;          Z=-Z;
    }
    else
    {
        X=ldUseOne-X;         Y=ldUseOne-Y;          Z=ldUseOne-Z;
    }
    Xadd = -Xadd;  Yadd = -Yadd;   Zadd = -Zadd;
    // data to calulate in DoList
    for (int id =1; id < nDoList; id++)
    {
        Sat->PartSummXYZ (Xk,Yk, sinTetta,  X_, Xadd_, Yadd_, Zadd_, iDoList[id][0], iDoList[id][1], iDoList[id][2], iDoList[id][3]);
                         Y_=X_;            Z_=X_;
        X_=-X_;          Y_=-Y_;           Z_=-Z_;
        Xadd_ = -Xadd_;  Yadd_ = -Yadd_;   Zadd_ = -Zadd_;
        X+=X_;           Y+=Y_;            Z+=Z_;
        Xadd += Xadd_; Yadd += Yadd_; Zadd += Zadd_;
    }
    // next is minus values - Poly from n=2 k= 0 can be ignored
    long double Xm1, Ym1, Zm1;
    long double Xaddm1, Yaddm1, Zaddm1;
    Xm1 = 0; Ym1 = 0; Zm1 = 0; Xaddm1 = 0; Yaddm1 = 0; Zaddm1 = 0;
    long double Xm2;
    long double Xaddm2, Yaddm2, Zaddm2;
                
    for (int is = 0; is < nSkipList; is++)
    {
        Sat->PartSummXYZ (Xk,Yk, sinTetta,  Xm2, Xaddm2, Yaddm2, Zaddm2, iSkipList[is][0], iSkipList[is][1], iSkipList[is][2], iSkipList[is][3]);
        Xm1+=-Xm2;         Ym1+=-Xm2;          Zm1+=-Xm2;

        Xaddm1 += -Xaddm2;  Yaddm1 += -Yaddm2;   Zaddm1 += -Zaddm2;
    }
    Fx =(X-Xm1)*XdivR + (Xadd-Xaddm1);
    Fy =(Y-Ym1)*YdivR + (Yadd-Yaddm1);
    Fz =(Z-Zm1)*sinTetta + (Zadd-Zaddm1);
    // get FORCE from Legandre Poly
    long double ForceDD = GM_MODEL / (Height*Height);
    Fx *=ForceDD;   Fy *=ForceDD;      Fz *=ForceDD;
}

void MinusPointForces(long double &FX, long double &FY, long double &FZ, 
                      long double Xtt, long double Ytt, long double Ztt, int imp, int imp_skip)
{
    int j;
    long double ValX0, ValY0, ValZ0, tD_Obj1Obj2, tD_, Sat_ForceDD_i_j, Sat_ForceDD_i_j_div_Sat_Distance_i_j;
    for (j = 0; j < imp; j++)
    {
        if (imp_skip != j)
        {
            ValX0 = (Xtt-MassPoints[j].X);
            ValY0 = (Ytt-MassPoints[j].Y);
            ValZ0 = (Ztt-MassPoints[j].Z);
            tD_Obj1Obj2 = ValX0*ValX0 + ValY0*ValY0 + ValZ0*ValZ0;
            tD_ = sqrt(tD_Obj1Obj2);
            Sat_ForceDD_i_j = MassPoints[j].Mp * GM_MODEL / (tD_Obj1Obj2*tD_);
            FX -= (ValX0) * Sat_ForceDD_i_j;
            FY -= (ValY0) * Sat_ForceDD_i_j;
            FZ -= (ValZ0) * Sat_ForceDD_i_j;
       }
    }
}

long double Functional(long double ldUseOne, TRAOBJ *Sat, int iTotalCheckPoints, int dk, int iDoList[10][4], int nDoList,int iSkipList[10][4], int nSkipList, 
int imp, int imp_skip)
{
    int i;
    int k;
    long double Height;
    long double DHeight;
    long double Xt, Yt, Zt;
    long double X, Y, Z;
    long double Xadd, Yadd, Zadd;
    long double X_, Y_, Z_;
    long double Xadd_, Yadd_, Zadd_;

    long double sinTetta, XdivR, YdivR;
    long double Xk[TOTAL_COEF+3];
    long double Yk[TOTAL_COEF+3];
    long double FX,FY,FZ;
    long double ForceDD;
    long double Norm;
    long double Xn, Yn, Zn;
    long double Angl;
    long double NormZero;
    long double ZeroX, ZeroY, ZeroZ;
    long double ErrorMainX,ErrorMainY, ErrorMainZ;
    long double ErrorMain;
    long double MidDist;
    long double ValX0;
    long double ValY0;
    long double ValZ0;
    long double tD_Obj1Obj2;
    long double tD_;
    long double Sat_ForceDD_i_j;
    long double Sat_ForceDD_i_j_div_Sat_Distance_i_j;
    long double Sat_FX;
    long double Sat_FY;
    long double Sat_FZ;
    ErrorMain = 0;

    for (i = 0; i < iTotalCheckPoints; i++)
    {
        Height =MinH;
        DHeight = (MaxH - MinH)/dk;

        for( k= 0; k < dk; k++, Height+=DHeight)
        {
            ForceDD = GM_MODEL / (Height*Height);
            Xt = Height*TotalCheckPoints[i][0];
            Yt = Height*TotalCheckPoints[i][1];
            Zt = Height*TotalCheckPoints[i][2];
            CalcForcesPoly(ldUseOne, Sat, TotalCheckPoints[i][0], TotalCheckPoints[i][1], TotalCheckPoints[i][2], Height,
                    FX,FY,FZ,    iDoList, nDoList, iSkipList,nSkipList);

            ErrorMainX = FX;
            ErrorMainY = FY;
            ErrorMainZ = FZ;

            MinusPointForces(ErrorMainX, ErrorMainY, ErrorMainZ, Xt, Yt, Zt, imp, -1);

            ErrorMain += sqrt(ErrorMainX*ErrorMainX + ErrorMainY*ErrorMainY + ErrorMainZ*ErrorMainZ);
        }
    }
    return ErrorMain;
}
long double BallanceMass(long double StoreMass[(TOTAL_COEF+3)*(TOTAL_COEF+3)], int imp, int imp_set, long double Step)
{
    long double TotalMass = 0;
    int j;
    long double Divisor = imp -1;
    for (j = 0; j < imp; j++)
    {
        MassPoints[j].Mp = StoreMass[j];
        if (imp_set != j)
        {
            TotalMass += MassPoints[j].Mp;
        }
    }
    if (imp ==0)
        return 1.0;
    if (imp ==1)
        return 1.0;
    Divisor = Step/Divisor;
    for (j = 0 ; j < imp; j++)
    {
        if (imp_set != j)
        {
            MassPoints[j].Mp -=Divisor;
        }
    }
    return (1.0 - TotalMass + Step);
}
void FindPosWinMinError(long double ldUseOne, long double &NormZero, long double ForceNorm, long double Angl, long double &NVectorLen, long double PreSeeror,
    long double Xt, long double Yt, long double Zt, long double Xn, long double Yn, long double Zn,
    int iDoList[10][4], int nDoList, 
    int iTotalCheckPoints, TRAOBJ *Sat, int iSkipList[10][4], int nSkipList, int imp, int imp_skip, int imp_set)
{
    // initial step
    NormZero = NVectorLen * cos(Angl);
    long double ZeroX = Xt -NormZero *Xn;
    long double ZeroY = Yt -NormZero *Yn;
    long double ZeroZ = Zt -NormZero *Zn;

    long double Xtt = Xt - 2.0*NormZero *Xn;
    long double Ytt = Yt - 2.0*NormZero *Yn;
    long double Ztt = Zt - 2.0*NormZero *Zn;

    long double Heightt = sqrt(Xtt*Xtt + Ytt*Ytt + Ztt*Ztt);
    long double XttdivH = Xtt/ Heightt;
    long double YttdivH = Ytt/Heightt;
    long double ZttdivH = Ztt/Heightt;
            //Sat_ForceDD_i_j = MassPoints[j].Mp * GM_MODEL / (tD_Obj1Obj2*tD_);

    MassPoints[imp_set].Mp = ForceNorm * NormZero*NormZero / GM_MODEL;
    MassPoints[imp_set].X = ZeroX; MassPoints[imp_set].Y = ZeroY; MassPoints[imp_set].Z = ZeroZ;
    long double FX,FY,FZ;

    CalcForcesPoly(ldUseOne, Sat, XttdivH, YttdivH, ZttdivH, Heightt, FX,FY,FZ,    iDoList, nDoList, iSkipList,nSkipList);
    int iSet = imp_set;
    if (iSet >= imp)
        iSet = imp+1;
    MinusPointForces(FX, FY, FZ, Xtt, Ytt, Ztt, iSet, imp_skip);

    long double ErrorMain1 = FX*FX + FY*FY + FZ*FZ;
    if (ErrorMain1 == 0)
        return;
    PreSeeror *= ErrorMain1;

    long double Step = 1.0;

    NVectorLen += Step;

    NormZero = NVectorLen * cos(Angl);
    ZeroX = Xt -NormZero *Xn;
    ZeroY = Yt -NormZero *Yn;
    ZeroZ = Zt -NormZero *Zn;

    Xtt = Xt - 2.0*NormZero *Xn;
    Ytt = Yt - 2.0*NormZero *Yn;
    Ztt = Zt - 2.0*NormZero *Zn;

    Heightt = sqrt(Xtt*Xtt + Ytt*Ytt + Ztt*Ztt);
    XttdivH = Xtt/ Heightt;
    YttdivH = Ytt/Heightt;
    ZttdivH = Ztt/Heightt;
            //Sat_ForceDD_i_j = MassPoints[j].Mp * GM_MODEL / (tD_Obj1Obj2*tD_);

    MassPoints[imp_set].Mp = ForceNorm * NormZero*NormZero / GM_MODEL;
    MassPoints[imp_set].X = ZeroX; MassPoints[imp_set].Y = ZeroY; MassPoints[imp_set].Z = ZeroZ;

    CalcForcesPoly(ldUseOne,Sat, XttdivH, YttdivH, ZttdivH, Heightt, FX,FY,FZ,    iDoList, nDoList, iSkipList,nSkipList);
    MinusPointForces(FX, FY, FZ, Xtt, Ytt, Ztt, iSet, imp_skip);

    long double ErrorMain2 = FX*FX + FY*FY + FZ*FZ;
    while (1)
    {
        if (fabs(ErrorMain1 - ErrorMain2) <PreSeeror)
        {
            if (ErrorMain1 >= ErrorMain2)
                break;
            else
            {
                break;
            }
        }

        if (ErrorMain2 < ErrorMain1)
        {
            // contine steps
            ErrorMain1 = ErrorMain2;
        }
        else
        {
            // step reverce direction and make step twice smaller
            ErrorMain1 = ErrorMain2;

            Step = -Step/2;
            if (fabs(Step) < PreSeeror)
                break;
        }
        NVectorLen += Step;

        NormZero = NVectorLen * cos(Angl);
        ZeroX = Xt -NormZero *Xn;
        ZeroY = Yt -NormZero *Yn;
        ZeroZ = Zt -NormZero *Zn;

        Xtt = Xt - 2.0*NormZero *Xn;
        Ytt = Yt - 2.0*NormZero *Yn;
        Ztt = Zt - 2.0*NormZero *Zn;

        Heightt = sqrt(Xtt*Xtt + Ytt*Ytt + Ztt*Ztt);
        XttdivH = Xtt/ Heightt;
        YttdivH = Ytt/Heightt;
        ZttdivH = Ztt/Heightt;
            //Sat_ForceDD_i_j = MassPoints[j].Mp * GM_MODEL / (tD_Obj1Obj2*tD_);

        MassPoints[imp_set].Mp = ForceNorm * NormZero*NormZero / GM_MODEL;
        MassPoints[imp_set].X = ZeroX; MassPoints[imp_set].Y = ZeroY; MassPoints[imp_set].Z = ZeroZ;

        CalcForcesPoly(ldUseOne, Sat, XttdivH, YttdivH, ZttdivH, Heightt, FX,FY,FZ,    iDoList, nDoList, iSkipList,nSkipList);
        MinusPointForces(FX, FY, FZ, Xtt, Ytt, Ztt, iSet, imp_skip);
        ErrorMain2 = FX*FX + FY*FY + FZ*FZ;
    }

}
void NormMassPoints(int imp, long double StepM, int j, MASS_POINT_ELEMENT MassPointsI[(TOTAL_COEF+3)*(TOTAL_COEF+3)],
    MASS_POINT_ELEMENT MassPointsSumm[(TOTAL_COEF+3)*(TOTAL_COEF+3)],
    MASS_POINT_ELEMENT MassPointsV[10][(TOTAL_COEF+3)*(TOTAL_COEF+3)])
{
    // first step nothing can be bigger than 1
    int i;
    long double SummM = 0;
    long double SummMin = 0;
    int iMaxv = 0;
    for( i = 0; i < imp+1; i++)
    {
        SummM += MassPoints[i].Mp;
    }
    SummM -= 1.0 ;
    if (SummM != 0.0)
    {
        SummM /= imp+1;
        for( i = 0; i < imp+1; i++)
        {
            MassPoints[i].Mp -= SummM;
        }
        // now make it less then 1 each
        SummM = MassPoints[0].Mp ;
        //SummMin = MassPoints[0].Mp;
        iMaxv = 0;
        for( i = 1; i < imp+1; i++)
        {
            if (SummM < MassPoints[i].Mp)
            {
                SummM =MassPoints[i].Mp;
                iMaxv = i;
            }
            //if (SummMin > MassPoints[i].Mp)
            //    SummMin =MassPoints[i].Mp;

        }
        //if ((SummM > 2.0) || (SummMin < -2.0))
        //{
        //    if (fabs(SummM) > fabs(SummMin))
        //        SummM = SummM;
        //    else
        //        SummM = SummMin;
        //}
        if ((SummM > 2.0) || (SummM < -2.0))
        {
            //SummM/=2.0;
            //for( i = 0; i < imp+1; i++)
            //{
            //    MassPoints[i].Mp/=SummM;
            //}
            SummM = 0;
            for( i = 0; i < imp+1; i++)
            {
                if (i != iMaxv)
                    SummM += MassPoints[i].Mp;
                else
                    MassPoints[i].Mp = 2.0;

            }
            SummM += 1.0 ;
            if (SummM != 0.0)
            {
                SummM /= imp;
                for( i = 0; i < imp+1; i++)
                {
                    if (i != iMaxv)
                        MassPoints[i].Mp -= SummM;
                }
            }
            SummM = 0;
            for( i = 0; i < imp+1; i++)
            {
                SummM += MassPoints[i].Mp;
            }
        }
    }
    for( i = 0; i < imp+1; i++)
    {
        //MassPoints[i].Mp = MassPointsI[i].Mp + 0.5*MassPointsSumm[i].Mp + 0.5*MassPointsV[j][i].Mp;
        MassPointsV[j][i].Mp = (MassPoints[i].Mp - (MassPointsI[i].Mp + MassPointsSumm[i].Mp));
    }
    
}
void NormMassPoints1(int imp, long double StepM, int j, MASS_POINT_ELEMENT MassPointsI[(TOTAL_COEF+3)*(TOTAL_COEF+3)],
    MASS_POINT_ELEMENT MassPointsSumm[(TOTAL_COEF+3)*(TOTAL_COEF+3)],
    MASS_POINT_ELEMENT MassPointsV[10][(TOTAL_COEF+3)*(TOTAL_COEF+3)])
{
    // first step nothing can be bigger than 1
    int i;
    long double SummM = 0;
    long double SummMin = 0;
    int iMaxv = 0;
    for( i = 0; i < imp+1; i++)
    {
        SummM += MassPoints[i].Mp;
    }
    //SummM -= 1.0 ;
    if (SummM != 0.0)
    {
        SummM /= imp+1;
        for( i = 0; i < imp+1; i++)
        {
            MassPoints[i].Mp -= SummM;
        }
        // now make it less then 1 each
        SummM = MassPoints[0].Mp ;
        //SummMin = MassPoints[0].Mp;
        iMaxv = 0;
        for( i = 1; i < imp+1; i++)
        {
            if (SummM < MassPoints[i].Mp)
            {
                SummM =MassPoints[i].Mp;
                iMaxv = i;
            }

        }
        if ((SummM > 1.0) || (SummM < -1.0))
        {
            SummM = 0;
            for( i = 0; i < imp+1; i++)
            {
                if (i != iMaxv)
                    SummM += MassPoints[i].Mp;
                else
                    MassPoints[i].Mp = 1.0;

            }
            SummM += 1.0 ;
            if (SummM != 0.0)
            {
                SummM /= imp;
                for( i = 0; i < imp+1; i++)
                {
                    if (i != iMaxv)
                        MassPoints[i].Mp -= SummM;
                }
            }
            SummM = 0;
            for( i = 0; i < imp+1; i++)
            {
                SummM += MassPoints[i].Mp;
            }
        }
    }
    for( i = 0; i < imp+1; i++)
    {
        //MassPoints[i].Mp = MassPointsI[i].Mp + 0.5*MassPointsSumm[i].Mp + 0.5*MassPointsV[j][i].Mp;
        MassPointsV[j][i].Mp = (MassPoints[i].Mp - (MassPointsI[i].Mp + MassPointsSumm[i].Mp));
    }
    
}

void GetOneMassPoint(long double ldUseOne, int iModeRun, long double &ErrorMain1, 
    long double &Step, int iDoList[10][4], int nDoList, int dk,
    int iTotalCheckPoints, TRAOBJ *Sat, int iSkipList[10][4], int nSkipList, int imp, int imp_skip, int imp_set)
{
    // initial algorithm in:
    // from ftp://ftp.gfz-potsdam.de/home/sf/bar/publications/BaDie-Milan90.pdf
    // 1. loop for all points and find max abs value of the GP - (summ of all GPf of N-1 points)
    // 2. from selected point goes to the center of the planet to get minimum of the functonal (summ all errors are minimum) that point will be P_candidate
    // 3. find closes points P_close_list (k_val) to P_candidate add to a list P_close_list+P_candidate (size == k_val+1)
    // 4. find optimized value of masses in the P_close_list:
    //    a) loop for each point in the P_close_list find for mass minimum of the functional
    //    b) repeat loop till functional is minimal
    //    (all is ehuristic process == BAD == points position has to be optimized)
    //    lets try montecarlo - kill the problem with random data
    int i,j,k;
    long double Height;
    long double DHeight;
    long double Xt, Yt, Zt;
    long double X, Y, Z;
    long double Xadd, Yadd, Zadd;
    long double X_, Y_, Z_;
    long double Xadd_, Yadd_, Zadd_;
    long double sinTetta, XdivR, YdivR;
    long double Xk[TOTAL_COEF+3];
    long double Yk[TOTAL_COEF+3];
    long double FX,FY,FZ;
    long double ForceDD;
    long double Norm;
    long double Xn, Yn, Zn;
    long double Angl;
    long double NormZero;
    long double ZeroX, ZeroY, ZeroZ;
    long double CenterOfMAssX, CenterOfMAssY, CenterOfMAssZ,Mass;
    long double NVectorX, NVectorY, NVectorZ, NVectorLen;
    long double StoreMass[(TOTAL_COEF+3)*(TOTAL_COEF+3)];
    CenterOfMAssX =0; CenterOfMAssY=0; CenterOfMAssZ=0; Mass=0;
    if (imp)
    {
        for (i = 0; i < imp; i++)
        {
            CenterOfMAssX+= MassPoints[i].X*MassPoints[i].Mp;
            CenterOfMAssY+= MassPoints[i].Y*MassPoints[i].Mp;
            CenterOfMAssZ+= MassPoints[i].Z*MassPoints[i].Mp;
            Mass += MassPoints[i].Mp;
        }
        // Mass = sqrt( Mass);
        CenterOfMAssX/=Mass; CenterOfMAssY/=Mass; CenterOfMAssZ/=Mass;
    }
    // first run - to find point
    long double SumZeroX, SumZeroY, SumZeroZ;
    SumZeroX = 0; SumZeroY = 0; SumZeroZ = 0;
    long double SumNorm = 0;
    long double NormMax = 0;
    int iMax = 0;
    long double FXmax, FYmax, FZmax;
    long double NVectorXmax, NVectorYmax, NVectorZmax,NVectorLenmax;
    long double Xtmax,Ytmax,Ztmax;
    if ((iModeRun ==0) || (iModeRun ==2))
    {
        for (i = 0; i < iTotalCheckPoints; i++)
        {
            Height =MinH;
            DHeight = (MaxH - MinH)/dk;
            for( k= 0; k < dk; k++, Height+=DHeight)
            {
                // calculation of the forces from Legender Poly model
                ForceDD = GM_MODEL / (Height*Height);
                Xt = Height*TotalCheckPoints[i][0];
                Yt = Height*TotalCheckPoints[i][1];
                Zt = Height*TotalCheckPoints[i][2];
                CalcForcesPoly(ldUseOne, Sat, TotalCheckPoints[i][0], TotalCheckPoints[i][1], TotalCheckPoints[i][2], Height,
                    FX,FY,FZ,    iDoList, nDoList, iSkipList,nSkipList);
                // now needs to minus all forces from previous Mass Points
                MinusPointForces(FX, FY, FZ, Xt, Yt, Zt, imp, imp_skip);
                // normal of the FORCE vector
                Norm = sqrt(FX*FX + FY*FY + FZ*FZ);
                Xn = FX/Norm;   Yn = FY/Norm;      Zn = FZ/Norm;

                // get center of mass point of the all prev Mass Points 
                NVectorX = Xt;// - CenterOfMAssX;
                NVectorY = Yt;// - CenterOfMAssY;
                NVectorZ = Zt;// - CenterOfMAssZ;
                NVectorLen = sqrt(NVectorX*NVectorX + NVectorY*NVectorY + NVectorZ*NVectorZ);
                NVectorX /= NVectorLen; NVectorY /= NVectorLen; NVectorZ /= NVectorLen;
#if 0
                if (NormMax < Norm)
                {
                    iMax = i;
                    NormMax = Norm;
                    FXmax = FX; FYmax = FY; FZmax = FZ;
                    NVectorXmax = NVectorX; NVectorYmax=NVectorY; NVectorZmax=NVectorZ;
                    NVectorLenmax = NVectorLen;
                    Xtmax=Xt; Ytmax=Yt; Ztmax=Zt;
                }
#else
                // angle
                Angl = AngleBtwNorm(NVectorX,NVectorY,NVectorZ,Xn,Yn,Zn);
                // probable point
                FindPosWinMinError(ldUseOne,NormZero, Norm, Angl, NVectorLen, 0.00001,
                    Xt, Yt, Zt, Xn, Yn, Zn,
                            iDoList, nDoList, iTotalCheckPoints, Sat, iSkipList, nSkipList, imp, imp_skip, imp_set);
                NormZero = NVectorLen * cos(Angl);
                ZeroX = Xt -NormZero *Xn;
                ZeroY = Yt -NormZero *Yn;
                ZeroZ = Zt -NormZero *Zn;
                MassPoints[imp_set].Mp = Norm * NormZero*NormZero / GM_MODEL;
                MassPoints[imp_set].X = ZeroX; MassPoints[imp_set].Y = ZeroY; MassPoints[imp_set].Z = ZeroZ;
                // calc medium val
                SumZeroX +=ZeroX*MassPoints[imp_set].Mp; SumZeroY +=ZeroY*MassPoints[imp_set].Mp; SumZeroZ +=ZeroZ*MassPoints[imp_set].Mp;
                SumNorm += MassPoints[imp_set].Mp;
#endif
            }
        }
#if 0
        Xn = FXmax/NormMax;
        Yn = FYmax/NormMax;
        Zn = FZmax/NormMax;
        Angl = AngleBtwNorm(NVectorXmax,NVectorYmax,NVectorZmax,Xn,Yn,Zn);
        NormZero = NVectorLenmax * cos(Angl);
        ZeroX = -NVectorLenmax *Xn;
        ZeroY = -NVectorLenmax *Yn;
        ZeroZ = -NVectorLenmax *Zn;
        ZeroX +=Xtmax;
        ZeroY +=Ytmax;
        ZeroZ +=Ztmax;
        SumZeroX = ZeroX; SumZeroY = ZeroY; SumZeroZ = ZeroZ;
#else
        SumZeroX /= iTotalCheckPoints *dk*SumNorm;
        SumZeroY /= iTotalCheckPoints *dk*SumNorm;
        SumZeroZ /= iTotalCheckPoints *dk*SumNorm;
#endif
        
        for(i = 0; i < imp; i++)
        {
            StoreMass[i] = MassPoints[i].Mp;
        }
        
        MassPoints[imp_set].X = SumZeroX; MassPoints[imp_set].Y = SumZeroY; MassPoints[imp_set].Z = SumZeroZ;
        // second run to find the mass
        MassPoints[imp_set].Mp = 0;
        if (iModeRun ==0)
        {
            ErrorMain1 = Functional(ldUseOne, Sat, iTotalCheckPoints, dk, iDoList, nDoList,iSkipList, nSkipList, imp+1, imp_skip);
            long double ErrorMain2;
            Step = -0.1;
            MassPoints[imp_set].Mp = Step;
            ErrorMain2 = Functional(ldUseOne,Sat, iTotalCheckPoints, dk, iDoList, nDoList,iSkipList, nSkipList, imp+1, imp_skip);
            while (1)
            {
                if (fabs(ErrorMain1 - ErrorMain2) <1e-17)
                {
                    if (ErrorMain1 >= ErrorMain2)
                        break;
                    else
                    {
                        MassPoints[imp_set].Mp -=Step;
                        break;
                    }
                }
                if (ErrorMain2 < ErrorMain1)
                {
                    // contine steps
                    ErrorMain1 = ErrorMain2;
                }
                else
                {
                    // step reverce direction and make step twice smaller
                    ErrorMain1 = ErrorMain2;
                    Step = -Step/2;
                    if (fabs(Step) < 1e-17)
                        break;
                }
                MassPoints[imp_set].Mp += Step;
                ErrorMain2 = Functional(ldUseOne,Sat, iTotalCheckPoints, dk, iDoList, nDoList,iSkipList, nSkipList, imp+1, imp_skip);
            }
            if (imp<=1)
            {
                return;
            }
            ErrorMain1 = ErrorMain2;
        }
    }

    // some how point found 
    // now optimization:
    // 1.generate 10 random vectors (each with dimention 4 * [number of points]
    // 2.calulates 10 functionals on all this vectors
    // 3. calc summ_vector with Weight == MAX_val_functional - functional + 1 that is a vector with more probable direction
    // 4 generate 10 random vectors + summ_vector
    // 5. calulate 10 functionals on all this vectors
    // 6. calc (0.25*old_summ_vector + 0.75*summ_vector) (0.25 & 0.75 are params)
    // 7. loop to pp 4
    MASS_POINT_ELEMENT MassPointsI[(TOTAL_COEF+3)*(TOTAL_COEF+3)];
    MASS_POINT_ELEMENT MassPointsSumm[(TOTAL_COEF+3)*(TOTAL_COEF+3)];
    MASS_POINT_ELEMENT MassPointsV[10][(TOTAL_COEF+3)*(TOTAL_COEF+3)];
#define ARRAY_OF_TESTS 10
    long double FunctionalVal[ARRAY_OF_TESTS];
    long double FunctionalValOld[ARRAY_OF_TESTS];
    long double StepM = 10.0* ErrorMain1 / ((long double)iTotalCheckPoints * (long double)dk); // for mass initial step is 0.1
    long double StepXYZ = 1000.0* ErrorMain1 / ((long double)iTotalCheckPoints * (long double)dk); // for position initial step is 10m
    for (j = 0; j < ARRAY_OF_TESTS; j++)
    {
        FunctionalValOld[j] = 0.0;
    }
    for (i = 0; i < imp+1; i++)
    {
        MassPointsI[i].X = MassPoints[i].X;  MassPointsI[i].Y = MassPoints[i].Y;  MassPointsI[i].Z = MassPoints[i].Z;  MassPointsI[i].Mp = MassPoints[i].Mp;
        MassPointsSumm[i].X =0;  MassPointsSumm[i].Y =0;  MassPointsSumm[i].Z =0;  MassPointsSumm[i].Mp =0;
    }
    long double MIN_PrevFunc = 1e+50;//ErrorMain1;
    long int CountContinue = 1000;
    long double stepxyz = StepXYZ;
    long long llFound = 0;
    long double stepm = StepM;
    long double Devisor = 2.0;
    long double RealStepWas = 0;
    int iCUrMin_ = 0;
    BOOL bStepWas_ = FALSE;
    long double ldCUrMin_ = 0;
    long double StepWas_[(TOTAL_COEF+3)*(TOTAL_COEF+3)];
    long double StepMassWas_[(TOTAL_COEF+3)*(TOTAL_COEF+3)];
    BOOL ResetMassPointsSum = TRUE;
    int RANDOM_TESTS = (imp+1)*64*4;

    while(1)
    {
        long double MAX_val_functional = 0;
        int jmax =0;
        long double AllVal = 0;

        long double MIN_val_functional = 10e+50;
        int jmin =0;
        BOOL FindOnTheExactPath = FALSE;
        CountContinue = RANDOM_TESTS;
        for (j = 0; j < ARRAY_OF_TESTS; j++)
        {
            while(1)
            {
                for (i = 0; i < imp+1; i++)
                {
                    if (j == 1)
                    {
                        // case: optimization point from j=0 used but with different mass points
                        MassPointsV[j][i].X = MassPointsV[0][i].X;  MassPointsV[j][i].Y = MassPointsV[0][i].Y;  MassPointsV[j][i].Z = MassPointsV[0][i].Z;
                        MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                        MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                        MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                        MassPointsV[j][i].Mp = stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                        MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                        continue;
                    }
                    else if (j == 2)
                    {
                        // case: initial point from prev step but mass points values from j== 0
                        MassPointsV[j][i].X = -MassPointsSumm[i].X;  MassPointsV[j][i].Y = -MassPointsSumm[i].Y;  MassPointsV[j][i].Z = -MassPointsSumm[i].Z;
                        MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                        MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                        MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                        MassPointsV[j][i].Mp = MassPointsV[0][i].Mp;
                        MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                        continue;
                    }
                    else if (j == 3)
                    {
                        // case: 0.5 step
                        GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                        MassPointsV[j][i].X *= 0.5*stepxyz;  MassPointsV[j][i].Y *= 0.5*stepxyz;  MassPointsV[j][i].Z *= 0.5*stepxyz;
                        MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                        MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                        MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                        MassPointsV[j][i].Mp = 0.5*stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                        MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                        continue;
                    }
                    else if (j == 4)
                    {
                        // case: 0.25 step
                        GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                        MassPointsV[j][i].X *= 0.25*stepxyz;  MassPointsV[j][i].Y *= 0.25*stepxyz;  MassPointsV[j][i].Z *= 0.25*stepxyz;
                        MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                        MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                        MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                        MassPointsV[j][i].Mp = 0.25*stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                        MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                        continue;
                    }
                    else if (j == 5)
                    {
                        // case: 0.25 step 
                        if (FunctionalVal[1] < MIN_PrevFunc) // for j == 3 (0.5 step) was found min => search in this area
                        {
                            GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                            MassPointsV[j][i].X *= 0.25*stepxyz;  MassPointsV[j][i].Y *= 0.25*stepxyz;  MassPointsV[j][i].Z *= 0.25*stepxyz;
                            MassPointsV[j][i].X += MassPointsV[1][i].X;  MassPointsV[j][i].Y += MassPointsV[1][i].Y;  MassPointsV[j][i].Z += MassPointsV[1][i].Z;
                            MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                            MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                            MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                            MassPointsV[j][i].Mp = 0.25*stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                            MassPointsV[j][i].Mp += MassPointsV[1][i].Mp;
                            MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                            continue;
                        }
                        else if (FunctionalVal[2] < MIN_PrevFunc) // for j == 3 (0.5 step) was found min => search in this area
                        {
                            GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                            MassPointsV[j][i].X *= 0.25*stepxyz;  MassPointsV[j][i].Y *= 0.25*stepxyz;  MassPointsV[j][i].Z *= 0.25*stepxyz;
                            MassPointsV[j][i].X += MassPointsV[2][i].X;  MassPointsV[j][i].Y += MassPointsV[2][i].Y;  MassPointsV[j][i].Z += MassPointsV[2][i].Z;
                            MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                            MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                            MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                            MassPointsV[j][i].Mp = 0.25*stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                            MassPointsV[j][i].Mp += MassPointsV[2][i].Mp;
                            MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                            continue;
                        }
                        else if (FunctionalVal[3] < MIN_PrevFunc) // for j == 3 (0.5 step) was found min => search in this area
                        {
                            GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                            MassPointsV[j][i].X *= 0.25*stepxyz;  MassPointsV[j][i].Y *= 0.25*stepxyz;  MassPointsV[j][i].Z *= 0.25*stepxyz;
                            MassPointsV[j][i].X += MassPointsV[3][i].X;  MassPointsV[j][i].Y += MassPointsV[3][i].Y;  MassPointsV[j][i].Z += MassPointsV[3][i].Z;
                            MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                            MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                            MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                            MassPointsV[j][i].Mp = 0.25*stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                            MassPointsV[j][i].Mp += MassPointsV[3][i].Mp;
                            MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                            continue;
                        }
                        if (FunctionalVal[4] < MIN_PrevFunc) // for j == 4 (0.25 step) was found min => search in this area
                        {
                            GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                            MassPointsV[j][i].X *= 0.25*stepxyz;  MassPointsV[j][i].Y *= 0.25*stepxyz;  MassPointsV[j][i].Z *= 0.25*stepxyz;
                            MassPointsV[j][i].X += MassPointsV[4][i].X;  MassPointsV[j][i].Y += MassPointsV[4][i].Y;  MassPointsV[j][i].Z += MassPointsV[4][i].Z;
                            MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                            MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                            MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                            MassPointsV[j][i].Mp = 0.25*stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                            MassPointsV[j][i].Mp += MassPointsV[4][i].Mp;
                            MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                            continue;
                        }
                        
                        {
                            GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                            MassPointsV[j][i].X *= 0.25*stepxyz;  MassPointsV[j][i].Y *= 0.25*stepxyz;  MassPointsV[j][i].Z *= 0.25*stepxyz;
                            MassPointsV[j][i].X += MassPointsV[0][i].X;  MassPointsV[j][i].Y += MassPointsV[0][i].Y;  MassPointsV[j][i].Z += MassPointsV[0][i].Z;
                            MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                            MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                            MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                            MassPointsV[j][i].Mp = 0.25*stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                            MassPointsV[j][i].Mp += MassPointsV[0][i].Mp;
                            MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                            continue;
                        }
                    }
                    else if (j==6)
                    {
                        if (FunctionalVal[5] < MIN_PrevFunc)
                        {
                            GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                            MassPointsV[j][i].X *= 0.25*stepxyz;  MassPointsV[j][i].Y *= 0.25*stepxyz;  MassPointsV[j][i].Z *= 0.25*stepxyz;
                            MassPointsV[j][i].X += MassPointsV[5][i].X;  MassPointsV[j][i].Y += MassPointsV[5][i].Y;  MassPointsV[j][i].Z += MassPointsV[5][i].Z;
                            MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                            MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                            MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                            MassPointsV[j][i].Mp = 0.25*stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                            MassPointsV[j][i].Mp += MassPointsV[5][i].Mp;
                            MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                            continue;
                        }
                        {
                            GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                            MassPointsV[j][i].X *= 0.125*stepxyz;  MassPointsV[j][i].Y *= 0.125*stepxyz;  MassPointsV[j][i].Z *= 0.125*stepxyz;
                            MassPointsV[j][i].X += MassPointsV[0][i].X;  MassPointsV[j][i].Y += MassPointsV[0][i].Y;  MassPointsV[j][i].Z += MassPointsV[0][i].Z;
                            MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                            MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                            MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                            MassPointsV[j][i].Mp = 0.125*stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                            MassPointsV[j][i].Mp += MassPointsV[0][i].Mp;
                            MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                            continue;
                        }
                    }
                    else if ((j == 7) || (j == 8))
                    {
                        if (bStepWas_ == FALSE)
                        {
                            iCUrMin_ = 0;
                            ldCUrMin_ = FunctionalVal[0];
                            StepWas_[i] = 0;
                            StepMassWas_[i] = 0;

                            for (int ise = 0; ise < j; ise++)
                            {
                                if (ldCUrMin_ > FunctionalVal[ise])
                                {
                                    ldCUrMin_ = FunctionalVal[ise];
                                    iCUrMin_ = ise;
                                }
                            }
                            StepWas_[i] = (MassPointsSumm[i].X + MassPointsV[iCUrMin_][i].X)*(MassPointsSumm[i].X + MassPointsV[iCUrMin_][i].X) + 
                                (MassPointsSumm[i].Y + MassPointsV[iCUrMin_][i].Y)*(MassPointsSumm[i].Y + MassPointsV[iCUrMin_][i].Y) + 
                                (MassPointsSumm[i].Z + MassPointsV[iCUrMin_][i].Z)*(MassPointsSumm[i].Z + MassPointsV[iCUrMin_][i].Z);
                            StepWas_[i] = sqrt(StepWas_[i]);
                            StepMassWas_[i] = MassPointsSumm[i].Mp + MassPointsV[iCUrMin_][i].Mp;
                            if (i == imp)
                                bStepWas_ = TRUE;
                            if (j==7)
                            {
                                StepWas_[i] *= 0.0625;
                                StepMassWas_[i] = fabs(StepMassWas_[i] * 0.0625);
                            }
                            else if (j==8)
                            {
                                StepWas_[i] *= 0.03125;
                                StepMassWas_[i] =  fabs(StepMassWas_[i]* 0.03125);
                            }
                        }
                        GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                        MassPointsV[j][i].X *= StepWas_[i];  MassPointsV[j][i].Y *= StepWas_[i];  MassPointsV[j][i].Z *= StepWas_[i];
                        MassPointsV[j][i].X += MassPointsV[iCUrMin_][i].X;  MassPointsV[j][i].Y += MassPointsV[iCUrMin_][i].Y;  MassPointsV[j][i].Z += MassPointsV[iCUrMin_][i].Z;
                        MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                        MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                        MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                        MassPointsV[j][i].Mp = StepMassWas_[i] * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                        MassPointsV[j][i].Mp += MassPointsV[iCUrMin_][i].Mp;
                        MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                        continue;
                    }
                    /*else if (j == 9)
                    {
                        // just in case case: initial point from prev step
                        MassPointsV[j][i].X = -MassPointsSumm[i].X;  MassPointsV[j][i].Y = -MassPointsSumm[i].Y;  MassPointsV[j][i].Z = -MassPointsSumm[i].Z;
                        MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                        MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                        MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                        MassPointsV[j][i].Mp = -MassPointsSumm[i].Mp;
                        MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                        continue;
                    }*/
                    // that is a case of 0 & 9
                    if ((j == 0) && (bStepWas_ == FALSE))
                    {
                        if (i == imp)
                            bStepWas_ = TRUE;
                        MassPointsV[j][i].X = 0;  MassPointsV[j][i].Y = 0;  MassPointsV[j][i].Z = 0;
                        MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                        MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                        MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                        MassPointsV[j][i].Mp = 0;
                        MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                        continue;
                    }
                    if ((j == 9) && (bStepWas_ == FALSE))
                    {
                        if (i == imp)
                            bStepWas_ = TRUE;
                        MassPointsV[j][i].X = -MassPointsSumm[i].X*0.5;  MassPointsV[j][i].Y = -MassPointsSumm[i].Y*0.5;  MassPointsV[j][i].Z = -MassPointsSumm[i].Z*0.5;
                        MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                        MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                        MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                        MassPointsV[j][i].Mp = -MassPointsSumm[i].Mp * 0.5;
                        MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                        continue;
                    }
                    GetRandomNVector(MassPointsV[j][i].X, MassPointsV[j][i].Y, MassPointsV[j][i].Z);
                    MassPointsV[j][i].X *= stepxyz;  MassPointsV[j][i].Y *= stepxyz;  MassPointsV[j][i].Z *= stepxyz;
                    MassPoints[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[j][i].X;
                    MassPoints[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[j][i].Y;
                    MassPoints[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[j][i].Z;
                    MassPointsV[j][i].Mp = stepm * ((long double)ra()-(long double)ra()) / (2.0*(long double)4294967295L);
                    MassPoints[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[j][i].Mp;
                }
                NormMassPoints1(imp, stepm, j, MassPointsI, MassPointsSumm, MassPointsV);
                FunctionalVal[j] = Functional(ldUseOne, Sat, iTotalCheckPoints, dk, iDoList, nDoList,iSkipList, nSkipList, imp+1, imp_skip);
                if (FunctionalVal[j] > MIN_PrevFunc)
                {
                    if (j ==0)
                    {
                        if (--CountContinue <0)
                        {
                            CountContinue = RANDOM_TESTS;
                            stepxyz *= 1.2;
                            if (stepxyz > StepXYZ* 10000.0)
                                stepxyz = StepXYZ/4.0;
                            stepm *= 1.1;
                            if (stepm > StepM*100.0)
                                stepm = StepM/4.0;
                        }
                        llFound ++;
                        if (llFound > 500000)
                        {
                            ResetMassPointsSum = TRUE;
                            for (i = 0; i < imp+1; i++)
                            {
                                MassPointsSumm[i].X =0;  MassPointsSumm[i].Y =0;  MassPointsSumm[i].Z =0;  MassPointsSumm[i].Mp =0;
                            }
                            stepxyz = StepXYZ/4.0;
                            stepm = StepM/4.0;
                            llFound = 0;
                        }
                        continue;
                    }
                    else if (j ==2)
                    {
                        bStepWas_ = FALSE;
                        CountContinue = RANDOM_TESTS;
                        break;
                    }
                    else if (j <=8)
                    {
                        if (--CountContinue <0)
                        {
                            CountContinue = RANDOM_TESTS;
                            bStepWas_ = FALSE;
                            break;
                        }
                        continue;
                    }
                    else if (j ==9)
                    {
                        CountContinue = RANDOM_TESTS;
                        bStepWas_ = FALSE;
                        break;
                    }
                    else if (j <=10)
                    {
                        CountContinue = RANDOM_TESTS;
                        bStepWas_ = FALSE;
                        break;
                    }
                    CountContinue = RANDOM_TESTS;
                    break;
                }
                else
                {
                    if (CountContinue == RANDOM_TESTS)
                    {
                        if ((j == 0) && (ResetMassPointsSum== FALSE))
                            FindOnTheExactPath = TRUE;
                    }
                    CountContinue = RANDOM_TESTS;
                    //stepxyz = StepXYZ;
                    llFound = 0;
                    stepm = StepM;
                    bStepWas_ = FALSE;
                    break;
                }
            } 
            if (MAX_val_functional < FunctionalVal[j])
            {
                MAX_val_functional = FunctionalVal[j];
                jmax = j;
            }
            if (MIN_val_functional >= FunctionalVal[j])
            {
                MIN_val_functional = FunctionalVal[j];
                jmin = j;
                if ((j == 0) && FindOnTheExactPath)
                    break;
            }
        }
        MIN_PrevFunc = MIN_val_functional;
        CountContinue = RANDOM_TESTS;
        //stepxyz = StepXYZ;
        // set next point (dimention == 4*Npoints) as minimum of optimized functional
        for (i = 0; i <  imp+1; i++)
        {
            MassPointsI[i].X = MassPointsI[i].X + MassPointsSumm[i].X + MassPointsV[jmin][i].X;
            MassPointsI[i].Y = MassPointsI[i].Y + MassPointsSumm[i].Y + MassPointsV[jmin][i].Y;
            MassPointsI[i].Z = MassPointsI[i].Z + MassPointsSumm[i].Z + MassPointsV[jmin][i].Z;
            //if ( i == 0)
            //    MassPointsI[i].Mp = 1;
            //else
                MassPointsI[i].Mp = MassPointsI[i].Mp + MassPointsSumm[i].Mp + MassPointsV[jmin][i].Mp;
        }

        MAX_val_functional *= 1.0;
        long double MIN_coef = MAX_val_functional - FunctionalVal[jmin];
#if 0
        // get preferable vector
        for (j = 0; j < 10; j++)
        {
            FunctionalVal[j] = (MAX_val_functional - FunctionalVal[j])/MIN_coef;///(MAX_val_functional/1.1);
            AllVal += FunctionalVal[j];
            for (i = 0; i < imp+1; i++)
            {
                MassPointsSumm[i].X = (MassPointsSumm[i].X +  MassPointsV[j][i].X)*FunctionalVal[j];
                MassPointsSumm[i].Y = (MassPointsSumm[i].Y +  MassPointsV[j][i].Y)*FunctionalVal[j];
                MassPointsSumm[i].Z = (MassPointsSumm[i].Z +  MassPointsV[j][i].Z)*FunctionalVal[j];
                MassPointsSumm[i].Mp = (MassPointsSumm[i].Mp + MassPointsV[j][i].Mp)*FunctionalVal[j];
            }
        }
        // set preferable vector
        for (i = 0; i <  imp+1; i++)
        {
            MassPointsSumm[i].X /= 10 * AllVal; MassPointsSumm[i].Y /= 10 * AllVal; MassPointsSumm[i].Z /= 10 * AllVal; MassPointsSumm[i].Mp /= 10 * AllVal;
        }
        
        for(j = 0; j < 10; j++)
        {
            FunctionalValOld[j] = FunctionalVal[j];
        }
#else
        stepxyz = 0;
        //Devisor = 2.0;
        for (i = 0; i < imp+1; i++)
        {
            MassPointsSumm[i].X = (1.5*MassPointsSumm[i].X + 0.5* MassPointsV[jmin][i].X)/Devisor;
            MassPointsSumm[i].Y = (1.5*MassPointsSumm[i].Y + 0.5* MassPointsV[jmin][i].Y)/Devisor;
            MassPointsSumm[i].Z = (1.5*MassPointsSumm[i].Z + 0.5* MassPointsV[jmin][i].Z)/Devisor;
            MassPointsSumm[i].Mp = (1.5*MassPointsSumm[i].Mp + 0.5* MassPointsV[jmin][i].Mp)/Devisor;
            stepxyz += MassPointsSumm[i].X*MassPointsSumm[i].X + MassPointsSumm[i].Y*MassPointsSumm[i].Y +MassPointsSumm[i].Z*MassPointsSumm[i].Z;
        }
#endif
        StepXYZ = 1000.0* MIN_PrevFunc / ((long double)iTotalCheckPoints * (long double)dk);
        StepM = StepXYZ / 100.0;
        stepxyz = 0.5*sqrt(stepxyz/3.0);
        if (stepxyz > 0)
            ResetMassPointsSum= FALSE;
        RealStepWas = 2.0*stepxyz ;
        //Devisor *= 0.995;
        //if (Devisor < 1.7)
            Devisor = 1.515;
        //if (stepxyz > (StepXYZ*5.0))
        //{
        //    stepxyz = StepXYZ;
        //    Devisor = 2.0;
        //}
        if (stepxyz > 10*StepXYZ)
            stepxyz = 10*StepXYZ;
        if (stepxyz < 0.1)
            stepxyz = StepXYZ;
        stepm = StepM;
/*
        printf (" direction of the min gradient:\n");
        for (i = 0; i <  imp+1; i++)
        {
            printf("%03d %+25.17Le %+25.17Le %+25.17Le %+25.17Le\n", i, MassPointsSumm[i].X, MassPointsSumm[i].Y, MassPointsSumm[i].Z, MassPointsSumm[i].Mp);
        }
        */
        printf ("\n opt %015f n=%03d %03d k=%03d %03d points=%03d stepXYZ=%f stepm =%f jmin =%d was=%f Vals:\n",MIN_PrevFunc, iDoList[0][0], iDoList[0][1], iDoList[0][2], iDoList[0][3],imp+1,stepxyz,stepm,jmin,RealStepWas);
        for (i = 0; i <  imp+1; i++)
        {
            printf("%03d %+25.17Le %+25.17Le %+25.17Le %+25.17Le\n", i, MassPointsI[i].X, MassPointsI[i].Y, MassPointsI[i].Z, MassPointsI[i].Mp);
        }
        if (StepXYZ < 1e-4)
            break;
    }
    for (i = 0; i < imp+1; i++)
    {
        MassPoints[i].X = MassPointsI[i].X;  MassPoints[i].Y = MassPointsI[i].Y;  MassPoints[i].Z = MassPointsI[i].Z;  MassPoints[i].Mp = MassPointsI[i].Mp;
    }

    ErrorMain1 = MIN_PrevFunc;

}
void MassPointGen(TRAOBJ *SlS, TRAOBJ *Sat,TRAIMPLOBJ *Eng, long double ldFrom,long double ldFromTLEEpoch, long long iAllSec, int iItPerS, long double tSl)
{
    int i;
    int k;
    char szLine[1024];
    int iSkipList[10][4];
    int nSkipList = 0;
    int iTotalCheckPoints;
    int iDoList[10][4];
    int nDoList;

    FILE * CheckPointsFile = fopen(MidRandPointsFile, "r");
    if (CheckPointsFile)
    {
        memset(szLine, 0, sizeof(szLine));
        fgets(szLine,sizeof(szLine), CheckPointsFile);
        iTotalCheckPoints = atoi(szLine);
        if (iTotalCheckPoints > MAX_CHECK_POINTS)
        {
            printf("\n error == MAX_CHECK_POINTS");
            exit(-7);
        }

        for (i = 0; i < iTotalCheckPoints; i++)
        {
            memset(szLine, 0, sizeof(szLine));
            fgets(szLine,sizeof(szLine), CheckPointsFile);
            TotalCheckPoints[i][0] = atof(szLine);
            TotalCheckPoints[i][1] = atof(&szLine[26]);
            TotalCheckPoints[i][2] = atof(&szLine[52]);
        }
        fclose(CheckPointsFile);
    }
    else
    {
        CheckPointsFile = fopen(MidRandPointsFile, "w");
        if (CheckPointsFile)
        {
            for (i = 0; i < MAX_CHECK_POINTS; i++)
            {
                GetRandomNVector(TotalCheckPoints[i][0], TotalCheckPoints[i][1], TotalCheckPoints[i][2]);
            }
            fprintf(CheckPointsFile, "%d\n",MAX_CHECK_POINTS);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double) 0.0,(long double) 0.0,(long double) 1.0);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double) 0.0,(long double) 1.0,(long double) 0.0);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double) 1.0,(long double) 0.0,(long double) 0.0);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double)-1.0,(long double) 0.0,(long double) 0.0);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double) 0.0,(long double)-1.0,(long double) 0.0);
            fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n",(long double) 0.0,(long double) 0.0,(long double)-1.0);
            for (i = 0; i < MAX_CHECK_POINTS-6; i++)
            {
                fprintf(CheckPointsFile, "%+25.17Le %+25.17Le %+25.17Le \n", TotalCheckPoints[i][0], TotalCheckPoints[i][1], TotalCheckPoints[i][2]);
            }
            fclose(CheckPointsFile);
        } 
        return;
    }
    MinH += EarthR;
    MaxH += EarthR;
    Sat->precEps =0;
    Sat->precTet =0;
    Sat->precZ =0;
    Sat->nutEpsilon =0;
    Sat->nutDFeta = 0;
    Sat->Lambda = 0;
    int dk = 1;
    long double MassPer;
    long double SumZeroX, SumZeroY, SumZeroZ;
    long double Gerror, step;
    int imp = 0;
    iDoList[0][0] =2; iDoList[0][1] =2;iDoList[0][2] =0;iDoList[0][3] =0;
    nDoList  =1;
    char szOpt[20] = {" ini"};
    FILE * fMassPointOutput = NULL;
    if (GetFileString(szMassPointsModelFile, "@ModelOutput", 0, NULL, 0) == 0) // open was successfull fInputReadUrlOrFile is a handler
    {
        char szString[1024];
        int status_modelfileread = 0;
        int ik; // last read
        
        while(GetFileString(szMassPointsModelFile, "@ModelOutput", 1, szString, sizeof(szString)) == 0)
        {
            if (status_modelfileread ==0)
            {
                status_modelfileread = 1;
                // opt 00000000.056894 n=002 002 k=000 000 points=003 stepXYZ=0.568940 stepm =0.000569 jmin =3 was=1.867428 Vals:
                //012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                //0         1         2         3         4         5         6         7         8         9         10
                memset(szOpt, 0, sizeof(szOpt));
                memcpy(szOpt,&szString[0], 4);
                Gerror = atof(&szString[5]);
                iDoList[0][0] =atoi(&szString[23]);
                iDoList[0][1] =atoi(&szString[27]);
                iDoList[0][2] =atoi(&szString[33]);
                iDoList[0][3] =atoi(&szString[37]);
                nDoList  =1;
                imp = atoi(&szString[48]);
            }
            else
            {
                //000 +3.35596057677783980e+003 -6.90090131721902250e+002 +2.91567834116732230e+004 +1.99982885630231770e+000
                //012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                //0         1         2         3         4         5         6         7         8         9         10
                ik= atoi(&szString[0]);
                if (ik < imp)
                {
                    MassPoints[ik].X = atof(&szString[4]);
                    MassPoints[ik].Y = atof(&szString[30]);
                    MassPoints[ik].Z = atof(&szString[56]);
                    MassPoints[ik].Mp = atof(&szString[82]);
                }
                else
                {
                    printf("\n error inside mass points file");
                    exit (33);
                }
            }
        }
        if ((ik+1) != imp)
        {
            printf("\n error in mass point file");
            exit (33);
        }
    }
    if (strstr(szOpt, " ini"))
    {
        GetOneMassPoint(0.0, 0, Gerror, step,iDoList, nDoList, dk,iTotalCheckPoints, Sat, iSkipList, nSkipList, imp,-1, imp);
        printf("\n%03d p=%10f %10f %10f m= %10f e= %f", imp, MassPoints[imp].X, MassPoints[imp].Y, MassPoints[imp].Z, MassPoints[imp].Mp, Gerror);

        imp++;
        GetOneMassPoint(0.0,0, Gerror, step, iDoList, nDoList, dk,iTotalCheckPoints, Sat, iSkipList, nSkipList, imp,-1,imp);
        printf("\n%03d p=%10f %10f %10f m= %10f e= %f", imp, MassPoints[imp].X, MassPoints[imp].Y, MassPoints[imp].Z, MassPoints[imp].Mp, Gerror);

        imp++;
        GetOneMassPoint(0.0,0, Gerror, step, iDoList, nDoList, dk,iTotalCheckPoints, Sat, iSkipList, nSkipList, imp,-1,imp);
        printf("\n%03d p=%10f %10f %10f m= %10f e= %f", imp, MassPoints[imp].X, MassPoints[imp].Y, MassPoints[imp].Z, MassPoints[imp].Mp, Gerror);
        imp++;
        GetOneMassPoint(0.0,0, Gerror, step, iDoList, nDoList, dk,iTotalCheckPoints, Sat, iSkipList, nSkipList, imp,-1,imp);
        printf("\n%03d p=%10f %10f %10f m= %10f e= %f", imp, MassPoints[imp].X, MassPoints[imp].Y, MassPoints[imp].Z, MassPoints[imp].Mp, Gerror);
    }
    else if (strstr(szOpt, " add"))
    {
        // add one point:
        GetOneMassPoint(0.0,2, Gerror, step, iDoList, nDoList, dk,iTotalCheckPoints, Sat, iSkipList, nSkipList, imp,-1,imp);
    }
    else
    {
        imp--;
        // jast to finish initial job:
        GetOneMassPoint(0.0,1, Gerror, step, iDoList, nDoList, dk,iTotalCheckPoints, Sat, iSkipList, nSkipList, imp,-1,imp);
    }
    fMassPointOutput = fopen("@ModelOutput", "w");
    if (fMassPointOutput)
    {
        fprintf (fMassPointOutput,"\n opt %015f n=%03d %03d k=%03d %03d points=%03d stepXYZ=%f stepm =%f jmin =%d was=%f Vals:\n",Gerror, iDoList[0][0], iDoList[0][1], iDoList[0][2], iDoList[0][3],imp+1, 0.0, 0.0, 0, 0.0);

        for (i = 0; i <  imp+1; i++)
        {
            fprintf(fMassPointOutput,"%03d %+25.17Le %+25.17Le %+25.17Le %+25.17Le\n", i, MassPoints[i].X, MassPoints[i].Y, MassPoints[i].Z, MassPoints[i].Mp);
        }
    }

}

int main(int argc, char * argv[])
{
    //initializing procXML
    init_proc_XML();

    //initializing traXML
    init_tra_XML();


    int iDay;
    int iFlag = 0;
    int flFindMax;
    int flFindMin;
    int OptimMin = 1;

    stateType  StateEarth;
    stateType  StateMoon;
    
    double minDeltaMinMaxD;
    double maxDeltaMinMaxD;
    long iCountMin;

    double dErrorValue = 1000000.0;
    int iApog = 0;
    double Apog = 0.0;
    int iPerig = 0;
    double Perig = 0.0;
    double PerigMoon = 100000000000.0;
    double ApogPergTime = 0;
    double dRE;
    double dRM;
    double dRM0;
    int idRM = 0;
    double dRM1 =0;
    double dRM2 = 0;
    double dRMDelta = 1.0;
    int idRMDelta = 0;
    int StartSequence = 0;
    double dREMV;
    double SCH_Per = 10000000000000.0;
    double SCH_Apg = 0.0;
    double SCH_Dist = 0.0;
    int iSCH_Apg = 0;
    int iSCH_Per = 0;
    int SCH_ApgPerTime = 0;
    

#define MAXTRYANGLESDIR 6
    //double FindMin;
    int iFindMin;
    //double newTryAnglesDirDelta;

    int iFirstAngleDone = 0;
    int iMaxTryAnglesDir = MAXTRYANGLESDIR;
    int iTryAnglesDir = 0;
    double TryAnglesDirDelta = 0.25;
    double TryAnglesDir[MAXTRYANGLESDIR+1][3] = {0,0,0, 0,0,1, 0,0,-1, 0,1,0, 0,-1,0, 1,0,0, -1,0,0}; 
    double TryAnglesDirValues[MAXTRYANGLESDIR+1];
    double LastStepTryAnglesDirValuesX;
    double LastStepTryAnglesDirValuesY;
    //double LastStepTryAnglesDirValuesZ;
#define LASTSTEPHIST 10
    //int iLastStepHist;
    double LastStepHistX[LASTSTEPHIST];
    double LastStepHistY[LASTSTEPHIST];
    double LastStepHistZ[LASTSTEPHIST];
    TRAOBJ MyTry = SolarSystem;
    TRAOBJ MyTrySat = Sat;
    //TRAIMPLOBJ MyEngine[MAX_ENGINES];

	long double tProbTSec,tProbEcc,tProbIncl,tProbAscNode,tProbArgPer,tProbMeanAnom;
	long double tX,tY,tZ,tVX,tVY,tVZ;
    long double Time_SecondsFromStart=0;
    double ttProbX,ttProbY,ttProbZ,ttProbVX,ttProbVY,ttProbVZ;
    double tttX,tttVX;
    char szXMLFileName[3*_MAX_PATH] = {"tra.xml"};

    //InitTraMap(&CurTraMap);
    Sat.Elem = 0;  // zero asatelites at the begining
    Initialize_Ephemeris(BINARY_EP_NAME);
    printf("\nInitialize_Ephemeris=%s",BINARY_EP_NAME);
    if (argc == 2)
    {
        if (argv[1][1] == '?')
        {
            printf("\n TRA.EXE trajectory calculation software. Adobri Solutions LTD. Team Plan B");
            printf("\n licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.");
            printf("\n");
            printf("\n USAGE:");
            printf("\n  TRA.EXE  -?          - help");
            printf("\n  TRA.EXE              - process TRA.XML file");
            printf("\n  TRA.EXE <FILE NAME>  - process <FILE NAME>");
            printf("\n  TRA.EXE <URL> - process <URL> file");
            exit (0);
        }
        else
        {
            strcpy(szXMLFileName,argv[1]);
        }
    }
    AfxSocketInit();

    fInputReadUrlOrFile = NULL;
    if (GetFileString(szXMLFileName, "@tra.xml", 0, NULL, 0) == 0) // open was successfull fInputReadUrlOrFile is a handler
    {
        ParamDoAll(fInputReadUrlOrFile);
        fclose(fInputReadUrlOrFile);
        fInputReadUrlOrFile = NULL;
        if (strlen(CalcinfoFile) !=0)
        {
            if (GetFileString(CalcinfoFile, "@tracalc.xml", 0, NULL, 0) == 0)
            {
                ParamDoAll(fInputReadUrlOrFile);
                fclose(fInputReadUrlOrFile);
                fInputReadUrlOrFile = NULL;
            }
        }
    }
    else
        exit(1);
	{
        AssignFromNASAData(&SolarSystem, dStartJD);
        Interpolate_State( dStartJD , 2 , &StateEarth );
        StartSequence = 0;
        iDay = 0;
        printf("\n iterations per sec = %d", iItearationsPerSec);

#ifdef CALC_SOLAR_SYSTEM
//#define FIND_SPEED_BASED_ON_BC 1
        EarthX = SolarSystem.X[EARTH];
        EarthY = SolarSystem.Y[EARTH];
        EarthZ = SolarSystem.Z[EARTH];

        MoonX = SolarSystem.X[MOON];
        MoonY = SolarSystem.Y[MOON];
        MoonZ = SolarSystem.Z[MOON];
#endif
        printf("\nStart: Earth position: \nx=%f y=%f z=%f  \nMoon position:\nx=%f y=%f z= %f\n Sat position\nx=%f y=%f z= %f\n(run for %ld sec)", 
                 EarthX, 
                 EarthY, 
                 EarthZ,                  
            MoonX - EarthX, MoonY - EarthY, MoonZ - EarthZ, 
            Sat.X[0] - EarthX, Sat.Y[0] - EarthY, Sat.Z[0] - EarthZ, iTotalSec);
        
        double tDeltaEarthN = (( EarthX - StateEarth.Position[0]*1000.0)*( EarthX - StateEarth.Position[0]*1000.0) +
                                             ( EarthY - StateEarth.Position[1]*1000.0)*( EarthY - StateEarth.Position[1]*1000.0) +
                                             ( EarthZ - StateEarth.Position[2]*1000.0)*( EarthZ - StateEarth.Position[2]*1000.0)
                                            );
        printf("\nJPL EPHEMERIDES Earth-Moon Baricenter \nx=%f y=%f z=%f ", 
            StateEarth.Position[0]*1000.0, 
            StateEarth.Position[1]*1000.0, 
            StateEarth.Position[2]*1000.0);
         SYSTEMTIME ThatTime;
        dStartTLEEpoch = ConvertJulianDayToDateAndTime(dStartJD, &ThatTime);

        if (memcmp(Mode,"PROP",4)==0)
        {
            RunProp(&SolarSystem,&Sat,&Engine[0], dStartJD,dStartTLEEpoch, iTotalSec, iItearationsPerSec, TimeSl);
        }
        else if (memcmp(Mode,"SIM",4)==0)
        {
            RunSim(&SolarSystem,&Sat,&Engine[0], dStartJD,dStartTLEEpoch, iTotalSec, iItearationsPerSec, TimeSl);
        }
        else if (memcmp(Mode,"CALC",4)==0)
        {
            RunCalc(&SolarSystem,&Sat,&Engine[0], dStartJD,dStartTLEEpoch, iTotalSec, iItearationsPerSec, TimeSl);
        }
        else if (memcmp(Mode,"OPTIM",5)==0)
        {
        }
        else if (memcmp(Mode,"MASSPOINTS",10)==0)
        {
            MassPointGen(&SolarSystem,&Sat,&Engine[0], dStartJD,dStartTLEEpoch, iTotalSec, iItearationsPerSec, TimeSl);
        }
	}
    if (CpuCore)
    {
        Sat.StopThreads();
    }
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);
	return 0;
}

